// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: lc_kasse_auth/auth.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_lc_5fkasse_5fauth_2fauth_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_lc_5fkasse_5fauth_2fauth_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/timestamp.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_lc_5fkasse_5fauth_2fauth_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_lc_5fkasse_5fauth_2fauth_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_lc_5fkasse_5fauth_2fauth_2eproto;
namespace auth {
class Credentials;
struct CredentialsDefaultTypeInternal;
extern CredentialsDefaultTypeInternal _Credentials_default_instance_;
class EditCommand;
struct EditCommandDefaultTypeInternal;
extern EditCommandDefaultTypeInternal _EditCommand_default_instance_;
class EditCommand_Cancel;
struct EditCommand_CancelDefaultTypeInternal;
extern EditCommand_CancelDefaultTypeInternal _EditCommand_Cancel_default_instance_;
class EditCommand_CreateTerminal;
struct EditCommand_CreateTerminalDefaultTypeInternal;
extern EditCommand_CreateTerminalDefaultTypeInternal _EditCommand_CreateTerminal_default_instance_;
class EditCommand_CreateUser;
struct EditCommand_CreateUserDefaultTypeInternal;
extern EditCommand_CreateUserDefaultTypeInternal _EditCommand_CreateUser_default_instance_;
class EditCommand_CreateUserGroup;
struct EditCommand_CreateUserGroupDefaultTypeInternal;
extern EditCommand_CreateUserGroupDefaultTypeInternal _EditCommand_CreateUserGroup_default_instance_;
class EditCommand_DeleteTerminal;
struct EditCommand_DeleteTerminalDefaultTypeInternal;
extern EditCommand_DeleteTerminalDefaultTypeInternal _EditCommand_DeleteTerminal_default_instance_;
class EditCommand_DeleteUser;
struct EditCommand_DeleteUserDefaultTypeInternal;
extern EditCommand_DeleteUserDefaultTypeInternal _EditCommand_DeleteUser_default_instance_;
class EditCommand_DeleteUserGroup;
struct EditCommand_DeleteUserGroupDefaultTypeInternal;
extern EditCommand_DeleteUserGroupDefaultTypeInternal _EditCommand_DeleteUserGroup_default_instance_;
class EditCommand_GetTerminal;
struct EditCommand_GetTerminalDefaultTypeInternal;
extern EditCommand_GetTerminalDefaultTypeInternal _EditCommand_GetTerminal_default_instance_;
class EditCommand_GetTerminals;
struct EditCommand_GetTerminalsDefaultTypeInternal;
extern EditCommand_GetTerminalsDefaultTypeInternal _EditCommand_GetTerminals_default_instance_;
class EditCommand_GetUser;
struct EditCommand_GetUserDefaultTypeInternal;
extern EditCommand_GetUserDefaultTypeInternal _EditCommand_GetUser_default_instance_;
class EditCommand_GetUserGroup;
struct EditCommand_GetUserGroupDefaultTypeInternal;
extern EditCommand_GetUserGroupDefaultTypeInternal _EditCommand_GetUserGroup_default_instance_;
class EditCommand_Save;
struct EditCommand_SaveDefaultTypeInternal;
extern EditCommand_SaveDefaultTypeInternal _EditCommand_Save_default_instance_;
class EditCommand_UpdateTerminal;
struct EditCommand_UpdateTerminalDefaultTypeInternal;
extern EditCommand_UpdateTerminalDefaultTypeInternal _EditCommand_UpdateTerminal_default_instance_;
class EditCommand_UpdateUser;
struct EditCommand_UpdateUserDefaultTypeInternal;
extern EditCommand_UpdateUserDefaultTypeInternal _EditCommand_UpdateUser_default_instance_;
class EditCommand_UpdateUserGroup;
struct EditCommand_UpdateUserGroupDefaultTypeInternal;
extern EditCommand_UpdateUserGroupDefaultTypeInternal _EditCommand_UpdateUserGroup_default_instance_;
class EditResponse;
struct EditResponseDefaultTypeInternal;
extern EditResponseDefaultTypeInternal _EditResponse_default_instance_;
class EditResponse_CreateTerminal;
struct EditResponse_CreateTerminalDefaultTypeInternal;
extern EditResponse_CreateTerminalDefaultTypeInternal _EditResponse_CreateTerminal_default_instance_;
class EditResponse_CreateUser;
struct EditResponse_CreateUserDefaultTypeInternal;
extern EditResponse_CreateUserDefaultTypeInternal _EditResponse_CreateUser_default_instance_;
class EditResponse_CreateUserGroup;
struct EditResponse_CreateUserGroupDefaultTypeInternal;
extern EditResponse_CreateUserGroupDefaultTypeInternal _EditResponse_CreateUserGroup_default_instance_;
class EditResponse_DeleteTerminal;
struct EditResponse_DeleteTerminalDefaultTypeInternal;
extern EditResponse_DeleteTerminalDefaultTypeInternal _EditResponse_DeleteTerminal_default_instance_;
class EditResponse_DeleteUser;
struct EditResponse_DeleteUserDefaultTypeInternal;
extern EditResponse_DeleteUserDefaultTypeInternal _EditResponse_DeleteUser_default_instance_;
class EditResponse_DeleteUserGroup;
struct EditResponse_DeleteUserGroupDefaultTypeInternal;
extern EditResponse_DeleteUserGroupDefaultTypeInternal _EditResponse_DeleteUserGroup_default_instance_;
class EditResponse_Error;
struct EditResponse_ErrorDefaultTypeInternal;
extern EditResponse_ErrorDefaultTypeInternal _EditResponse_Error_default_instance_;
class EditResponse_GetTerminal;
struct EditResponse_GetTerminalDefaultTypeInternal;
extern EditResponse_GetTerminalDefaultTypeInternal _EditResponse_GetTerminal_default_instance_;
class EditResponse_GetTerminals;
struct EditResponse_GetTerminalsDefaultTypeInternal;
extern EditResponse_GetTerminalsDefaultTypeInternal _EditResponse_GetTerminals_default_instance_;
class EditResponse_GetUser;
struct EditResponse_GetUserDefaultTypeInternal;
extern EditResponse_GetUserDefaultTypeInternal _EditResponse_GetUser_default_instance_;
class EditResponse_GetUserGroup;
struct EditResponse_GetUserGroupDefaultTypeInternal;
extern EditResponse_GetUserGroupDefaultTypeInternal _EditResponse_GetUserGroup_default_instance_;
class EditResponse_GetUserGroupsResponse;
struct EditResponse_GetUserGroupsResponseDefaultTypeInternal;
extern EditResponse_GetUserGroupsResponseDefaultTypeInternal _EditResponse_GetUserGroupsResponse_default_instance_;
class EditResponse_GetUsersByGroupResponse;
struct EditResponse_GetUsersByGroupResponseDefaultTypeInternal;
extern EditResponse_GetUsersByGroupResponseDefaultTypeInternal _EditResponse_GetUsersByGroupResponse_default_instance_;
class EditResponse_TerminalsResp;
struct EditResponse_TerminalsRespDefaultTypeInternal;
extern EditResponse_TerminalsRespDefaultTypeInternal _EditResponse_TerminalsResp_default_instance_;
class EditResponse_UpdateTerminal;
struct EditResponse_UpdateTerminalDefaultTypeInternal;
extern EditResponse_UpdateTerminalDefaultTypeInternal _EditResponse_UpdateTerminal_default_instance_;
class EditResponse_UpdateUser;
struct EditResponse_UpdateUserDefaultTypeInternal;
extern EditResponse_UpdateUserDefaultTypeInternal _EditResponse_UpdateUser_default_instance_;
class EditResponse_UpdateUserGroup;
struct EditResponse_UpdateUserGroupDefaultTypeInternal;
extern EditResponse_UpdateUserGroupDefaultTypeInternal _EditResponse_UpdateUserGroup_default_instance_;
class Empty;
struct EmptyDefaultTypeInternal;
extern EmptyDefaultTypeInternal _Empty_default_instance_;
class Error;
struct ErrorDefaultTypeInternal;
extern ErrorDefaultTypeInternal _Error_default_instance_;
class Events;
struct EventsDefaultTypeInternal;
extern EventsDefaultTypeInternal _Events_default_instance_;
class Events_Event;
struct Events_EventDefaultTypeInternal;
extern Events_EventDefaultTypeInternal _Events_Event_default_instance_;
class GetUserGroupsReq;
struct GetUserGroupsReqDefaultTypeInternal;
extern GetUserGroupsReqDefaultTypeInternal _GetUserGroupsReq_default_instance_;
class GetUserGroupsResp;
struct GetUserGroupsRespDefaultTypeInternal;
extern GetUserGroupsRespDefaultTypeInternal _GetUserGroupsResp_default_instance_;
class GetUsersByGroupReq;
struct GetUsersByGroupReqDefaultTypeInternal;
extern GetUsersByGroupReqDefaultTypeInternal _GetUsersByGroupReq_default_instance_;
class GetUsersByGroupResp;
struct GetUsersByGroupRespDefaultTypeInternal;
extern GetUsersByGroupRespDefaultTypeInternal _GetUsersByGroupResp_default_instance_;
class LoginRequest;
struct LoginRequestDefaultTypeInternal;
extern LoginRequestDefaultTypeInternal _LoginRequest_default_instance_;
class LoginRequest_Logout;
struct LoginRequest_LogoutDefaultTypeInternal;
extern LoginRequest_LogoutDefaultTypeInternal _LoginRequest_Logout_default_instance_;
class LoginResponse;
struct LoginResponseDefaultTypeInternal;
extern LoginResponseDefaultTypeInternal _LoginResponse_default_instance_;
class PaginationRequest;
struct PaginationRequestDefaultTypeInternal;
extern PaginationRequestDefaultTypeInternal _PaginationRequest_default_instance_;
class PaginationResponse;
struct PaginationResponseDefaultTypeInternal;
extern PaginationResponseDefaultTypeInternal _PaginationResponse_default_instance_;
class Session;
struct SessionDefaultTypeInternal;
extern SessionDefaultTypeInternal _Session_default_instance_;
class SubscribeCommands;
struct SubscribeCommandsDefaultTypeInternal;
extern SubscribeCommandsDefaultTypeInternal _SubscribeCommands_default_instance_;
class SubscribeCommands_Subscribe;
struct SubscribeCommands_SubscribeDefaultTypeInternal;
extern SubscribeCommands_SubscribeDefaultTypeInternal _SubscribeCommands_Subscribe_default_instance_;
class SubscribeCommands_Unsubscribe;
struct SubscribeCommands_UnsubscribeDefaultTypeInternal;
extern SubscribeCommands_UnsubscribeDefaultTypeInternal _SubscribeCommands_Unsubscribe_default_instance_;
class Terminal;
struct TerminalDefaultTypeInternal;
extern TerminalDefaultTypeInternal _Terminal_default_instance_;
class Terminals;
struct TerminalsDefaultTypeInternal;
extern TerminalsDefaultTypeInternal _Terminals_default_instance_;
class Token;
struct TokenDefaultTypeInternal;
extern TokenDefaultTypeInternal _Token_default_instance_;
class User;
struct UserDefaultTypeInternal;
extern UserDefaultTypeInternal _User_default_instance_;
class UserGroup;
struct UserGroupDefaultTypeInternal;
extern UserGroupDefaultTypeInternal _UserGroup_default_instance_;
}  // namespace auth
PROTOBUF_NAMESPACE_OPEN
template<> ::auth::Credentials* Arena::CreateMaybeMessage<::auth::Credentials>(Arena*);
template<> ::auth::EditCommand* Arena::CreateMaybeMessage<::auth::EditCommand>(Arena*);
template<> ::auth::EditCommand_Cancel* Arena::CreateMaybeMessage<::auth::EditCommand_Cancel>(Arena*);
template<> ::auth::EditCommand_CreateTerminal* Arena::CreateMaybeMessage<::auth::EditCommand_CreateTerminal>(Arena*);
template<> ::auth::EditCommand_CreateUser* Arena::CreateMaybeMessage<::auth::EditCommand_CreateUser>(Arena*);
template<> ::auth::EditCommand_CreateUserGroup* Arena::CreateMaybeMessage<::auth::EditCommand_CreateUserGroup>(Arena*);
template<> ::auth::EditCommand_DeleteTerminal* Arena::CreateMaybeMessage<::auth::EditCommand_DeleteTerminal>(Arena*);
template<> ::auth::EditCommand_DeleteUser* Arena::CreateMaybeMessage<::auth::EditCommand_DeleteUser>(Arena*);
template<> ::auth::EditCommand_DeleteUserGroup* Arena::CreateMaybeMessage<::auth::EditCommand_DeleteUserGroup>(Arena*);
template<> ::auth::EditCommand_GetTerminal* Arena::CreateMaybeMessage<::auth::EditCommand_GetTerminal>(Arena*);
template<> ::auth::EditCommand_GetTerminals* Arena::CreateMaybeMessage<::auth::EditCommand_GetTerminals>(Arena*);
template<> ::auth::EditCommand_GetUser* Arena::CreateMaybeMessage<::auth::EditCommand_GetUser>(Arena*);
template<> ::auth::EditCommand_GetUserGroup* Arena::CreateMaybeMessage<::auth::EditCommand_GetUserGroup>(Arena*);
template<> ::auth::EditCommand_Save* Arena::CreateMaybeMessage<::auth::EditCommand_Save>(Arena*);
template<> ::auth::EditCommand_UpdateTerminal* Arena::CreateMaybeMessage<::auth::EditCommand_UpdateTerminal>(Arena*);
template<> ::auth::EditCommand_UpdateUser* Arena::CreateMaybeMessage<::auth::EditCommand_UpdateUser>(Arena*);
template<> ::auth::EditCommand_UpdateUserGroup* Arena::CreateMaybeMessage<::auth::EditCommand_UpdateUserGroup>(Arena*);
template<> ::auth::EditResponse* Arena::CreateMaybeMessage<::auth::EditResponse>(Arena*);
template<> ::auth::EditResponse_CreateTerminal* Arena::CreateMaybeMessage<::auth::EditResponse_CreateTerminal>(Arena*);
template<> ::auth::EditResponse_CreateUser* Arena::CreateMaybeMessage<::auth::EditResponse_CreateUser>(Arena*);
template<> ::auth::EditResponse_CreateUserGroup* Arena::CreateMaybeMessage<::auth::EditResponse_CreateUserGroup>(Arena*);
template<> ::auth::EditResponse_DeleteTerminal* Arena::CreateMaybeMessage<::auth::EditResponse_DeleteTerminal>(Arena*);
template<> ::auth::EditResponse_DeleteUser* Arena::CreateMaybeMessage<::auth::EditResponse_DeleteUser>(Arena*);
template<> ::auth::EditResponse_DeleteUserGroup* Arena::CreateMaybeMessage<::auth::EditResponse_DeleteUserGroup>(Arena*);
template<> ::auth::EditResponse_Error* Arena::CreateMaybeMessage<::auth::EditResponse_Error>(Arena*);
template<> ::auth::EditResponse_GetTerminal* Arena::CreateMaybeMessage<::auth::EditResponse_GetTerminal>(Arena*);
template<> ::auth::EditResponse_GetTerminals* Arena::CreateMaybeMessage<::auth::EditResponse_GetTerminals>(Arena*);
template<> ::auth::EditResponse_GetUser* Arena::CreateMaybeMessage<::auth::EditResponse_GetUser>(Arena*);
template<> ::auth::EditResponse_GetUserGroup* Arena::CreateMaybeMessage<::auth::EditResponse_GetUserGroup>(Arena*);
template<> ::auth::EditResponse_GetUserGroupsResponse* Arena::CreateMaybeMessage<::auth::EditResponse_GetUserGroupsResponse>(Arena*);
template<> ::auth::EditResponse_GetUsersByGroupResponse* Arena::CreateMaybeMessage<::auth::EditResponse_GetUsersByGroupResponse>(Arena*);
template<> ::auth::EditResponse_TerminalsResp* Arena::CreateMaybeMessage<::auth::EditResponse_TerminalsResp>(Arena*);
template<> ::auth::EditResponse_UpdateTerminal* Arena::CreateMaybeMessage<::auth::EditResponse_UpdateTerminal>(Arena*);
template<> ::auth::EditResponse_UpdateUser* Arena::CreateMaybeMessage<::auth::EditResponse_UpdateUser>(Arena*);
template<> ::auth::EditResponse_UpdateUserGroup* Arena::CreateMaybeMessage<::auth::EditResponse_UpdateUserGroup>(Arena*);
template<> ::auth::Empty* Arena::CreateMaybeMessage<::auth::Empty>(Arena*);
template<> ::auth::Error* Arena::CreateMaybeMessage<::auth::Error>(Arena*);
template<> ::auth::Events* Arena::CreateMaybeMessage<::auth::Events>(Arena*);
template<> ::auth::Events_Event* Arena::CreateMaybeMessage<::auth::Events_Event>(Arena*);
template<> ::auth::GetUserGroupsReq* Arena::CreateMaybeMessage<::auth::GetUserGroupsReq>(Arena*);
template<> ::auth::GetUserGroupsResp* Arena::CreateMaybeMessage<::auth::GetUserGroupsResp>(Arena*);
template<> ::auth::GetUsersByGroupReq* Arena::CreateMaybeMessage<::auth::GetUsersByGroupReq>(Arena*);
template<> ::auth::GetUsersByGroupResp* Arena::CreateMaybeMessage<::auth::GetUsersByGroupResp>(Arena*);
template<> ::auth::LoginRequest* Arena::CreateMaybeMessage<::auth::LoginRequest>(Arena*);
template<> ::auth::LoginRequest_Logout* Arena::CreateMaybeMessage<::auth::LoginRequest_Logout>(Arena*);
template<> ::auth::LoginResponse* Arena::CreateMaybeMessage<::auth::LoginResponse>(Arena*);
template<> ::auth::PaginationRequest* Arena::CreateMaybeMessage<::auth::PaginationRequest>(Arena*);
template<> ::auth::PaginationResponse* Arena::CreateMaybeMessage<::auth::PaginationResponse>(Arena*);
template<> ::auth::Session* Arena::CreateMaybeMessage<::auth::Session>(Arena*);
template<> ::auth::SubscribeCommands* Arena::CreateMaybeMessage<::auth::SubscribeCommands>(Arena*);
template<> ::auth::SubscribeCommands_Subscribe* Arena::CreateMaybeMessage<::auth::SubscribeCommands_Subscribe>(Arena*);
template<> ::auth::SubscribeCommands_Unsubscribe* Arena::CreateMaybeMessage<::auth::SubscribeCommands_Unsubscribe>(Arena*);
template<> ::auth::Terminal* Arena::CreateMaybeMessage<::auth::Terminal>(Arena*);
template<> ::auth::Terminals* Arena::CreateMaybeMessage<::auth::Terminals>(Arena*);
template<> ::auth::Token* Arena::CreateMaybeMessage<::auth::Token>(Arena*);
template<> ::auth::User* Arena::CreateMaybeMessage<::auth::User>(Arena*);
template<> ::auth::UserGroup* Arena::CreateMaybeMessage<::auth::UserGroup>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace auth {

enum EventType : int {
  CreatedUser = 0,
  UpdatedUser = 1,
  DeletedUser = 2,
  LockedUser = 3,
  CreatedUserGroup = 4,
  UpdateUserGroup = 5,
  DeletedUserGroup = 6,
  LockedUserGroup = 7,
  CreatedTerminal = 8,
  UpdatedTerminal = 9,
  DeletedTerminal = 10,
  LockedTerminal = 11,
  EventType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  EventType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool EventType_IsValid(int value);
constexpr EventType EventType_MIN = CreatedUser;
constexpr EventType EventType_MAX = LockedTerminal;
constexpr int EventType_ARRAYSIZE = EventType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EventType_descriptor();
template<typename T>
inline const std::string& EventType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EventType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EventType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EventType_descriptor(), enum_t_value);
}
inline bool EventType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EventType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EventType>(
    EventType_descriptor(), name, value);
}
// ===================================================================

class Empty final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:auth.Empty) */ {
 public:
  inline Empty() : Empty(nullptr) {}
  explicit PROTOBUF_CONSTEXPR Empty(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Empty(const Empty& from);
  Empty(Empty&& from) noexcept
    : Empty() {
    *this = ::std::move(from);
  }

  inline Empty& operator=(const Empty& from) {
    CopyFrom(from);
    return *this;
  }
  inline Empty& operator=(Empty&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Empty& default_instance() {
    return *internal_default_instance();
  }
  static inline const Empty* internal_default_instance() {
    return reinterpret_cast<const Empty*>(
               &_Empty_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Empty& a, Empty& b) {
    a.Swap(&b);
  }
  inline void Swap(Empty* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Empty* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Empty* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Empty>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Empty& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Empty& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "auth.Empty";
  }
  protected:
  explicit Empty(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:auth.Empty)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_lc_5fkasse_5fauth_2fauth_2eproto;
};
// -------------------------------------------------------------------

class Terminals final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:auth.Terminals) */ {
 public:
  inline Terminals() : Terminals(nullptr) {}
  ~Terminals() override;
  explicit PROTOBUF_CONSTEXPR Terminals(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Terminals(const Terminals& from);
  Terminals(Terminals&& from) noexcept
    : Terminals() {
    *this = ::std::move(from);
  }

  inline Terminals& operator=(const Terminals& from) {
    CopyFrom(from);
    return *this;
  }
  inline Terminals& operator=(Terminals&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Terminals& default_instance() {
    return *internal_default_instance();
  }
  static inline const Terminals* internal_default_instance() {
    return reinterpret_cast<const Terminals*>(
               &_Terminals_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Terminals& a, Terminals& b) {
    a.Swap(&b);
  }
  inline void Swap(Terminals* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Terminals* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Terminals* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Terminals>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Terminals& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Terminals& from) {
    Terminals::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Terminals* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "auth.Terminals";
  }
  protected:
  explicit Terminals(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTerminalsFieldNumber = 1,
  };
  // repeated .auth.Terminal terminals = 1;
  int terminals_size() const;
  private:
  int _internal_terminals_size() const;
  public:
  void clear_terminals();
  ::auth::Terminal* mutable_terminals(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::auth::Terminal >*
      mutable_terminals();
  private:
  const ::auth::Terminal& _internal_terminals(int index) const;
  ::auth::Terminal* _internal_add_terminals();
  public:
  const ::auth::Terminal& terminals(int index) const;
  ::auth::Terminal* add_terminals();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::auth::Terminal >&
      terminals() const;

  // @@protoc_insertion_point(class_scope:auth.Terminals)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::auth::Terminal > terminals_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lc_5fkasse_5fauth_2fauth_2eproto;
};
// -------------------------------------------------------------------

class PaginationRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:auth.PaginationRequest) */ {
 public:
  inline PaginationRequest() : PaginationRequest(nullptr) {}
  ~PaginationRequest() override;
  explicit PROTOBUF_CONSTEXPR PaginationRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PaginationRequest(const PaginationRequest& from);
  PaginationRequest(PaginationRequest&& from) noexcept
    : PaginationRequest() {
    *this = ::std::move(from);
  }

  inline PaginationRequest& operator=(const PaginationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PaginationRequest& operator=(PaginationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PaginationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PaginationRequest* internal_default_instance() {
    return reinterpret_cast<const PaginationRequest*>(
               &_PaginationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(PaginationRequest& a, PaginationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PaginationRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PaginationRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PaginationRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PaginationRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PaginationRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PaginationRequest& from) {
    PaginationRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PaginationRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "auth.PaginationRequest";
  }
  protected:
  explicit PaginationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
    kPageFieldNumber = 2,
    kStartfromIDFieldNumber = 3,
  };
  // uint64 items = 1;
  void clear_items();
  uint64_t items() const;
  void set_items(uint64_t value);
  private:
  uint64_t _internal_items() const;
  void _internal_set_items(uint64_t value);
  public:

  // uint64 page = 2;
  void clear_page();
  uint64_t page() const;
  void set_page(uint64_t value);
  private:
  uint64_t _internal_page() const;
  void _internal_set_page(uint64_t value);
  public:

  // uint64 startfromID = 3;
  void clear_startfromid();
  uint64_t startfromid() const;
  void set_startfromid(uint64_t value);
  private:
  uint64_t _internal_startfromid() const;
  void _internal_set_startfromid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:auth.PaginationRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t items_;
    uint64_t page_;
    uint64_t startfromid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lc_5fkasse_5fauth_2fauth_2eproto;
};
// -------------------------------------------------------------------

class PaginationResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:auth.PaginationResponse) */ {
 public:
  inline PaginationResponse() : PaginationResponse(nullptr) {}
  ~PaginationResponse() override;
  explicit PROTOBUF_CONSTEXPR PaginationResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PaginationResponse(const PaginationResponse& from);
  PaginationResponse(PaginationResponse&& from) noexcept
    : PaginationResponse() {
    *this = ::std::move(from);
  }

  inline PaginationResponse& operator=(const PaginationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PaginationResponse& operator=(PaginationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PaginationResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PaginationResponse* internal_default_instance() {
    return reinterpret_cast<const PaginationResponse*>(
               &_PaginationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(PaginationResponse& a, PaginationResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PaginationResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PaginationResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PaginationResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PaginationResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PaginationResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PaginationResponse& from) {
    PaginationResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PaginationResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "auth.PaginationResponse";
  }
  protected:
  explicit PaginationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPageFieldNumber = 1,
    kPagesFieldNumber = 2,
  };
  // uint64 page = 1;
  void clear_page();
  uint64_t page() const;
  void set_page(uint64_t value);
  private:
  uint64_t _internal_page() const;
  void _internal_set_page(uint64_t value);
  public:

  // uint64 pages = 2;
  void clear_pages();
  uint64_t pages() const;
  void set_pages(uint64_t value);
  private:
  uint64_t _internal_pages() const;
  void _internal_set_pages(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:auth.PaginationResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t page_;
    uint64_t pages_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lc_5fkasse_5fauth_2fauth_2eproto;
};
// -------------------------------------------------------------------

class GetUsersByGroupReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:auth.GetUsersByGroupReq) */ {
 public:
  inline GetUsersByGroupReq() : GetUsersByGroupReq(nullptr) {}
  ~GetUsersByGroupReq() override;
  explicit PROTOBUF_CONSTEXPR GetUsersByGroupReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetUsersByGroupReq(const GetUsersByGroupReq& from);
  GetUsersByGroupReq(GetUsersByGroupReq&& from) noexcept
    : GetUsersByGroupReq() {
    *this = ::std::move(from);
  }

  inline GetUsersByGroupReq& operator=(const GetUsersByGroupReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetUsersByGroupReq& operator=(GetUsersByGroupReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetUsersByGroupReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetUsersByGroupReq* internal_default_instance() {
    return reinterpret_cast<const GetUsersByGroupReq*>(
               &_GetUsersByGroupReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(GetUsersByGroupReq& a, GetUsersByGroupReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetUsersByGroupReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetUsersByGroupReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetUsersByGroupReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetUsersByGroupReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetUsersByGroupReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetUsersByGroupReq& from) {
    GetUsersByGroupReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetUsersByGroupReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "auth.GetUsersByGroupReq";
  }
  protected:
  explicit GetUsersByGroupReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPaginationreqFieldNumber = 2,
    kGroupidFieldNumber = 1,
  };
  // .auth.PaginationRequest paginationreq = 2;
  bool has_paginationreq() const;
  private:
  bool _internal_has_paginationreq() const;
  public:
  void clear_paginationreq();
  const ::auth::PaginationRequest& paginationreq() const;
  PROTOBUF_NODISCARD ::auth::PaginationRequest* release_paginationreq();
  ::auth::PaginationRequest* mutable_paginationreq();
  void set_allocated_paginationreq(::auth::PaginationRequest* paginationreq);
  private:
  const ::auth::PaginationRequest& _internal_paginationreq() const;
  ::auth::PaginationRequest* _internal_mutable_paginationreq();
  public:
  void unsafe_arena_set_allocated_paginationreq(
      ::auth::PaginationRequest* paginationreq);
  ::auth::PaginationRequest* unsafe_arena_release_paginationreq();

  // uint64 groupid = 1;
  void clear_groupid();
  uint64_t groupid() const;
  void set_groupid(uint64_t value);
  private:
  uint64_t _internal_groupid() const;
  void _internal_set_groupid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:auth.GetUsersByGroupReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::auth::PaginationRequest* paginationreq_;
    uint64_t groupid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lc_5fkasse_5fauth_2fauth_2eproto;
};
// -------------------------------------------------------------------

class GetUsersByGroupResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:auth.GetUsersByGroupResp) */ {
 public:
  inline GetUsersByGroupResp() : GetUsersByGroupResp(nullptr) {}
  ~GetUsersByGroupResp() override;
  explicit PROTOBUF_CONSTEXPR GetUsersByGroupResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetUsersByGroupResp(const GetUsersByGroupResp& from);
  GetUsersByGroupResp(GetUsersByGroupResp&& from) noexcept
    : GetUsersByGroupResp() {
    *this = ::std::move(from);
  }

  inline GetUsersByGroupResp& operator=(const GetUsersByGroupResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetUsersByGroupResp& operator=(GetUsersByGroupResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetUsersByGroupResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetUsersByGroupResp* internal_default_instance() {
    return reinterpret_cast<const GetUsersByGroupResp*>(
               &_GetUsersByGroupResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(GetUsersByGroupResp& a, GetUsersByGroupResp& b) {
    a.Swap(&b);
  }
  inline void Swap(GetUsersByGroupResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetUsersByGroupResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetUsersByGroupResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetUsersByGroupResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetUsersByGroupResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetUsersByGroupResp& from) {
    GetUsersByGroupResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetUsersByGroupResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "auth.GetUsersByGroupResp";
  }
  protected:
  explicit GetUsersByGroupResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsersFieldNumber = 1,
    kPaginationrespFieldNumber = 2,
  };
  // repeated .auth.User users = 1;
  int users_size() const;
  private:
  int _internal_users_size() const;
  public:
  void clear_users();
  ::auth::User* mutable_users(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::auth::User >*
      mutable_users();
  private:
  const ::auth::User& _internal_users(int index) const;
  ::auth::User* _internal_add_users();
  public:
  const ::auth::User& users(int index) const;
  ::auth::User* add_users();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::auth::User >&
      users() const;

  // .auth.PaginationResponse paginationresp = 2;
  bool has_paginationresp() const;
  private:
  bool _internal_has_paginationresp() const;
  public:
  void clear_paginationresp();
  const ::auth::PaginationResponse& paginationresp() const;
  PROTOBUF_NODISCARD ::auth::PaginationResponse* release_paginationresp();
  ::auth::PaginationResponse* mutable_paginationresp();
  void set_allocated_paginationresp(::auth::PaginationResponse* paginationresp);
  private:
  const ::auth::PaginationResponse& _internal_paginationresp() const;
  ::auth::PaginationResponse* _internal_mutable_paginationresp();
  public:
  void unsafe_arena_set_allocated_paginationresp(
      ::auth::PaginationResponse* paginationresp);
  ::auth::PaginationResponse* unsafe_arena_release_paginationresp();

  // @@protoc_insertion_point(class_scope:auth.GetUsersByGroupResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::auth::User > users_;
    ::auth::PaginationResponse* paginationresp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lc_5fkasse_5fauth_2fauth_2eproto;
};
// -------------------------------------------------------------------

class GetUserGroupsReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:auth.GetUserGroupsReq) */ {
 public:
  inline GetUserGroupsReq() : GetUserGroupsReq(nullptr) {}
  ~GetUserGroupsReq() override;
  explicit PROTOBUF_CONSTEXPR GetUserGroupsReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetUserGroupsReq(const GetUserGroupsReq& from);
  GetUserGroupsReq(GetUserGroupsReq&& from) noexcept
    : GetUserGroupsReq() {
    *this = ::std::move(from);
  }

  inline GetUserGroupsReq& operator=(const GetUserGroupsReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetUserGroupsReq& operator=(GetUserGroupsReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetUserGroupsReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetUserGroupsReq* internal_default_instance() {
    return reinterpret_cast<const GetUserGroupsReq*>(
               &_GetUserGroupsReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(GetUserGroupsReq& a, GetUserGroupsReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetUserGroupsReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetUserGroupsReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetUserGroupsReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetUserGroupsReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetUserGroupsReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetUserGroupsReq& from) {
    GetUserGroupsReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetUserGroupsReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "auth.GetUserGroupsReq";
  }
  protected:
  explicit GetUserGroupsReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPaginationreqFieldNumber = 1,
  };
  // .auth.PaginationRequest paginationreq = 1;
  bool has_paginationreq() const;
  private:
  bool _internal_has_paginationreq() const;
  public:
  void clear_paginationreq();
  const ::auth::PaginationRequest& paginationreq() const;
  PROTOBUF_NODISCARD ::auth::PaginationRequest* release_paginationreq();
  ::auth::PaginationRequest* mutable_paginationreq();
  void set_allocated_paginationreq(::auth::PaginationRequest* paginationreq);
  private:
  const ::auth::PaginationRequest& _internal_paginationreq() const;
  ::auth::PaginationRequest* _internal_mutable_paginationreq();
  public:
  void unsafe_arena_set_allocated_paginationreq(
      ::auth::PaginationRequest* paginationreq);
  ::auth::PaginationRequest* unsafe_arena_release_paginationreq();

  // @@protoc_insertion_point(class_scope:auth.GetUserGroupsReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::auth::PaginationRequest* paginationreq_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lc_5fkasse_5fauth_2fauth_2eproto;
};
// -------------------------------------------------------------------

class GetUserGroupsResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:auth.GetUserGroupsResp) */ {
 public:
  inline GetUserGroupsResp() : GetUserGroupsResp(nullptr) {}
  ~GetUserGroupsResp() override;
  explicit PROTOBUF_CONSTEXPR GetUserGroupsResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetUserGroupsResp(const GetUserGroupsResp& from);
  GetUserGroupsResp(GetUserGroupsResp&& from) noexcept
    : GetUserGroupsResp() {
    *this = ::std::move(from);
  }

  inline GetUserGroupsResp& operator=(const GetUserGroupsResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetUserGroupsResp& operator=(GetUserGroupsResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetUserGroupsResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetUserGroupsResp* internal_default_instance() {
    return reinterpret_cast<const GetUserGroupsResp*>(
               &_GetUserGroupsResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(GetUserGroupsResp& a, GetUserGroupsResp& b) {
    a.Swap(&b);
  }
  inline void Swap(GetUserGroupsResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetUserGroupsResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetUserGroupsResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetUserGroupsResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetUserGroupsResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetUserGroupsResp& from) {
    GetUserGroupsResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetUserGroupsResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "auth.GetUserGroupsResp";
  }
  protected:
  explicit GetUserGroupsResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGroupsFieldNumber = 1,
    kPaginationrespFieldNumber = 2,
  };
  // repeated .auth.UserGroup groups = 1;
  int groups_size() const;
  private:
  int _internal_groups_size() const;
  public:
  void clear_groups();
  ::auth::UserGroup* mutable_groups(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::auth::UserGroup >*
      mutable_groups();
  private:
  const ::auth::UserGroup& _internal_groups(int index) const;
  ::auth::UserGroup* _internal_add_groups();
  public:
  const ::auth::UserGroup& groups(int index) const;
  ::auth::UserGroup* add_groups();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::auth::UserGroup >&
      groups() const;

  // .auth.PaginationResponse paginationresp = 2;
  bool has_paginationresp() const;
  private:
  bool _internal_has_paginationresp() const;
  public:
  void clear_paginationresp();
  const ::auth::PaginationResponse& paginationresp() const;
  PROTOBUF_NODISCARD ::auth::PaginationResponse* release_paginationresp();
  ::auth::PaginationResponse* mutable_paginationresp();
  void set_allocated_paginationresp(::auth::PaginationResponse* paginationresp);
  private:
  const ::auth::PaginationResponse& _internal_paginationresp() const;
  ::auth::PaginationResponse* _internal_mutable_paginationresp();
  public:
  void unsafe_arena_set_allocated_paginationresp(
      ::auth::PaginationResponse* paginationresp);
  ::auth::PaginationResponse* unsafe_arena_release_paginationresp();

  // @@protoc_insertion_point(class_scope:auth.GetUserGroupsResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::auth::UserGroup > groups_;
    ::auth::PaginationResponse* paginationresp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lc_5fkasse_5fauth_2fauth_2eproto;
};
// -------------------------------------------------------------------

class EditCommand_GetUser final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:auth.EditCommand.GetUser) */ {
 public:
  inline EditCommand_GetUser() : EditCommand_GetUser(nullptr) {}
  ~EditCommand_GetUser() override;
  explicit PROTOBUF_CONSTEXPR EditCommand_GetUser(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EditCommand_GetUser(const EditCommand_GetUser& from);
  EditCommand_GetUser(EditCommand_GetUser&& from) noexcept
    : EditCommand_GetUser() {
    *this = ::std::move(from);
  }

  inline EditCommand_GetUser& operator=(const EditCommand_GetUser& from) {
    CopyFrom(from);
    return *this;
  }
  inline EditCommand_GetUser& operator=(EditCommand_GetUser&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EditCommand_GetUser& default_instance() {
    return *internal_default_instance();
  }
  static inline const EditCommand_GetUser* internal_default_instance() {
    return reinterpret_cast<const EditCommand_GetUser*>(
               &_EditCommand_GetUser_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(EditCommand_GetUser& a, EditCommand_GetUser& b) {
    a.Swap(&b);
  }
  inline void Swap(EditCommand_GetUser* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EditCommand_GetUser* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EditCommand_GetUser* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EditCommand_GetUser>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EditCommand_GetUser& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EditCommand_GetUser& from) {
    EditCommand_GetUser::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EditCommand_GetUser* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "auth.EditCommand.GetUser";
  }
  protected:
  explicit EditCommand_GetUser(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // uint64 id = 1;
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:auth.EditCommand.GetUser)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lc_5fkasse_5fauth_2fauth_2eproto;
};
// -------------------------------------------------------------------

class EditCommand_GetUserGroup final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:auth.EditCommand.GetUserGroup) */ {
 public:
  inline EditCommand_GetUserGroup() : EditCommand_GetUserGroup(nullptr) {}
  ~EditCommand_GetUserGroup() override;
  explicit PROTOBUF_CONSTEXPR EditCommand_GetUserGroup(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EditCommand_GetUserGroup(const EditCommand_GetUserGroup& from);
  EditCommand_GetUserGroup(EditCommand_GetUserGroup&& from) noexcept
    : EditCommand_GetUserGroup() {
    *this = ::std::move(from);
  }

  inline EditCommand_GetUserGroup& operator=(const EditCommand_GetUserGroup& from) {
    CopyFrom(from);
    return *this;
  }
  inline EditCommand_GetUserGroup& operator=(EditCommand_GetUserGroup&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EditCommand_GetUserGroup& default_instance() {
    return *internal_default_instance();
  }
  static inline const EditCommand_GetUserGroup* internal_default_instance() {
    return reinterpret_cast<const EditCommand_GetUserGroup*>(
               &_EditCommand_GetUserGroup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(EditCommand_GetUserGroup& a, EditCommand_GetUserGroup& b) {
    a.Swap(&b);
  }
  inline void Swap(EditCommand_GetUserGroup* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EditCommand_GetUserGroup* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EditCommand_GetUserGroup* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EditCommand_GetUserGroup>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EditCommand_GetUserGroup& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EditCommand_GetUserGroup& from) {
    EditCommand_GetUserGroup::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EditCommand_GetUserGroup* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "auth.EditCommand.GetUserGroup";
  }
  protected:
  explicit EditCommand_GetUserGroup(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // uint64 id = 1;
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:auth.EditCommand.GetUserGroup)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lc_5fkasse_5fauth_2fauth_2eproto;
};
// -------------------------------------------------------------------

class EditCommand_UpdateUser final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:auth.EditCommand.UpdateUser) */ {
 public:
  inline EditCommand_UpdateUser() : EditCommand_UpdateUser(nullptr) {}
  ~EditCommand_UpdateUser() override;
  explicit PROTOBUF_CONSTEXPR EditCommand_UpdateUser(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EditCommand_UpdateUser(const EditCommand_UpdateUser& from);
  EditCommand_UpdateUser(EditCommand_UpdateUser&& from) noexcept
    : EditCommand_UpdateUser() {
    *this = ::std::move(from);
  }

  inline EditCommand_UpdateUser& operator=(const EditCommand_UpdateUser& from) {
    CopyFrom(from);
    return *this;
  }
  inline EditCommand_UpdateUser& operator=(EditCommand_UpdateUser&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EditCommand_UpdateUser& default_instance() {
    return *internal_default_instance();
  }
  static inline const EditCommand_UpdateUser* internal_default_instance() {
    return reinterpret_cast<const EditCommand_UpdateUser*>(
               &_EditCommand_UpdateUser_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(EditCommand_UpdateUser& a, EditCommand_UpdateUser& b) {
    a.Swap(&b);
  }
  inline void Swap(EditCommand_UpdateUser* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EditCommand_UpdateUser* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EditCommand_UpdateUser* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EditCommand_UpdateUser>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EditCommand_UpdateUser& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EditCommand_UpdateUser& from) {
    EditCommand_UpdateUser::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EditCommand_UpdateUser* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "auth.EditCommand.UpdateUser";
  }
  protected:
  explicit EditCommand_UpdateUser(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserFieldNumber = 1,
  };
  // .auth.User user = 1;
  bool has_user() const;
  private:
  bool _internal_has_user() const;
  public:
  void clear_user();
  const ::auth::User& user() const;
  PROTOBUF_NODISCARD ::auth::User* release_user();
  ::auth::User* mutable_user();
  void set_allocated_user(::auth::User* user);
  private:
  const ::auth::User& _internal_user() const;
  ::auth::User* _internal_mutable_user();
  public:
  void unsafe_arena_set_allocated_user(
      ::auth::User* user);
  ::auth::User* unsafe_arena_release_user();

  // @@protoc_insertion_point(class_scope:auth.EditCommand.UpdateUser)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::auth::User* user_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lc_5fkasse_5fauth_2fauth_2eproto;
};
// -------------------------------------------------------------------

class EditCommand_UpdateUserGroup final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:auth.EditCommand.UpdateUserGroup) */ {
 public:
  inline EditCommand_UpdateUserGroup() : EditCommand_UpdateUserGroup(nullptr) {}
  ~EditCommand_UpdateUserGroup() override;
  explicit PROTOBUF_CONSTEXPR EditCommand_UpdateUserGroup(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EditCommand_UpdateUserGroup(const EditCommand_UpdateUserGroup& from);
  EditCommand_UpdateUserGroup(EditCommand_UpdateUserGroup&& from) noexcept
    : EditCommand_UpdateUserGroup() {
    *this = ::std::move(from);
  }

  inline EditCommand_UpdateUserGroup& operator=(const EditCommand_UpdateUserGroup& from) {
    CopyFrom(from);
    return *this;
  }
  inline EditCommand_UpdateUserGroup& operator=(EditCommand_UpdateUserGroup&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EditCommand_UpdateUserGroup& default_instance() {
    return *internal_default_instance();
  }
  static inline const EditCommand_UpdateUserGroup* internal_default_instance() {
    return reinterpret_cast<const EditCommand_UpdateUserGroup*>(
               &_EditCommand_UpdateUserGroup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(EditCommand_UpdateUserGroup& a, EditCommand_UpdateUserGroup& b) {
    a.Swap(&b);
  }
  inline void Swap(EditCommand_UpdateUserGroup* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EditCommand_UpdateUserGroup* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EditCommand_UpdateUserGroup* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EditCommand_UpdateUserGroup>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EditCommand_UpdateUserGroup& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EditCommand_UpdateUserGroup& from) {
    EditCommand_UpdateUserGroup::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EditCommand_UpdateUserGroup* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "auth.EditCommand.UpdateUserGroup";
  }
  protected:
  explicit EditCommand_UpdateUserGroup(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGroupFieldNumber = 1,
  };
  // .auth.UserGroup group = 1;
  bool has_group() const;
  private:
  bool _internal_has_group() const;
  public:
  void clear_group();
  const ::auth::UserGroup& group() const;
  PROTOBUF_NODISCARD ::auth::UserGroup* release_group();
  ::auth::UserGroup* mutable_group();
  void set_allocated_group(::auth::UserGroup* group);
  private:
  const ::auth::UserGroup& _internal_group() const;
  ::auth::UserGroup* _internal_mutable_group();
  public:
  void unsafe_arena_set_allocated_group(
      ::auth::UserGroup* group);
  ::auth::UserGroup* unsafe_arena_release_group();

  // @@protoc_insertion_point(class_scope:auth.EditCommand.UpdateUserGroup)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::auth::UserGroup* group_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lc_5fkasse_5fauth_2fauth_2eproto;
};
// -------------------------------------------------------------------

class EditCommand_DeleteUser final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:auth.EditCommand.DeleteUser) */ {
 public:
  inline EditCommand_DeleteUser() : EditCommand_DeleteUser(nullptr) {}
  ~EditCommand_DeleteUser() override;
  explicit PROTOBUF_CONSTEXPR EditCommand_DeleteUser(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EditCommand_DeleteUser(const EditCommand_DeleteUser& from);
  EditCommand_DeleteUser(EditCommand_DeleteUser&& from) noexcept
    : EditCommand_DeleteUser() {
    *this = ::std::move(from);
  }

  inline EditCommand_DeleteUser& operator=(const EditCommand_DeleteUser& from) {
    CopyFrom(from);
    return *this;
  }
  inline EditCommand_DeleteUser& operator=(EditCommand_DeleteUser&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EditCommand_DeleteUser& default_instance() {
    return *internal_default_instance();
  }
  static inline const EditCommand_DeleteUser* internal_default_instance() {
    return reinterpret_cast<const EditCommand_DeleteUser*>(
               &_EditCommand_DeleteUser_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(EditCommand_DeleteUser& a, EditCommand_DeleteUser& b) {
    a.Swap(&b);
  }
  inline void Swap(EditCommand_DeleteUser* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EditCommand_DeleteUser* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EditCommand_DeleteUser* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EditCommand_DeleteUser>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EditCommand_DeleteUser& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EditCommand_DeleteUser& from) {
    EditCommand_DeleteUser::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EditCommand_DeleteUser* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "auth.EditCommand.DeleteUser";
  }
  protected:
  explicit EditCommand_DeleteUser(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // uint64 id = 1;
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:auth.EditCommand.DeleteUser)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lc_5fkasse_5fauth_2fauth_2eproto;
};
// -------------------------------------------------------------------

class EditCommand_DeleteUserGroup final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:auth.EditCommand.DeleteUserGroup) */ {
 public:
  inline EditCommand_DeleteUserGroup() : EditCommand_DeleteUserGroup(nullptr) {}
  ~EditCommand_DeleteUserGroup() override;
  explicit PROTOBUF_CONSTEXPR EditCommand_DeleteUserGroup(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EditCommand_DeleteUserGroup(const EditCommand_DeleteUserGroup& from);
  EditCommand_DeleteUserGroup(EditCommand_DeleteUserGroup&& from) noexcept
    : EditCommand_DeleteUserGroup() {
    *this = ::std::move(from);
  }

  inline EditCommand_DeleteUserGroup& operator=(const EditCommand_DeleteUserGroup& from) {
    CopyFrom(from);
    return *this;
  }
  inline EditCommand_DeleteUserGroup& operator=(EditCommand_DeleteUserGroup&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EditCommand_DeleteUserGroup& default_instance() {
    return *internal_default_instance();
  }
  static inline const EditCommand_DeleteUserGroup* internal_default_instance() {
    return reinterpret_cast<const EditCommand_DeleteUserGroup*>(
               &_EditCommand_DeleteUserGroup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(EditCommand_DeleteUserGroup& a, EditCommand_DeleteUserGroup& b) {
    a.Swap(&b);
  }
  inline void Swap(EditCommand_DeleteUserGroup* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EditCommand_DeleteUserGroup* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EditCommand_DeleteUserGroup* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EditCommand_DeleteUserGroup>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EditCommand_DeleteUserGroup& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EditCommand_DeleteUserGroup& from) {
    EditCommand_DeleteUserGroup::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EditCommand_DeleteUserGroup* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "auth.EditCommand.DeleteUserGroup";
  }
  protected:
  explicit EditCommand_DeleteUserGroup(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // uint64 id = 1;
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:auth.EditCommand.DeleteUserGroup)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lc_5fkasse_5fauth_2fauth_2eproto;
};
// -------------------------------------------------------------------

class EditCommand_CreateUser final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:auth.EditCommand.CreateUser) */ {
 public:
  inline EditCommand_CreateUser() : EditCommand_CreateUser(nullptr) {}
  ~EditCommand_CreateUser() override;
  explicit PROTOBUF_CONSTEXPR EditCommand_CreateUser(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EditCommand_CreateUser(const EditCommand_CreateUser& from);
  EditCommand_CreateUser(EditCommand_CreateUser&& from) noexcept
    : EditCommand_CreateUser() {
    *this = ::std::move(from);
  }

  inline EditCommand_CreateUser& operator=(const EditCommand_CreateUser& from) {
    CopyFrom(from);
    return *this;
  }
  inline EditCommand_CreateUser& operator=(EditCommand_CreateUser&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EditCommand_CreateUser& default_instance() {
    return *internal_default_instance();
  }
  static inline const EditCommand_CreateUser* internal_default_instance() {
    return reinterpret_cast<const EditCommand_CreateUser*>(
               &_EditCommand_CreateUser_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(EditCommand_CreateUser& a, EditCommand_CreateUser& b) {
    a.Swap(&b);
  }
  inline void Swap(EditCommand_CreateUser* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EditCommand_CreateUser* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EditCommand_CreateUser* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EditCommand_CreateUser>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EditCommand_CreateUser& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EditCommand_CreateUser& from) {
    EditCommand_CreateUser::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EditCommand_CreateUser* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "auth.EditCommand.CreateUser";
  }
  protected:
  explicit EditCommand_CreateUser(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserFieldNumber = 1,
  };
  // .auth.User user = 1;
  bool has_user() const;
  private:
  bool _internal_has_user() const;
  public:
  void clear_user();
  const ::auth::User& user() const;
  PROTOBUF_NODISCARD ::auth::User* release_user();
  ::auth::User* mutable_user();
  void set_allocated_user(::auth::User* user);
  private:
  const ::auth::User& _internal_user() const;
  ::auth::User* _internal_mutable_user();
  public:
  void unsafe_arena_set_allocated_user(
      ::auth::User* user);
  ::auth::User* unsafe_arena_release_user();

  // @@protoc_insertion_point(class_scope:auth.EditCommand.CreateUser)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::auth::User* user_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lc_5fkasse_5fauth_2fauth_2eproto;
};
// -------------------------------------------------------------------

class EditCommand_CreateUserGroup final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:auth.EditCommand.CreateUserGroup) */ {
 public:
  inline EditCommand_CreateUserGroup() : EditCommand_CreateUserGroup(nullptr) {}
  ~EditCommand_CreateUserGroup() override;
  explicit PROTOBUF_CONSTEXPR EditCommand_CreateUserGroup(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EditCommand_CreateUserGroup(const EditCommand_CreateUserGroup& from);
  EditCommand_CreateUserGroup(EditCommand_CreateUserGroup&& from) noexcept
    : EditCommand_CreateUserGroup() {
    *this = ::std::move(from);
  }

  inline EditCommand_CreateUserGroup& operator=(const EditCommand_CreateUserGroup& from) {
    CopyFrom(from);
    return *this;
  }
  inline EditCommand_CreateUserGroup& operator=(EditCommand_CreateUserGroup&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EditCommand_CreateUserGroup& default_instance() {
    return *internal_default_instance();
  }
  static inline const EditCommand_CreateUserGroup* internal_default_instance() {
    return reinterpret_cast<const EditCommand_CreateUserGroup*>(
               &_EditCommand_CreateUserGroup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(EditCommand_CreateUserGroup& a, EditCommand_CreateUserGroup& b) {
    a.Swap(&b);
  }
  inline void Swap(EditCommand_CreateUserGroup* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EditCommand_CreateUserGroup* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EditCommand_CreateUserGroup* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EditCommand_CreateUserGroup>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EditCommand_CreateUserGroup& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EditCommand_CreateUserGroup& from) {
    EditCommand_CreateUserGroup::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EditCommand_CreateUserGroup* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "auth.EditCommand.CreateUserGroup";
  }
  protected:
  explicit EditCommand_CreateUserGroup(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGroupFieldNumber = 1,
  };
  // .auth.UserGroup group = 1;
  bool has_group() const;
  private:
  bool _internal_has_group() const;
  public:
  void clear_group();
  const ::auth::UserGroup& group() const;
  PROTOBUF_NODISCARD ::auth::UserGroup* release_group();
  ::auth::UserGroup* mutable_group();
  void set_allocated_group(::auth::UserGroup* group);
  private:
  const ::auth::UserGroup& _internal_group() const;
  ::auth::UserGroup* _internal_mutable_group();
  public:
  void unsafe_arena_set_allocated_group(
      ::auth::UserGroup* group);
  ::auth::UserGroup* unsafe_arena_release_group();

  // @@protoc_insertion_point(class_scope:auth.EditCommand.CreateUserGroup)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::auth::UserGroup* group_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lc_5fkasse_5fauth_2fauth_2eproto;
};
// -------------------------------------------------------------------

class EditCommand_GetTerminal final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:auth.EditCommand.GetTerminal) */ {
 public:
  inline EditCommand_GetTerminal() : EditCommand_GetTerminal(nullptr) {}
  ~EditCommand_GetTerminal() override;
  explicit PROTOBUF_CONSTEXPR EditCommand_GetTerminal(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EditCommand_GetTerminal(const EditCommand_GetTerminal& from);
  EditCommand_GetTerminal(EditCommand_GetTerminal&& from) noexcept
    : EditCommand_GetTerminal() {
    *this = ::std::move(from);
  }

  inline EditCommand_GetTerminal& operator=(const EditCommand_GetTerminal& from) {
    CopyFrom(from);
    return *this;
  }
  inline EditCommand_GetTerminal& operator=(EditCommand_GetTerminal&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EditCommand_GetTerminal& default_instance() {
    return *internal_default_instance();
  }
  static inline const EditCommand_GetTerminal* internal_default_instance() {
    return reinterpret_cast<const EditCommand_GetTerminal*>(
               &_EditCommand_GetTerminal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(EditCommand_GetTerminal& a, EditCommand_GetTerminal& b) {
    a.Swap(&b);
  }
  inline void Swap(EditCommand_GetTerminal* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EditCommand_GetTerminal* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EditCommand_GetTerminal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EditCommand_GetTerminal>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EditCommand_GetTerminal& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EditCommand_GetTerminal& from) {
    EditCommand_GetTerminal::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EditCommand_GetTerminal* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "auth.EditCommand.GetTerminal";
  }
  protected:
  explicit EditCommand_GetTerminal(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // uint64 id = 1;
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:auth.EditCommand.GetTerminal)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lc_5fkasse_5fauth_2fauth_2eproto;
};
// -------------------------------------------------------------------

class EditCommand_UpdateTerminal final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:auth.EditCommand.UpdateTerminal) */ {
 public:
  inline EditCommand_UpdateTerminal() : EditCommand_UpdateTerminal(nullptr) {}
  ~EditCommand_UpdateTerminal() override;
  explicit PROTOBUF_CONSTEXPR EditCommand_UpdateTerminal(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EditCommand_UpdateTerminal(const EditCommand_UpdateTerminal& from);
  EditCommand_UpdateTerminal(EditCommand_UpdateTerminal&& from) noexcept
    : EditCommand_UpdateTerminal() {
    *this = ::std::move(from);
  }

  inline EditCommand_UpdateTerminal& operator=(const EditCommand_UpdateTerminal& from) {
    CopyFrom(from);
    return *this;
  }
  inline EditCommand_UpdateTerminal& operator=(EditCommand_UpdateTerminal&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EditCommand_UpdateTerminal& default_instance() {
    return *internal_default_instance();
  }
  static inline const EditCommand_UpdateTerminal* internal_default_instance() {
    return reinterpret_cast<const EditCommand_UpdateTerminal*>(
               &_EditCommand_UpdateTerminal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(EditCommand_UpdateTerminal& a, EditCommand_UpdateTerminal& b) {
    a.Swap(&b);
  }
  inline void Swap(EditCommand_UpdateTerminal* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EditCommand_UpdateTerminal* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EditCommand_UpdateTerminal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EditCommand_UpdateTerminal>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EditCommand_UpdateTerminal& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EditCommand_UpdateTerminal& from) {
    EditCommand_UpdateTerminal::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EditCommand_UpdateTerminal* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "auth.EditCommand.UpdateTerminal";
  }
  protected:
  explicit EditCommand_UpdateTerminal(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTerminalFieldNumber = 1,
  };
  // .auth.Terminal terminal = 1;
  bool has_terminal() const;
  private:
  bool _internal_has_terminal() const;
  public:
  void clear_terminal();
  const ::auth::Terminal& terminal() const;
  PROTOBUF_NODISCARD ::auth::Terminal* release_terminal();
  ::auth::Terminal* mutable_terminal();
  void set_allocated_terminal(::auth::Terminal* terminal);
  private:
  const ::auth::Terminal& _internal_terminal() const;
  ::auth::Terminal* _internal_mutable_terminal();
  public:
  void unsafe_arena_set_allocated_terminal(
      ::auth::Terminal* terminal);
  ::auth::Terminal* unsafe_arena_release_terminal();

  // @@protoc_insertion_point(class_scope:auth.EditCommand.UpdateTerminal)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::auth::Terminal* terminal_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lc_5fkasse_5fauth_2fauth_2eproto;
};
// -------------------------------------------------------------------

class EditCommand_DeleteTerminal final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:auth.EditCommand.DeleteTerminal) */ {
 public:
  inline EditCommand_DeleteTerminal() : EditCommand_DeleteTerminal(nullptr) {}
  ~EditCommand_DeleteTerminal() override;
  explicit PROTOBUF_CONSTEXPR EditCommand_DeleteTerminal(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EditCommand_DeleteTerminal(const EditCommand_DeleteTerminal& from);
  EditCommand_DeleteTerminal(EditCommand_DeleteTerminal&& from) noexcept
    : EditCommand_DeleteTerminal() {
    *this = ::std::move(from);
  }

  inline EditCommand_DeleteTerminal& operator=(const EditCommand_DeleteTerminal& from) {
    CopyFrom(from);
    return *this;
  }
  inline EditCommand_DeleteTerminal& operator=(EditCommand_DeleteTerminal&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EditCommand_DeleteTerminal& default_instance() {
    return *internal_default_instance();
  }
  static inline const EditCommand_DeleteTerminal* internal_default_instance() {
    return reinterpret_cast<const EditCommand_DeleteTerminal*>(
               &_EditCommand_DeleteTerminal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(EditCommand_DeleteTerminal& a, EditCommand_DeleteTerminal& b) {
    a.Swap(&b);
  }
  inline void Swap(EditCommand_DeleteTerminal* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EditCommand_DeleteTerminal* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EditCommand_DeleteTerminal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EditCommand_DeleteTerminal>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EditCommand_DeleteTerminal& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EditCommand_DeleteTerminal& from) {
    EditCommand_DeleteTerminal::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EditCommand_DeleteTerminal* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "auth.EditCommand.DeleteTerminal";
  }
  protected:
  explicit EditCommand_DeleteTerminal(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // uint64 id = 1;
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:auth.EditCommand.DeleteTerminal)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lc_5fkasse_5fauth_2fauth_2eproto;
};
// -------------------------------------------------------------------

class EditCommand_GetTerminals final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:auth.EditCommand.GetTerminals) */ {
 public:
  inline EditCommand_GetTerminals() : EditCommand_GetTerminals(nullptr) {}
  ~EditCommand_GetTerminals() override;
  explicit PROTOBUF_CONSTEXPR EditCommand_GetTerminals(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EditCommand_GetTerminals(const EditCommand_GetTerminals& from);
  EditCommand_GetTerminals(EditCommand_GetTerminals&& from) noexcept
    : EditCommand_GetTerminals() {
    *this = ::std::move(from);
  }

  inline EditCommand_GetTerminals& operator=(const EditCommand_GetTerminals& from) {
    CopyFrom(from);
    return *this;
  }
  inline EditCommand_GetTerminals& operator=(EditCommand_GetTerminals&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EditCommand_GetTerminals& default_instance() {
    return *internal_default_instance();
  }
  static inline const EditCommand_GetTerminals* internal_default_instance() {
    return reinterpret_cast<const EditCommand_GetTerminals*>(
               &_EditCommand_GetTerminals_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(EditCommand_GetTerminals& a, EditCommand_GetTerminals& b) {
    a.Swap(&b);
  }
  inline void Swap(EditCommand_GetTerminals* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EditCommand_GetTerminals* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EditCommand_GetTerminals* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EditCommand_GetTerminals>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EditCommand_GetTerminals& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EditCommand_GetTerminals& from) {
    EditCommand_GetTerminals::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EditCommand_GetTerminals* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "auth.EditCommand.GetTerminals";
  }
  protected:
  explicit EditCommand_GetTerminals(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestFieldNumber = 1,
  };
  // .auth.PaginationRequest request = 1;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::auth::PaginationRequest& request() const;
  PROTOBUF_NODISCARD ::auth::PaginationRequest* release_request();
  ::auth::PaginationRequest* mutable_request();
  void set_allocated_request(::auth::PaginationRequest* request);
  private:
  const ::auth::PaginationRequest& _internal_request() const;
  ::auth::PaginationRequest* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::auth::PaginationRequest* request);
  ::auth::PaginationRequest* unsafe_arena_release_request();

  // @@protoc_insertion_point(class_scope:auth.EditCommand.GetTerminals)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::auth::PaginationRequest* request_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lc_5fkasse_5fauth_2fauth_2eproto;
};
// -------------------------------------------------------------------

class EditCommand_CreateTerminal final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:auth.EditCommand.CreateTerminal) */ {
 public:
  inline EditCommand_CreateTerminal() : EditCommand_CreateTerminal(nullptr) {}
  ~EditCommand_CreateTerminal() override;
  explicit PROTOBUF_CONSTEXPR EditCommand_CreateTerminal(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EditCommand_CreateTerminal(const EditCommand_CreateTerminal& from);
  EditCommand_CreateTerminal(EditCommand_CreateTerminal&& from) noexcept
    : EditCommand_CreateTerminal() {
    *this = ::std::move(from);
  }

  inline EditCommand_CreateTerminal& operator=(const EditCommand_CreateTerminal& from) {
    CopyFrom(from);
    return *this;
  }
  inline EditCommand_CreateTerminal& operator=(EditCommand_CreateTerminal&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EditCommand_CreateTerminal& default_instance() {
    return *internal_default_instance();
  }
  static inline const EditCommand_CreateTerminal* internal_default_instance() {
    return reinterpret_cast<const EditCommand_CreateTerminal*>(
               &_EditCommand_CreateTerminal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(EditCommand_CreateTerminal& a, EditCommand_CreateTerminal& b) {
    a.Swap(&b);
  }
  inline void Swap(EditCommand_CreateTerminal* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EditCommand_CreateTerminal* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EditCommand_CreateTerminal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EditCommand_CreateTerminal>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EditCommand_CreateTerminal& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EditCommand_CreateTerminal& from) {
    EditCommand_CreateTerminal::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EditCommand_CreateTerminal* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "auth.EditCommand.CreateTerminal";
  }
  protected:
  explicit EditCommand_CreateTerminal(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTerminalFieldNumber = 1,
  };
  // .auth.Terminal terminal = 1;
  bool has_terminal() const;
  private:
  bool _internal_has_terminal() const;
  public:
  void clear_terminal();
  const ::auth::Terminal& terminal() const;
  PROTOBUF_NODISCARD ::auth::Terminal* release_terminal();
  ::auth::Terminal* mutable_terminal();
  void set_allocated_terminal(::auth::Terminal* terminal);
  private:
  const ::auth::Terminal& _internal_terminal() const;
  ::auth::Terminal* _internal_mutable_terminal();
  public:
  void unsafe_arena_set_allocated_terminal(
      ::auth::Terminal* terminal);
  ::auth::Terminal* unsafe_arena_release_terminal();

  // @@protoc_insertion_point(class_scope:auth.EditCommand.CreateTerminal)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::auth::Terminal* terminal_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lc_5fkasse_5fauth_2fauth_2eproto;
};
// -------------------------------------------------------------------

class EditCommand_Save final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:auth.EditCommand.Save) */ {
 public:
  inline EditCommand_Save() : EditCommand_Save(nullptr) {}
  explicit PROTOBUF_CONSTEXPR EditCommand_Save(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EditCommand_Save(const EditCommand_Save& from);
  EditCommand_Save(EditCommand_Save&& from) noexcept
    : EditCommand_Save() {
    *this = ::std::move(from);
  }

  inline EditCommand_Save& operator=(const EditCommand_Save& from) {
    CopyFrom(from);
    return *this;
  }
  inline EditCommand_Save& operator=(EditCommand_Save&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EditCommand_Save& default_instance() {
    return *internal_default_instance();
  }
  static inline const EditCommand_Save* internal_default_instance() {
    return reinterpret_cast<const EditCommand_Save*>(
               &_EditCommand_Save_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(EditCommand_Save& a, EditCommand_Save& b) {
    a.Swap(&b);
  }
  inline void Swap(EditCommand_Save* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EditCommand_Save* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EditCommand_Save* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EditCommand_Save>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const EditCommand_Save& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const EditCommand_Save& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "auth.EditCommand.Save";
  }
  protected:
  explicit EditCommand_Save(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:auth.EditCommand.Save)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_lc_5fkasse_5fauth_2fauth_2eproto;
};
// -------------------------------------------------------------------

class EditCommand_Cancel final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:auth.EditCommand.Cancel) */ {
 public:
  inline EditCommand_Cancel() : EditCommand_Cancel(nullptr) {}
  explicit PROTOBUF_CONSTEXPR EditCommand_Cancel(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EditCommand_Cancel(const EditCommand_Cancel& from);
  EditCommand_Cancel(EditCommand_Cancel&& from) noexcept
    : EditCommand_Cancel() {
    *this = ::std::move(from);
  }

  inline EditCommand_Cancel& operator=(const EditCommand_Cancel& from) {
    CopyFrom(from);
    return *this;
  }
  inline EditCommand_Cancel& operator=(EditCommand_Cancel&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EditCommand_Cancel& default_instance() {
    return *internal_default_instance();
  }
  static inline const EditCommand_Cancel* internal_default_instance() {
    return reinterpret_cast<const EditCommand_Cancel*>(
               &_EditCommand_Cancel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(EditCommand_Cancel& a, EditCommand_Cancel& b) {
    a.Swap(&b);
  }
  inline void Swap(EditCommand_Cancel* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EditCommand_Cancel* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EditCommand_Cancel* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EditCommand_Cancel>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const EditCommand_Cancel& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const EditCommand_Cancel& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "auth.EditCommand.Cancel";
  }
  protected:
  explicit EditCommand_Cancel(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:auth.EditCommand.Cancel)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_lc_5fkasse_5fauth_2fauth_2eproto;
};
// -------------------------------------------------------------------

class EditCommand final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:auth.EditCommand) */ {
 public:
  inline EditCommand() : EditCommand(nullptr) {}
  ~EditCommand() override;
  explicit PROTOBUF_CONSTEXPR EditCommand(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EditCommand(const EditCommand& from);
  EditCommand(EditCommand&& from) noexcept
    : EditCommand() {
    *this = ::std::move(from);
  }

  inline EditCommand& operator=(const EditCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline EditCommand& operator=(EditCommand&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EditCommand& default_instance() {
    return *internal_default_instance();
  }
  enum CmdCase {
    kGetuser = 1,
    kGetusergroup = 2,
    kUpdateuser = 3,
    kUpdateusergroup = 4,
    kDeleteuser = 5,
    kDeleteusergroup = 6,
    kCreateuser = 7,
    kCreateusergroup = 8,
    kGetUserGroups = 9,
    kGetUsersByGroup = 10,
    kGetTerminal = 11,
    kUpdateTerminal = 12,
    kDeleteTerminal = 13,
    kGetTerminals = 14,
    kCreateTerminal = 15,
    kSave = 16,
    kCancel = 17,
    CMD_NOT_SET = 0,
  };

  static inline const EditCommand* internal_default_instance() {
    return reinterpret_cast<const EditCommand*>(
               &_EditCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(EditCommand& a, EditCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(EditCommand* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EditCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EditCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EditCommand>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EditCommand& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EditCommand& from) {
    EditCommand::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EditCommand* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "auth.EditCommand";
  }
  protected:
  explicit EditCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef EditCommand_GetUser GetUser;
  typedef EditCommand_GetUserGroup GetUserGroup;
  typedef EditCommand_UpdateUser UpdateUser;
  typedef EditCommand_UpdateUserGroup UpdateUserGroup;
  typedef EditCommand_DeleteUser DeleteUser;
  typedef EditCommand_DeleteUserGroup DeleteUserGroup;
  typedef EditCommand_CreateUser CreateUser;
  typedef EditCommand_CreateUserGroup CreateUserGroup;
  typedef EditCommand_GetTerminal GetTerminal;
  typedef EditCommand_UpdateTerminal UpdateTerminal;
  typedef EditCommand_DeleteTerminal DeleteTerminal;
  typedef EditCommand_GetTerminals GetTerminals;
  typedef EditCommand_CreateTerminal CreateTerminal;
  typedef EditCommand_Save Save;
  typedef EditCommand_Cancel Cancel;

  // accessors -------------------------------------------------------

  enum : int {
    kGetuserFieldNumber = 1,
    kGetusergroupFieldNumber = 2,
    kUpdateuserFieldNumber = 3,
    kUpdateusergroupFieldNumber = 4,
    kDeleteuserFieldNumber = 5,
    kDeleteusergroupFieldNumber = 6,
    kCreateuserFieldNumber = 7,
    kCreateusergroupFieldNumber = 8,
    kGetUserGroupsFieldNumber = 9,
    kGetUsersByGroupFieldNumber = 10,
    kGetTerminalFieldNumber = 11,
    kUpdateTerminalFieldNumber = 12,
    kDeleteTerminalFieldNumber = 13,
    kGetTerminalsFieldNumber = 14,
    kCreateTerminalFieldNumber = 15,
    kSaveFieldNumber = 16,
    kCancelFieldNumber = 17,
  };
  // .auth.EditCommand.GetUser getuser = 1;
  bool has_getuser() const;
  private:
  bool _internal_has_getuser() const;
  public:
  void clear_getuser();
  const ::auth::EditCommand_GetUser& getuser() const;
  PROTOBUF_NODISCARD ::auth::EditCommand_GetUser* release_getuser();
  ::auth::EditCommand_GetUser* mutable_getuser();
  void set_allocated_getuser(::auth::EditCommand_GetUser* getuser);
  private:
  const ::auth::EditCommand_GetUser& _internal_getuser() const;
  ::auth::EditCommand_GetUser* _internal_mutable_getuser();
  public:
  void unsafe_arena_set_allocated_getuser(
      ::auth::EditCommand_GetUser* getuser);
  ::auth::EditCommand_GetUser* unsafe_arena_release_getuser();

  // .auth.EditCommand.GetUserGroup getusergroup = 2;
  bool has_getusergroup() const;
  private:
  bool _internal_has_getusergroup() const;
  public:
  void clear_getusergroup();
  const ::auth::EditCommand_GetUserGroup& getusergroup() const;
  PROTOBUF_NODISCARD ::auth::EditCommand_GetUserGroup* release_getusergroup();
  ::auth::EditCommand_GetUserGroup* mutable_getusergroup();
  void set_allocated_getusergroup(::auth::EditCommand_GetUserGroup* getusergroup);
  private:
  const ::auth::EditCommand_GetUserGroup& _internal_getusergroup() const;
  ::auth::EditCommand_GetUserGroup* _internal_mutable_getusergroup();
  public:
  void unsafe_arena_set_allocated_getusergroup(
      ::auth::EditCommand_GetUserGroup* getusergroup);
  ::auth::EditCommand_GetUserGroup* unsafe_arena_release_getusergroup();

  // .auth.EditCommand.UpdateUser updateuser = 3;
  bool has_updateuser() const;
  private:
  bool _internal_has_updateuser() const;
  public:
  void clear_updateuser();
  const ::auth::EditCommand_UpdateUser& updateuser() const;
  PROTOBUF_NODISCARD ::auth::EditCommand_UpdateUser* release_updateuser();
  ::auth::EditCommand_UpdateUser* mutable_updateuser();
  void set_allocated_updateuser(::auth::EditCommand_UpdateUser* updateuser);
  private:
  const ::auth::EditCommand_UpdateUser& _internal_updateuser() const;
  ::auth::EditCommand_UpdateUser* _internal_mutable_updateuser();
  public:
  void unsafe_arena_set_allocated_updateuser(
      ::auth::EditCommand_UpdateUser* updateuser);
  ::auth::EditCommand_UpdateUser* unsafe_arena_release_updateuser();

  // .auth.EditCommand.UpdateUserGroup updateusergroup = 4;
  bool has_updateusergroup() const;
  private:
  bool _internal_has_updateusergroup() const;
  public:
  void clear_updateusergroup();
  const ::auth::EditCommand_UpdateUserGroup& updateusergroup() const;
  PROTOBUF_NODISCARD ::auth::EditCommand_UpdateUserGroup* release_updateusergroup();
  ::auth::EditCommand_UpdateUserGroup* mutable_updateusergroup();
  void set_allocated_updateusergroup(::auth::EditCommand_UpdateUserGroup* updateusergroup);
  private:
  const ::auth::EditCommand_UpdateUserGroup& _internal_updateusergroup() const;
  ::auth::EditCommand_UpdateUserGroup* _internal_mutable_updateusergroup();
  public:
  void unsafe_arena_set_allocated_updateusergroup(
      ::auth::EditCommand_UpdateUserGroup* updateusergroup);
  ::auth::EditCommand_UpdateUserGroup* unsafe_arena_release_updateusergroup();

  // .auth.EditCommand.DeleteUser deleteuser = 5;
  bool has_deleteuser() const;
  private:
  bool _internal_has_deleteuser() const;
  public:
  void clear_deleteuser();
  const ::auth::EditCommand_DeleteUser& deleteuser() const;
  PROTOBUF_NODISCARD ::auth::EditCommand_DeleteUser* release_deleteuser();
  ::auth::EditCommand_DeleteUser* mutable_deleteuser();
  void set_allocated_deleteuser(::auth::EditCommand_DeleteUser* deleteuser);
  private:
  const ::auth::EditCommand_DeleteUser& _internal_deleteuser() const;
  ::auth::EditCommand_DeleteUser* _internal_mutable_deleteuser();
  public:
  void unsafe_arena_set_allocated_deleteuser(
      ::auth::EditCommand_DeleteUser* deleteuser);
  ::auth::EditCommand_DeleteUser* unsafe_arena_release_deleteuser();

  // .auth.EditCommand.DeleteUserGroup deleteusergroup = 6;
  bool has_deleteusergroup() const;
  private:
  bool _internal_has_deleteusergroup() const;
  public:
  void clear_deleteusergroup();
  const ::auth::EditCommand_DeleteUserGroup& deleteusergroup() const;
  PROTOBUF_NODISCARD ::auth::EditCommand_DeleteUserGroup* release_deleteusergroup();
  ::auth::EditCommand_DeleteUserGroup* mutable_deleteusergroup();
  void set_allocated_deleteusergroup(::auth::EditCommand_DeleteUserGroup* deleteusergroup);
  private:
  const ::auth::EditCommand_DeleteUserGroup& _internal_deleteusergroup() const;
  ::auth::EditCommand_DeleteUserGroup* _internal_mutable_deleteusergroup();
  public:
  void unsafe_arena_set_allocated_deleteusergroup(
      ::auth::EditCommand_DeleteUserGroup* deleteusergroup);
  ::auth::EditCommand_DeleteUserGroup* unsafe_arena_release_deleteusergroup();

  // .auth.EditCommand.CreateUser createuser = 7;
  bool has_createuser() const;
  private:
  bool _internal_has_createuser() const;
  public:
  void clear_createuser();
  const ::auth::EditCommand_CreateUser& createuser() const;
  PROTOBUF_NODISCARD ::auth::EditCommand_CreateUser* release_createuser();
  ::auth::EditCommand_CreateUser* mutable_createuser();
  void set_allocated_createuser(::auth::EditCommand_CreateUser* createuser);
  private:
  const ::auth::EditCommand_CreateUser& _internal_createuser() const;
  ::auth::EditCommand_CreateUser* _internal_mutable_createuser();
  public:
  void unsafe_arena_set_allocated_createuser(
      ::auth::EditCommand_CreateUser* createuser);
  ::auth::EditCommand_CreateUser* unsafe_arena_release_createuser();

  // .auth.EditCommand.CreateUserGroup createusergroup = 8;
  bool has_createusergroup() const;
  private:
  bool _internal_has_createusergroup() const;
  public:
  void clear_createusergroup();
  const ::auth::EditCommand_CreateUserGroup& createusergroup() const;
  PROTOBUF_NODISCARD ::auth::EditCommand_CreateUserGroup* release_createusergroup();
  ::auth::EditCommand_CreateUserGroup* mutable_createusergroup();
  void set_allocated_createusergroup(::auth::EditCommand_CreateUserGroup* createusergroup);
  private:
  const ::auth::EditCommand_CreateUserGroup& _internal_createusergroup() const;
  ::auth::EditCommand_CreateUserGroup* _internal_mutable_createusergroup();
  public:
  void unsafe_arena_set_allocated_createusergroup(
      ::auth::EditCommand_CreateUserGroup* createusergroup);
  ::auth::EditCommand_CreateUserGroup* unsafe_arena_release_createusergroup();

  // .auth.GetUserGroupsReq getUserGroups = 9;
  bool has_getusergroups() const;
  private:
  bool _internal_has_getusergroups() const;
  public:
  void clear_getusergroups();
  const ::auth::GetUserGroupsReq& getusergroups() const;
  PROTOBUF_NODISCARD ::auth::GetUserGroupsReq* release_getusergroups();
  ::auth::GetUserGroupsReq* mutable_getusergroups();
  void set_allocated_getusergroups(::auth::GetUserGroupsReq* getusergroups);
  private:
  const ::auth::GetUserGroupsReq& _internal_getusergroups() const;
  ::auth::GetUserGroupsReq* _internal_mutable_getusergroups();
  public:
  void unsafe_arena_set_allocated_getusergroups(
      ::auth::GetUserGroupsReq* getusergroups);
  ::auth::GetUserGroupsReq* unsafe_arena_release_getusergroups();

  // .auth.GetUsersByGroupReq getUsersByGroup = 10;
  bool has_getusersbygroup() const;
  private:
  bool _internal_has_getusersbygroup() const;
  public:
  void clear_getusersbygroup();
  const ::auth::GetUsersByGroupReq& getusersbygroup() const;
  PROTOBUF_NODISCARD ::auth::GetUsersByGroupReq* release_getusersbygroup();
  ::auth::GetUsersByGroupReq* mutable_getusersbygroup();
  void set_allocated_getusersbygroup(::auth::GetUsersByGroupReq* getusersbygroup);
  private:
  const ::auth::GetUsersByGroupReq& _internal_getusersbygroup() const;
  ::auth::GetUsersByGroupReq* _internal_mutable_getusersbygroup();
  public:
  void unsafe_arena_set_allocated_getusersbygroup(
      ::auth::GetUsersByGroupReq* getusersbygroup);
  ::auth::GetUsersByGroupReq* unsafe_arena_release_getusersbygroup();

  // .auth.EditCommand.GetTerminal getTerminal = 11;
  bool has_getterminal() const;
  private:
  bool _internal_has_getterminal() const;
  public:
  void clear_getterminal();
  const ::auth::EditCommand_GetTerminal& getterminal() const;
  PROTOBUF_NODISCARD ::auth::EditCommand_GetTerminal* release_getterminal();
  ::auth::EditCommand_GetTerminal* mutable_getterminal();
  void set_allocated_getterminal(::auth::EditCommand_GetTerminal* getterminal);
  private:
  const ::auth::EditCommand_GetTerminal& _internal_getterminal() const;
  ::auth::EditCommand_GetTerminal* _internal_mutable_getterminal();
  public:
  void unsafe_arena_set_allocated_getterminal(
      ::auth::EditCommand_GetTerminal* getterminal);
  ::auth::EditCommand_GetTerminal* unsafe_arena_release_getterminal();

  // .auth.EditCommand.UpdateTerminal updateTerminal = 12;
  bool has_updateterminal() const;
  private:
  bool _internal_has_updateterminal() const;
  public:
  void clear_updateterminal();
  const ::auth::EditCommand_UpdateTerminal& updateterminal() const;
  PROTOBUF_NODISCARD ::auth::EditCommand_UpdateTerminal* release_updateterminal();
  ::auth::EditCommand_UpdateTerminal* mutable_updateterminal();
  void set_allocated_updateterminal(::auth::EditCommand_UpdateTerminal* updateterminal);
  private:
  const ::auth::EditCommand_UpdateTerminal& _internal_updateterminal() const;
  ::auth::EditCommand_UpdateTerminal* _internal_mutable_updateterminal();
  public:
  void unsafe_arena_set_allocated_updateterminal(
      ::auth::EditCommand_UpdateTerminal* updateterminal);
  ::auth::EditCommand_UpdateTerminal* unsafe_arena_release_updateterminal();

  // .auth.EditCommand.DeleteTerminal deleteTerminal = 13;
  bool has_deleteterminal() const;
  private:
  bool _internal_has_deleteterminal() const;
  public:
  void clear_deleteterminal();
  const ::auth::EditCommand_DeleteTerminal& deleteterminal() const;
  PROTOBUF_NODISCARD ::auth::EditCommand_DeleteTerminal* release_deleteterminal();
  ::auth::EditCommand_DeleteTerminal* mutable_deleteterminal();
  void set_allocated_deleteterminal(::auth::EditCommand_DeleteTerminal* deleteterminal);
  private:
  const ::auth::EditCommand_DeleteTerminal& _internal_deleteterminal() const;
  ::auth::EditCommand_DeleteTerminal* _internal_mutable_deleteterminal();
  public:
  void unsafe_arena_set_allocated_deleteterminal(
      ::auth::EditCommand_DeleteTerminal* deleteterminal);
  ::auth::EditCommand_DeleteTerminal* unsafe_arena_release_deleteterminal();

  // .auth.EditCommand.GetTerminals getTerminals = 14;
  bool has_getterminals() const;
  private:
  bool _internal_has_getterminals() const;
  public:
  void clear_getterminals();
  const ::auth::EditCommand_GetTerminals& getterminals() const;
  PROTOBUF_NODISCARD ::auth::EditCommand_GetTerminals* release_getterminals();
  ::auth::EditCommand_GetTerminals* mutable_getterminals();
  void set_allocated_getterminals(::auth::EditCommand_GetTerminals* getterminals);
  private:
  const ::auth::EditCommand_GetTerminals& _internal_getterminals() const;
  ::auth::EditCommand_GetTerminals* _internal_mutable_getterminals();
  public:
  void unsafe_arena_set_allocated_getterminals(
      ::auth::EditCommand_GetTerminals* getterminals);
  ::auth::EditCommand_GetTerminals* unsafe_arena_release_getterminals();

  // .auth.EditCommand.CreateTerminal createTerminal = 15;
  bool has_createterminal() const;
  private:
  bool _internal_has_createterminal() const;
  public:
  void clear_createterminal();
  const ::auth::EditCommand_CreateTerminal& createterminal() const;
  PROTOBUF_NODISCARD ::auth::EditCommand_CreateTerminal* release_createterminal();
  ::auth::EditCommand_CreateTerminal* mutable_createterminal();
  void set_allocated_createterminal(::auth::EditCommand_CreateTerminal* createterminal);
  private:
  const ::auth::EditCommand_CreateTerminal& _internal_createterminal() const;
  ::auth::EditCommand_CreateTerminal* _internal_mutable_createterminal();
  public:
  void unsafe_arena_set_allocated_createterminal(
      ::auth::EditCommand_CreateTerminal* createterminal);
  ::auth::EditCommand_CreateTerminal* unsafe_arena_release_createterminal();

  // .auth.EditCommand.Save save = 16;
  bool has_save() const;
  private:
  bool _internal_has_save() const;
  public:
  void clear_save();
  const ::auth::EditCommand_Save& save() const;
  PROTOBUF_NODISCARD ::auth::EditCommand_Save* release_save();
  ::auth::EditCommand_Save* mutable_save();
  void set_allocated_save(::auth::EditCommand_Save* save);
  private:
  const ::auth::EditCommand_Save& _internal_save() const;
  ::auth::EditCommand_Save* _internal_mutable_save();
  public:
  void unsafe_arena_set_allocated_save(
      ::auth::EditCommand_Save* save);
  ::auth::EditCommand_Save* unsafe_arena_release_save();

  // .auth.EditCommand.Cancel cancel = 17;
  bool has_cancel() const;
  private:
  bool _internal_has_cancel() const;
  public:
  void clear_cancel();
  const ::auth::EditCommand_Cancel& cancel() const;
  PROTOBUF_NODISCARD ::auth::EditCommand_Cancel* release_cancel();
  ::auth::EditCommand_Cancel* mutable_cancel();
  void set_allocated_cancel(::auth::EditCommand_Cancel* cancel);
  private:
  const ::auth::EditCommand_Cancel& _internal_cancel() const;
  ::auth::EditCommand_Cancel* _internal_mutable_cancel();
  public:
  void unsafe_arena_set_allocated_cancel(
      ::auth::EditCommand_Cancel* cancel);
  ::auth::EditCommand_Cancel* unsafe_arena_release_cancel();

  void clear_cmd();
  CmdCase cmd_case() const;
  // @@protoc_insertion_point(class_scope:auth.EditCommand)
 private:
  class _Internal;
  void set_has_getuser();
  void set_has_getusergroup();
  void set_has_updateuser();
  void set_has_updateusergroup();
  void set_has_deleteuser();
  void set_has_deleteusergroup();
  void set_has_createuser();
  void set_has_createusergroup();
  void set_has_getusergroups();
  void set_has_getusersbygroup();
  void set_has_getterminal();
  void set_has_updateterminal();
  void set_has_deleteterminal();
  void set_has_getterminals();
  void set_has_createterminal();
  void set_has_save();
  void set_has_cancel();

  inline bool has_cmd() const;
  inline void clear_has_cmd();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union CmdUnion {
      constexpr CmdUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::auth::EditCommand_GetUser* getuser_;
      ::auth::EditCommand_GetUserGroup* getusergroup_;
      ::auth::EditCommand_UpdateUser* updateuser_;
      ::auth::EditCommand_UpdateUserGroup* updateusergroup_;
      ::auth::EditCommand_DeleteUser* deleteuser_;
      ::auth::EditCommand_DeleteUserGroup* deleteusergroup_;
      ::auth::EditCommand_CreateUser* createuser_;
      ::auth::EditCommand_CreateUserGroup* createusergroup_;
      ::auth::GetUserGroupsReq* getusergroups_;
      ::auth::GetUsersByGroupReq* getusersbygroup_;
      ::auth::EditCommand_GetTerminal* getterminal_;
      ::auth::EditCommand_UpdateTerminal* updateterminal_;
      ::auth::EditCommand_DeleteTerminal* deleteterminal_;
      ::auth::EditCommand_GetTerminals* getterminals_;
      ::auth::EditCommand_CreateTerminal* createterminal_;
      ::auth::EditCommand_Save* save_;
      ::auth::EditCommand_Cancel* cancel_;
    } cmd_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lc_5fkasse_5fauth_2fauth_2eproto;
};
// -------------------------------------------------------------------

class EditResponse_TerminalsResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:auth.EditResponse.TerminalsResp) */ {
 public:
  inline EditResponse_TerminalsResp() : EditResponse_TerminalsResp(nullptr) {}
  ~EditResponse_TerminalsResp() override;
  explicit PROTOBUF_CONSTEXPR EditResponse_TerminalsResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EditResponse_TerminalsResp(const EditResponse_TerminalsResp& from);
  EditResponse_TerminalsResp(EditResponse_TerminalsResp&& from) noexcept
    : EditResponse_TerminalsResp() {
    *this = ::std::move(from);
  }

  inline EditResponse_TerminalsResp& operator=(const EditResponse_TerminalsResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline EditResponse_TerminalsResp& operator=(EditResponse_TerminalsResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EditResponse_TerminalsResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const EditResponse_TerminalsResp* internal_default_instance() {
    return reinterpret_cast<const EditResponse_TerminalsResp*>(
               &_EditResponse_TerminalsResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(EditResponse_TerminalsResp& a, EditResponse_TerminalsResp& b) {
    a.Swap(&b);
  }
  inline void Swap(EditResponse_TerminalsResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EditResponse_TerminalsResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EditResponse_TerminalsResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EditResponse_TerminalsResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EditResponse_TerminalsResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EditResponse_TerminalsResp& from) {
    EditResponse_TerminalsResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EditResponse_TerminalsResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "auth.EditResponse.TerminalsResp";
  }
  protected:
  explicit EditResponse_TerminalsResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTerminalsFieldNumber = 1,
    kPaginationrespFieldNumber = 2,
  };
  // repeated .auth.Terminal terminals = 1;
  int terminals_size() const;
  private:
  int _internal_terminals_size() const;
  public:
  void clear_terminals();
  ::auth::Terminal* mutable_terminals(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::auth::Terminal >*
      mutable_terminals();
  private:
  const ::auth::Terminal& _internal_terminals(int index) const;
  ::auth::Terminal* _internal_add_terminals();
  public:
  const ::auth::Terminal& terminals(int index) const;
  ::auth::Terminal* add_terminals();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::auth::Terminal >&
      terminals() const;

  // .auth.PaginationResponse paginationresp = 2;
  bool has_paginationresp() const;
  private:
  bool _internal_has_paginationresp() const;
  public:
  void clear_paginationresp();
  const ::auth::PaginationResponse& paginationresp() const;
  PROTOBUF_NODISCARD ::auth::PaginationResponse* release_paginationresp();
  ::auth::PaginationResponse* mutable_paginationresp();
  void set_allocated_paginationresp(::auth::PaginationResponse* paginationresp);
  private:
  const ::auth::PaginationResponse& _internal_paginationresp() const;
  ::auth::PaginationResponse* _internal_mutable_paginationresp();
  public:
  void unsafe_arena_set_allocated_paginationresp(
      ::auth::PaginationResponse* paginationresp);
  ::auth::PaginationResponse* unsafe_arena_release_paginationresp();

  // @@protoc_insertion_point(class_scope:auth.EditResponse.TerminalsResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::auth::Terminal > terminals_;
    ::auth::PaginationResponse* paginationresp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lc_5fkasse_5fauth_2fauth_2eproto;
};
// -------------------------------------------------------------------

class EditResponse_Error final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:auth.EditResponse.Error) */ {
 public:
  inline EditResponse_Error() : EditResponse_Error(nullptr) {}
  ~EditResponse_Error() override;
  explicit PROTOBUF_CONSTEXPR EditResponse_Error(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EditResponse_Error(const EditResponse_Error& from);
  EditResponse_Error(EditResponse_Error&& from) noexcept
    : EditResponse_Error() {
    *this = ::std::move(from);
  }

  inline EditResponse_Error& operator=(const EditResponse_Error& from) {
    CopyFrom(from);
    return *this;
  }
  inline EditResponse_Error& operator=(EditResponse_Error&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EditResponse_Error& default_instance() {
    return *internal_default_instance();
  }
  static inline const EditResponse_Error* internal_default_instance() {
    return reinterpret_cast<const EditResponse_Error*>(
               &_EditResponse_Error_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(EditResponse_Error& a, EditResponse_Error& b) {
    a.Swap(&b);
  }
  inline void Swap(EditResponse_Error* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EditResponse_Error* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EditResponse_Error* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EditResponse_Error>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EditResponse_Error& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EditResponse_Error& from) {
    EditResponse_Error::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EditResponse_Error* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "auth.EditResponse.Error";
  }
  protected:
  explicit EditResponse_Error(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kCodeFieldNumber = 1,
  };
  // string message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // uint64 code = 1;
  void clear_code();
  uint64_t code() const;
  void set_code(uint64_t value);
  private:
  uint64_t _internal_code() const;
  void _internal_set_code(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:auth.EditResponse.Error)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    uint64_t code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lc_5fkasse_5fauth_2fauth_2eproto;
};
// -------------------------------------------------------------------

class EditResponse_GetUser final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:auth.EditResponse.GetUser) */ {
 public:
  inline EditResponse_GetUser() : EditResponse_GetUser(nullptr) {}
  ~EditResponse_GetUser() override;
  explicit PROTOBUF_CONSTEXPR EditResponse_GetUser(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EditResponse_GetUser(const EditResponse_GetUser& from);
  EditResponse_GetUser(EditResponse_GetUser&& from) noexcept
    : EditResponse_GetUser() {
    *this = ::std::move(from);
  }

  inline EditResponse_GetUser& operator=(const EditResponse_GetUser& from) {
    CopyFrom(from);
    return *this;
  }
  inline EditResponse_GetUser& operator=(EditResponse_GetUser&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EditResponse_GetUser& default_instance() {
    return *internal_default_instance();
  }
  static inline const EditResponse_GetUser* internal_default_instance() {
    return reinterpret_cast<const EditResponse_GetUser*>(
               &_EditResponse_GetUser_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(EditResponse_GetUser& a, EditResponse_GetUser& b) {
    a.Swap(&b);
  }
  inline void Swap(EditResponse_GetUser* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EditResponse_GetUser* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EditResponse_GetUser* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EditResponse_GetUser>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EditResponse_GetUser& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EditResponse_GetUser& from) {
    EditResponse_GetUser::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EditResponse_GetUser* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "auth.EditResponse.GetUser";
  }
  protected:
  explicit EditResponse_GetUser(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserFieldNumber = 1,
    kErrorFieldNumber = 2,
  };
  // optional .auth.User user = 1;
  bool has_user() const;
  private:
  bool _internal_has_user() const;
  public:
  void clear_user();
  const ::auth::User& user() const;
  PROTOBUF_NODISCARD ::auth::User* release_user();
  ::auth::User* mutable_user();
  void set_allocated_user(::auth::User* user);
  private:
  const ::auth::User& _internal_user() const;
  ::auth::User* _internal_mutable_user();
  public:
  void unsafe_arena_set_allocated_user(
      ::auth::User* user);
  ::auth::User* unsafe_arena_release_user();

  // optional .auth.EditResponse.Error error = 2;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::auth::EditResponse_Error& error() const;
  PROTOBUF_NODISCARD ::auth::EditResponse_Error* release_error();
  ::auth::EditResponse_Error* mutable_error();
  void set_allocated_error(::auth::EditResponse_Error* error);
  private:
  const ::auth::EditResponse_Error& _internal_error() const;
  ::auth::EditResponse_Error* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::auth::EditResponse_Error* error);
  ::auth::EditResponse_Error* unsafe_arena_release_error();

  // @@protoc_insertion_point(class_scope:auth.EditResponse.GetUser)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::auth::User* user_;
    ::auth::EditResponse_Error* error_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lc_5fkasse_5fauth_2fauth_2eproto;
};
// -------------------------------------------------------------------

class EditResponse_GetUserGroup final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:auth.EditResponse.GetUserGroup) */ {
 public:
  inline EditResponse_GetUserGroup() : EditResponse_GetUserGroup(nullptr) {}
  ~EditResponse_GetUserGroup() override;
  explicit PROTOBUF_CONSTEXPR EditResponse_GetUserGroup(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EditResponse_GetUserGroup(const EditResponse_GetUserGroup& from);
  EditResponse_GetUserGroup(EditResponse_GetUserGroup&& from) noexcept
    : EditResponse_GetUserGroup() {
    *this = ::std::move(from);
  }

  inline EditResponse_GetUserGroup& operator=(const EditResponse_GetUserGroup& from) {
    CopyFrom(from);
    return *this;
  }
  inline EditResponse_GetUserGroup& operator=(EditResponse_GetUserGroup&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EditResponse_GetUserGroup& default_instance() {
    return *internal_default_instance();
  }
  static inline const EditResponse_GetUserGroup* internal_default_instance() {
    return reinterpret_cast<const EditResponse_GetUserGroup*>(
               &_EditResponse_GetUserGroup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(EditResponse_GetUserGroup& a, EditResponse_GetUserGroup& b) {
    a.Swap(&b);
  }
  inline void Swap(EditResponse_GetUserGroup* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EditResponse_GetUserGroup* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EditResponse_GetUserGroup* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EditResponse_GetUserGroup>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EditResponse_GetUserGroup& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EditResponse_GetUserGroup& from) {
    EditResponse_GetUserGroup::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EditResponse_GetUserGroup* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "auth.EditResponse.GetUserGroup";
  }
  protected:
  explicit EditResponse_GetUserGroup(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGroupFieldNumber = 1,
    kErrorFieldNumber = 2,
  };
  // optional .auth.UserGroup group = 1;
  bool has_group() const;
  private:
  bool _internal_has_group() const;
  public:
  void clear_group();
  const ::auth::UserGroup& group() const;
  PROTOBUF_NODISCARD ::auth::UserGroup* release_group();
  ::auth::UserGroup* mutable_group();
  void set_allocated_group(::auth::UserGroup* group);
  private:
  const ::auth::UserGroup& _internal_group() const;
  ::auth::UserGroup* _internal_mutable_group();
  public:
  void unsafe_arena_set_allocated_group(
      ::auth::UserGroup* group);
  ::auth::UserGroup* unsafe_arena_release_group();

  // optional .auth.EditResponse.Error error = 2;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::auth::EditResponse_Error& error() const;
  PROTOBUF_NODISCARD ::auth::EditResponse_Error* release_error();
  ::auth::EditResponse_Error* mutable_error();
  void set_allocated_error(::auth::EditResponse_Error* error);
  private:
  const ::auth::EditResponse_Error& _internal_error() const;
  ::auth::EditResponse_Error* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::auth::EditResponse_Error* error);
  ::auth::EditResponse_Error* unsafe_arena_release_error();

  // @@protoc_insertion_point(class_scope:auth.EditResponse.GetUserGroup)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::auth::UserGroup* group_;
    ::auth::EditResponse_Error* error_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lc_5fkasse_5fauth_2fauth_2eproto;
};
// -------------------------------------------------------------------

class EditResponse_UpdateUser final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:auth.EditResponse.UpdateUser) */ {
 public:
  inline EditResponse_UpdateUser() : EditResponse_UpdateUser(nullptr) {}
  ~EditResponse_UpdateUser() override;
  explicit PROTOBUF_CONSTEXPR EditResponse_UpdateUser(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EditResponse_UpdateUser(const EditResponse_UpdateUser& from);
  EditResponse_UpdateUser(EditResponse_UpdateUser&& from) noexcept
    : EditResponse_UpdateUser() {
    *this = ::std::move(from);
  }

  inline EditResponse_UpdateUser& operator=(const EditResponse_UpdateUser& from) {
    CopyFrom(from);
    return *this;
  }
  inline EditResponse_UpdateUser& operator=(EditResponse_UpdateUser&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EditResponse_UpdateUser& default_instance() {
    return *internal_default_instance();
  }
  static inline const EditResponse_UpdateUser* internal_default_instance() {
    return reinterpret_cast<const EditResponse_UpdateUser*>(
               &_EditResponse_UpdateUser_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(EditResponse_UpdateUser& a, EditResponse_UpdateUser& b) {
    a.Swap(&b);
  }
  inline void Swap(EditResponse_UpdateUser* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EditResponse_UpdateUser* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EditResponse_UpdateUser* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EditResponse_UpdateUser>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EditResponse_UpdateUser& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EditResponse_UpdateUser& from) {
    EditResponse_UpdateUser::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EditResponse_UpdateUser* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "auth.EditResponse.UpdateUser";
  }
  protected:
  explicit EditResponse_UpdateUser(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserFieldNumber = 1,
    kErrorFieldNumber = 2,
  };
  // optional .auth.User user = 1;
  bool has_user() const;
  private:
  bool _internal_has_user() const;
  public:
  void clear_user();
  const ::auth::User& user() const;
  PROTOBUF_NODISCARD ::auth::User* release_user();
  ::auth::User* mutable_user();
  void set_allocated_user(::auth::User* user);
  private:
  const ::auth::User& _internal_user() const;
  ::auth::User* _internal_mutable_user();
  public:
  void unsafe_arena_set_allocated_user(
      ::auth::User* user);
  ::auth::User* unsafe_arena_release_user();

  // optional .auth.EditResponse.Error error = 2;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::auth::EditResponse_Error& error() const;
  PROTOBUF_NODISCARD ::auth::EditResponse_Error* release_error();
  ::auth::EditResponse_Error* mutable_error();
  void set_allocated_error(::auth::EditResponse_Error* error);
  private:
  const ::auth::EditResponse_Error& _internal_error() const;
  ::auth::EditResponse_Error* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::auth::EditResponse_Error* error);
  ::auth::EditResponse_Error* unsafe_arena_release_error();

  // @@protoc_insertion_point(class_scope:auth.EditResponse.UpdateUser)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::auth::User* user_;
    ::auth::EditResponse_Error* error_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lc_5fkasse_5fauth_2fauth_2eproto;
};
// -------------------------------------------------------------------

class EditResponse_UpdateUserGroup final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:auth.EditResponse.UpdateUserGroup) */ {
 public:
  inline EditResponse_UpdateUserGroup() : EditResponse_UpdateUserGroup(nullptr) {}
  ~EditResponse_UpdateUserGroup() override;
  explicit PROTOBUF_CONSTEXPR EditResponse_UpdateUserGroup(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EditResponse_UpdateUserGroup(const EditResponse_UpdateUserGroup& from);
  EditResponse_UpdateUserGroup(EditResponse_UpdateUserGroup&& from) noexcept
    : EditResponse_UpdateUserGroup() {
    *this = ::std::move(from);
  }

  inline EditResponse_UpdateUserGroup& operator=(const EditResponse_UpdateUserGroup& from) {
    CopyFrom(from);
    return *this;
  }
  inline EditResponse_UpdateUserGroup& operator=(EditResponse_UpdateUserGroup&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EditResponse_UpdateUserGroup& default_instance() {
    return *internal_default_instance();
  }
  static inline const EditResponse_UpdateUserGroup* internal_default_instance() {
    return reinterpret_cast<const EditResponse_UpdateUserGroup*>(
               &_EditResponse_UpdateUserGroup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(EditResponse_UpdateUserGroup& a, EditResponse_UpdateUserGroup& b) {
    a.Swap(&b);
  }
  inline void Swap(EditResponse_UpdateUserGroup* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EditResponse_UpdateUserGroup* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EditResponse_UpdateUserGroup* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EditResponse_UpdateUserGroup>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EditResponse_UpdateUserGroup& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EditResponse_UpdateUserGroup& from) {
    EditResponse_UpdateUserGroup::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EditResponse_UpdateUserGroup* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "auth.EditResponse.UpdateUserGroup";
  }
  protected:
  explicit EditResponse_UpdateUserGroup(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGroupFieldNumber = 1,
    kErrorFieldNumber = 2,
  };
  // optional .auth.UserGroup group = 1;
  bool has_group() const;
  private:
  bool _internal_has_group() const;
  public:
  void clear_group();
  const ::auth::UserGroup& group() const;
  PROTOBUF_NODISCARD ::auth::UserGroup* release_group();
  ::auth::UserGroup* mutable_group();
  void set_allocated_group(::auth::UserGroup* group);
  private:
  const ::auth::UserGroup& _internal_group() const;
  ::auth::UserGroup* _internal_mutable_group();
  public:
  void unsafe_arena_set_allocated_group(
      ::auth::UserGroup* group);
  ::auth::UserGroup* unsafe_arena_release_group();

  // optional .auth.EditResponse.Error error = 2;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::auth::EditResponse_Error& error() const;
  PROTOBUF_NODISCARD ::auth::EditResponse_Error* release_error();
  ::auth::EditResponse_Error* mutable_error();
  void set_allocated_error(::auth::EditResponse_Error* error);
  private:
  const ::auth::EditResponse_Error& _internal_error() const;
  ::auth::EditResponse_Error* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::auth::EditResponse_Error* error);
  ::auth::EditResponse_Error* unsafe_arena_release_error();

  // @@protoc_insertion_point(class_scope:auth.EditResponse.UpdateUserGroup)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::auth::UserGroup* group_;
    ::auth::EditResponse_Error* error_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lc_5fkasse_5fauth_2fauth_2eproto;
};
// -------------------------------------------------------------------

class EditResponse_DeleteUser final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:auth.EditResponse.DeleteUser) */ {
 public:
  inline EditResponse_DeleteUser() : EditResponse_DeleteUser(nullptr) {}
  ~EditResponse_DeleteUser() override;
  explicit PROTOBUF_CONSTEXPR EditResponse_DeleteUser(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EditResponse_DeleteUser(const EditResponse_DeleteUser& from);
  EditResponse_DeleteUser(EditResponse_DeleteUser&& from) noexcept
    : EditResponse_DeleteUser() {
    *this = ::std::move(from);
  }

  inline EditResponse_DeleteUser& operator=(const EditResponse_DeleteUser& from) {
    CopyFrom(from);
    return *this;
  }
  inline EditResponse_DeleteUser& operator=(EditResponse_DeleteUser&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EditResponse_DeleteUser& default_instance() {
    return *internal_default_instance();
  }
  static inline const EditResponse_DeleteUser* internal_default_instance() {
    return reinterpret_cast<const EditResponse_DeleteUser*>(
               &_EditResponse_DeleteUser_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(EditResponse_DeleteUser& a, EditResponse_DeleteUser& b) {
    a.Swap(&b);
  }
  inline void Swap(EditResponse_DeleteUser* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EditResponse_DeleteUser* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EditResponse_DeleteUser* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EditResponse_DeleteUser>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EditResponse_DeleteUser& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EditResponse_DeleteUser& from) {
    EditResponse_DeleteUser::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EditResponse_DeleteUser* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "auth.EditResponse.DeleteUser";
  }
  protected:
  explicit EditResponse_DeleteUser(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 1,
  };
  // optional .auth.EditResponse.Error error = 1;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::auth::EditResponse_Error& error() const;
  PROTOBUF_NODISCARD ::auth::EditResponse_Error* release_error();
  ::auth::EditResponse_Error* mutable_error();
  void set_allocated_error(::auth::EditResponse_Error* error);
  private:
  const ::auth::EditResponse_Error& _internal_error() const;
  ::auth::EditResponse_Error* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::auth::EditResponse_Error* error);
  ::auth::EditResponse_Error* unsafe_arena_release_error();

  // @@protoc_insertion_point(class_scope:auth.EditResponse.DeleteUser)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::auth::EditResponse_Error* error_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lc_5fkasse_5fauth_2fauth_2eproto;
};
// -------------------------------------------------------------------

class EditResponse_DeleteUserGroup final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:auth.EditResponse.DeleteUserGroup) */ {
 public:
  inline EditResponse_DeleteUserGroup() : EditResponse_DeleteUserGroup(nullptr) {}
  ~EditResponse_DeleteUserGroup() override;
  explicit PROTOBUF_CONSTEXPR EditResponse_DeleteUserGroup(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EditResponse_DeleteUserGroup(const EditResponse_DeleteUserGroup& from);
  EditResponse_DeleteUserGroup(EditResponse_DeleteUserGroup&& from) noexcept
    : EditResponse_DeleteUserGroup() {
    *this = ::std::move(from);
  }

  inline EditResponse_DeleteUserGroup& operator=(const EditResponse_DeleteUserGroup& from) {
    CopyFrom(from);
    return *this;
  }
  inline EditResponse_DeleteUserGroup& operator=(EditResponse_DeleteUserGroup&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EditResponse_DeleteUserGroup& default_instance() {
    return *internal_default_instance();
  }
  static inline const EditResponse_DeleteUserGroup* internal_default_instance() {
    return reinterpret_cast<const EditResponse_DeleteUserGroup*>(
               &_EditResponse_DeleteUserGroup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(EditResponse_DeleteUserGroup& a, EditResponse_DeleteUserGroup& b) {
    a.Swap(&b);
  }
  inline void Swap(EditResponse_DeleteUserGroup* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EditResponse_DeleteUserGroup* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EditResponse_DeleteUserGroup* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EditResponse_DeleteUserGroup>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EditResponse_DeleteUserGroup& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EditResponse_DeleteUserGroup& from) {
    EditResponse_DeleteUserGroup::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EditResponse_DeleteUserGroup* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "auth.EditResponse.DeleteUserGroup";
  }
  protected:
  explicit EditResponse_DeleteUserGroup(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 1,
  };
  // optional .auth.EditResponse.Error error = 1;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::auth::EditResponse_Error& error() const;
  PROTOBUF_NODISCARD ::auth::EditResponse_Error* release_error();
  ::auth::EditResponse_Error* mutable_error();
  void set_allocated_error(::auth::EditResponse_Error* error);
  private:
  const ::auth::EditResponse_Error& _internal_error() const;
  ::auth::EditResponse_Error* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::auth::EditResponse_Error* error);
  ::auth::EditResponse_Error* unsafe_arena_release_error();

  // @@protoc_insertion_point(class_scope:auth.EditResponse.DeleteUserGroup)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::auth::EditResponse_Error* error_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lc_5fkasse_5fauth_2fauth_2eproto;
};
// -------------------------------------------------------------------

class EditResponse_CreateUser final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:auth.EditResponse.CreateUser) */ {
 public:
  inline EditResponse_CreateUser() : EditResponse_CreateUser(nullptr) {}
  ~EditResponse_CreateUser() override;
  explicit PROTOBUF_CONSTEXPR EditResponse_CreateUser(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EditResponse_CreateUser(const EditResponse_CreateUser& from);
  EditResponse_CreateUser(EditResponse_CreateUser&& from) noexcept
    : EditResponse_CreateUser() {
    *this = ::std::move(from);
  }

  inline EditResponse_CreateUser& operator=(const EditResponse_CreateUser& from) {
    CopyFrom(from);
    return *this;
  }
  inline EditResponse_CreateUser& operator=(EditResponse_CreateUser&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EditResponse_CreateUser& default_instance() {
    return *internal_default_instance();
  }
  static inline const EditResponse_CreateUser* internal_default_instance() {
    return reinterpret_cast<const EditResponse_CreateUser*>(
               &_EditResponse_CreateUser_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(EditResponse_CreateUser& a, EditResponse_CreateUser& b) {
    a.Swap(&b);
  }
  inline void Swap(EditResponse_CreateUser* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EditResponse_CreateUser* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EditResponse_CreateUser* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EditResponse_CreateUser>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EditResponse_CreateUser& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EditResponse_CreateUser& from) {
    EditResponse_CreateUser::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EditResponse_CreateUser* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "auth.EditResponse.CreateUser";
  }
  protected:
  explicit EditResponse_CreateUser(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserFieldNumber = 1,
    kErrorFieldNumber = 2,
  };
  // optional .auth.User user = 1;
  bool has_user() const;
  private:
  bool _internal_has_user() const;
  public:
  void clear_user();
  const ::auth::User& user() const;
  PROTOBUF_NODISCARD ::auth::User* release_user();
  ::auth::User* mutable_user();
  void set_allocated_user(::auth::User* user);
  private:
  const ::auth::User& _internal_user() const;
  ::auth::User* _internal_mutable_user();
  public:
  void unsafe_arena_set_allocated_user(
      ::auth::User* user);
  ::auth::User* unsafe_arena_release_user();

  // optional .auth.EditResponse.Error error = 2;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::auth::EditResponse_Error& error() const;
  PROTOBUF_NODISCARD ::auth::EditResponse_Error* release_error();
  ::auth::EditResponse_Error* mutable_error();
  void set_allocated_error(::auth::EditResponse_Error* error);
  private:
  const ::auth::EditResponse_Error& _internal_error() const;
  ::auth::EditResponse_Error* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::auth::EditResponse_Error* error);
  ::auth::EditResponse_Error* unsafe_arena_release_error();

  // @@protoc_insertion_point(class_scope:auth.EditResponse.CreateUser)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::auth::User* user_;
    ::auth::EditResponse_Error* error_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lc_5fkasse_5fauth_2fauth_2eproto;
};
// -------------------------------------------------------------------

class EditResponse_CreateUserGroup final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:auth.EditResponse.CreateUserGroup) */ {
 public:
  inline EditResponse_CreateUserGroup() : EditResponse_CreateUserGroup(nullptr) {}
  ~EditResponse_CreateUserGroup() override;
  explicit PROTOBUF_CONSTEXPR EditResponse_CreateUserGroup(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EditResponse_CreateUserGroup(const EditResponse_CreateUserGroup& from);
  EditResponse_CreateUserGroup(EditResponse_CreateUserGroup&& from) noexcept
    : EditResponse_CreateUserGroup() {
    *this = ::std::move(from);
  }

  inline EditResponse_CreateUserGroup& operator=(const EditResponse_CreateUserGroup& from) {
    CopyFrom(from);
    return *this;
  }
  inline EditResponse_CreateUserGroup& operator=(EditResponse_CreateUserGroup&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EditResponse_CreateUserGroup& default_instance() {
    return *internal_default_instance();
  }
  static inline const EditResponse_CreateUserGroup* internal_default_instance() {
    return reinterpret_cast<const EditResponse_CreateUserGroup*>(
               &_EditResponse_CreateUserGroup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(EditResponse_CreateUserGroup& a, EditResponse_CreateUserGroup& b) {
    a.Swap(&b);
  }
  inline void Swap(EditResponse_CreateUserGroup* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EditResponse_CreateUserGroup* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EditResponse_CreateUserGroup* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EditResponse_CreateUserGroup>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EditResponse_CreateUserGroup& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EditResponse_CreateUserGroup& from) {
    EditResponse_CreateUserGroup::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EditResponse_CreateUserGroup* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "auth.EditResponse.CreateUserGroup";
  }
  protected:
  explicit EditResponse_CreateUserGroup(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGroupFieldNumber = 1,
    kErrorFieldNumber = 2,
  };
  // optional .auth.UserGroup group = 1;
  bool has_group() const;
  private:
  bool _internal_has_group() const;
  public:
  void clear_group();
  const ::auth::UserGroup& group() const;
  PROTOBUF_NODISCARD ::auth::UserGroup* release_group();
  ::auth::UserGroup* mutable_group();
  void set_allocated_group(::auth::UserGroup* group);
  private:
  const ::auth::UserGroup& _internal_group() const;
  ::auth::UserGroup* _internal_mutable_group();
  public:
  void unsafe_arena_set_allocated_group(
      ::auth::UserGroup* group);
  ::auth::UserGroup* unsafe_arena_release_group();

  // optional .auth.EditResponse.Error error = 2;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::auth::EditResponse_Error& error() const;
  PROTOBUF_NODISCARD ::auth::EditResponse_Error* release_error();
  ::auth::EditResponse_Error* mutable_error();
  void set_allocated_error(::auth::EditResponse_Error* error);
  private:
  const ::auth::EditResponse_Error& _internal_error() const;
  ::auth::EditResponse_Error* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::auth::EditResponse_Error* error);
  ::auth::EditResponse_Error* unsafe_arena_release_error();

  // @@protoc_insertion_point(class_scope:auth.EditResponse.CreateUserGroup)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::auth::UserGroup* group_;
    ::auth::EditResponse_Error* error_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lc_5fkasse_5fauth_2fauth_2eproto;
};
// -------------------------------------------------------------------

class EditResponse_GetUserGroupsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:auth.EditResponse.GetUserGroupsResponse) */ {
 public:
  inline EditResponse_GetUserGroupsResponse() : EditResponse_GetUserGroupsResponse(nullptr) {}
  ~EditResponse_GetUserGroupsResponse() override;
  explicit PROTOBUF_CONSTEXPR EditResponse_GetUserGroupsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EditResponse_GetUserGroupsResponse(const EditResponse_GetUserGroupsResponse& from);
  EditResponse_GetUserGroupsResponse(EditResponse_GetUserGroupsResponse&& from) noexcept
    : EditResponse_GetUserGroupsResponse() {
    *this = ::std::move(from);
  }

  inline EditResponse_GetUserGroupsResponse& operator=(const EditResponse_GetUserGroupsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline EditResponse_GetUserGroupsResponse& operator=(EditResponse_GetUserGroupsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EditResponse_GetUserGroupsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const EditResponse_GetUserGroupsResponse* internal_default_instance() {
    return reinterpret_cast<const EditResponse_GetUserGroupsResponse*>(
               &_EditResponse_GetUserGroupsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(EditResponse_GetUserGroupsResponse& a, EditResponse_GetUserGroupsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(EditResponse_GetUserGroupsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EditResponse_GetUserGroupsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EditResponse_GetUserGroupsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EditResponse_GetUserGroupsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EditResponse_GetUserGroupsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EditResponse_GetUserGroupsResponse& from) {
    EditResponse_GetUserGroupsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EditResponse_GetUserGroupsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "auth.EditResponse.GetUserGroupsResponse";
  }
  protected:
  explicit EditResponse_GetUserGroupsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRespFieldNumber = 1,
    kErrorFieldNumber = 2,
  };
  // optional .auth.GetUserGroupsResp resp = 1;
  bool has_resp() const;
  private:
  bool _internal_has_resp() const;
  public:
  void clear_resp();
  const ::auth::GetUserGroupsResp& resp() const;
  PROTOBUF_NODISCARD ::auth::GetUserGroupsResp* release_resp();
  ::auth::GetUserGroupsResp* mutable_resp();
  void set_allocated_resp(::auth::GetUserGroupsResp* resp);
  private:
  const ::auth::GetUserGroupsResp& _internal_resp() const;
  ::auth::GetUserGroupsResp* _internal_mutable_resp();
  public:
  void unsafe_arena_set_allocated_resp(
      ::auth::GetUserGroupsResp* resp);
  ::auth::GetUserGroupsResp* unsafe_arena_release_resp();

  // optional .auth.EditResponse.Error error = 2;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::auth::EditResponse_Error& error() const;
  PROTOBUF_NODISCARD ::auth::EditResponse_Error* release_error();
  ::auth::EditResponse_Error* mutable_error();
  void set_allocated_error(::auth::EditResponse_Error* error);
  private:
  const ::auth::EditResponse_Error& _internal_error() const;
  ::auth::EditResponse_Error* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::auth::EditResponse_Error* error);
  ::auth::EditResponse_Error* unsafe_arena_release_error();

  // @@protoc_insertion_point(class_scope:auth.EditResponse.GetUserGroupsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::auth::GetUserGroupsResp* resp_;
    ::auth::EditResponse_Error* error_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lc_5fkasse_5fauth_2fauth_2eproto;
};
// -------------------------------------------------------------------

class EditResponse_GetUsersByGroupResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:auth.EditResponse.GetUsersByGroupResponse) */ {
 public:
  inline EditResponse_GetUsersByGroupResponse() : EditResponse_GetUsersByGroupResponse(nullptr) {}
  ~EditResponse_GetUsersByGroupResponse() override;
  explicit PROTOBUF_CONSTEXPR EditResponse_GetUsersByGroupResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EditResponse_GetUsersByGroupResponse(const EditResponse_GetUsersByGroupResponse& from);
  EditResponse_GetUsersByGroupResponse(EditResponse_GetUsersByGroupResponse&& from) noexcept
    : EditResponse_GetUsersByGroupResponse() {
    *this = ::std::move(from);
  }

  inline EditResponse_GetUsersByGroupResponse& operator=(const EditResponse_GetUsersByGroupResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline EditResponse_GetUsersByGroupResponse& operator=(EditResponse_GetUsersByGroupResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EditResponse_GetUsersByGroupResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const EditResponse_GetUsersByGroupResponse* internal_default_instance() {
    return reinterpret_cast<const EditResponse_GetUsersByGroupResponse*>(
               &_EditResponse_GetUsersByGroupResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(EditResponse_GetUsersByGroupResponse& a, EditResponse_GetUsersByGroupResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(EditResponse_GetUsersByGroupResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EditResponse_GetUsersByGroupResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EditResponse_GetUsersByGroupResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EditResponse_GetUsersByGroupResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EditResponse_GetUsersByGroupResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EditResponse_GetUsersByGroupResponse& from) {
    EditResponse_GetUsersByGroupResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EditResponse_GetUsersByGroupResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "auth.EditResponse.GetUsersByGroupResponse";
  }
  protected:
  explicit EditResponse_GetUsersByGroupResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRespFieldNumber = 1,
    kErrorFieldNumber = 2,
  };
  // optional .auth.GetUsersByGroupResp resp = 1;
  bool has_resp() const;
  private:
  bool _internal_has_resp() const;
  public:
  void clear_resp();
  const ::auth::GetUsersByGroupResp& resp() const;
  PROTOBUF_NODISCARD ::auth::GetUsersByGroupResp* release_resp();
  ::auth::GetUsersByGroupResp* mutable_resp();
  void set_allocated_resp(::auth::GetUsersByGroupResp* resp);
  private:
  const ::auth::GetUsersByGroupResp& _internal_resp() const;
  ::auth::GetUsersByGroupResp* _internal_mutable_resp();
  public:
  void unsafe_arena_set_allocated_resp(
      ::auth::GetUsersByGroupResp* resp);
  ::auth::GetUsersByGroupResp* unsafe_arena_release_resp();

  // optional .auth.EditResponse.Error error = 2;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::auth::EditResponse_Error& error() const;
  PROTOBUF_NODISCARD ::auth::EditResponse_Error* release_error();
  ::auth::EditResponse_Error* mutable_error();
  void set_allocated_error(::auth::EditResponse_Error* error);
  private:
  const ::auth::EditResponse_Error& _internal_error() const;
  ::auth::EditResponse_Error* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::auth::EditResponse_Error* error);
  ::auth::EditResponse_Error* unsafe_arena_release_error();

  // @@protoc_insertion_point(class_scope:auth.EditResponse.GetUsersByGroupResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::auth::GetUsersByGroupResp* resp_;
    ::auth::EditResponse_Error* error_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lc_5fkasse_5fauth_2fauth_2eproto;
};
// -------------------------------------------------------------------

class EditResponse_GetTerminal final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:auth.EditResponse.GetTerminal) */ {
 public:
  inline EditResponse_GetTerminal() : EditResponse_GetTerminal(nullptr) {}
  ~EditResponse_GetTerminal() override;
  explicit PROTOBUF_CONSTEXPR EditResponse_GetTerminal(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EditResponse_GetTerminal(const EditResponse_GetTerminal& from);
  EditResponse_GetTerminal(EditResponse_GetTerminal&& from) noexcept
    : EditResponse_GetTerminal() {
    *this = ::std::move(from);
  }

  inline EditResponse_GetTerminal& operator=(const EditResponse_GetTerminal& from) {
    CopyFrom(from);
    return *this;
  }
  inline EditResponse_GetTerminal& operator=(EditResponse_GetTerminal&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EditResponse_GetTerminal& default_instance() {
    return *internal_default_instance();
  }
  static inline const EditResponse_GetTerminal* internal_default_instance() {
    return reinterpret_cast<const EditResponse_GetTerminal*>(
               &_EditResponse_GetTerminal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(EditResponse_GetTerminal& a, EditResponse_GetTerminal& b) {
    a.Swap(&b);
  }
  inline void Swap(EditResponse_GetTerminal* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EditResponse_GetTerminal* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EditResponse_GetTerminal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EditResponse_GetTerminal>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EditResponse_GetTerminal& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EditResponse_GetTerminal& from) {
    EditResponse_GetTerminal::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EditResponse_GetTerminal* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "auth.EditResponse.GetTerminal";
  }
  protected:
  explicit EditResponse_GetTerminal(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTerminalFieldNumber = 1,
    kErrorFieldNumber = 2,
  };
  // optional .auth.Terminal terminal = 1;
  bool has_terminal() const;
  private:
  bool _internal_has_terminal() const;
  public:
  void clear_terminal();
  const ::auth::Terminal& terminal() const;
  PROTOBUF_NODISCARD ::auth::Terminal* release_terminal();
  ::auth::Terminal* mutable_terminal();
  void set_allocated_terminal(::auth::Terminal* terminal);
  private:
  const ::auth::Terminal& _internal_terminal() const;
  ::auth::Terminal* _internal_mutable_terminal();
  public:
  void unsafe_arena_set_allocated_terminal(
      ::auth::Terminal* terminal);
  ::auth::Terminal* unsafe_arena_release_terminal();

  // optional .auth.EditResponse.Error error = 2;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::auth::EditResponse_Error& error() const;
  PROTOBUF_NODISCARD ::auth::EditResponse_Error* release_error();
  ::auth::EditResponse_Error* mutable_error();
  void set_allocated_error(::auth::EditResponse_Error* error);
  private:
  const ::auth::EditResponse_Error& _internal_error() const;
  ::auth::EditResponse_Error* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::auth::EditResponse_Error* error);
  ::auth::EditResponse_Error* unsafe_arena_release_error();

  // @@protoc_insertion_point(class_scope:auth.EditResponse.GetTerminal)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::auth::Terminal* terminal_;
    ::auth::EditResponse_Error* error_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lc_5fkasse_5fauth_2fauth_2eproto;
};
// -------------------------------------------------------------------

class EditResponse_UpdateTerminal final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:auth.EditResponse.UpdateTerminal) */ {
 public:
  inline EditResponse_UpdateTerminal() : EditResponse_UpdateTerminal(nullptr) {}
  ~EditResponse_UpdateTerminal() override;
  explicit PROTOBUF_CONSTEXPR EditResponse_UpdateTerminal(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EditResponse_UpdateTerminal(const EditResponse_UpdateTerminal& from);
  EditResponse_UpdateTerminal(EditResponse_UpdateTerminal&& from) noexcept
    : EditResponse_UpdateTerminal() {
    *this = ::std::move(from);
  }

  inline EditResponse_UpdateTerminal& operator=(const EditResponse_UpdateTerminal& from) {
    CopyFrom(from);
    return *this;
  }
  inline EditResponse_UpdateTerminal& operator=(EditResponse_UpdateTerminal&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EditResponse_UpdateTerminal& default_instance() {
    return *internal_default_instance();
  }
  static inline const EditResponse_UpdateTerminal* internal_default_instance() {
    return reinterpret_cast<const EditResponse_UpdateTerminal*>(
               &_EditResponse_UpdateTerminal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(EditResponse_UpdateTerminal& a, EditResponse_UpdateTerminal& b) {
    a.Swap(&b);
  }
  inline void Swap(EditResponse_UpdateTerminal* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EditResponse_UpdateTerminal* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EditResponse_UpdateTerminal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EditResponse_UpdateTerminal>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EditResponse_UpdateTerminal& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EditResponse_UpdateTerminal& from) {
    EditResponse_UpdateTerminal::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EditResponse_UpdateTerminal* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "auth.EditResponse.UpdateTerminal";
  }
  protected:
  explicit EditResponse_UpdateTerminal(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTerminalFieldNumber = 1,
    kErrorFieldNumber = 2,
  };
  // optional .auth.Terminal terminal = 1;
  bool has_terminal() const;
  private:
  bool _internal_has_terminal() const;
  public:
  void clear_terminal();
  const ::auth::Terminal& terminal() const;
  PROTOBUF_NODISCARD ::auth::Terminal* release_terminal();
  ::auth::Terminal* mutable_terminal();
  void set_allocated_terminal(::auth::Terminal* terminal);
  private:
  const ::auth::Terminal& _internal_terminal() const;
  ::auth::Terminal* _internal_mutable_terminal();
  public:
  void unsafe_arena_set_allocated_terminal(
      ::auth::Terminal* terminal);
  ::auth::Terminal* unsafe_arena_release_terminal();

  // optional .auth.EditResponse.Error error = 2;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::auth::EditResponse_Error& error() const;
  PROTOBUF_NODISCARD ::auth::EditResponse_Error* release_error();
  ::auth::EditResponse_Error* mutable_error();
  void set_allocated_error(::auth::EditResponse_Error* error);
  private:
  const ::auth::EditResponse_Error& _internal_error() const;
  ::auth::EditResponse_Error* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::auth::EditResponse_Error* error);
  ::auth::EditResponse_Error* unsafe_arena_release_error();

  // @@protoc_insertion_point(class_scope:auth.EditResponse.UpdateTerminal)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::auth::Terminal* terminal_;
    ::auth::EditResponse_Error* error_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lc_5fkasse_5fauth_2fauth_2eproto;
};
// -------------------------------------------------------------------

class EditResponse_DeleteTerminal final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:auth.EditResponse.DeleteTerminal) */ {
 public:
  inline EditResponse_DeleteTerminal() : EditResponse_DeleteTerminal(nullptr) {}
  ~EditResponse_DeleteTerminal() override;
  explicit PROTOBUF_CONSTEXPR EditResponse_DeleteTerminal(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EditResponse_DeleteTerminal(const EditResponse_DeleteTerminal& from);
  EditResponse_DeleteTerminal(EditResponse_DeleteTerminal&& from) noexcept
    : EditResponse_DeleteTerminal() {
    *this = ::std::move(from);
  }

  inline EditResponse_DeleteTerminal& operator=(const EditResponse_DeleteTerminal& from) {
    CopyFrom(from);
    return *this;
  }
  inline EditResponse_DeleteTerminal& operator=(EditResponse_DeleteTerminal&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EditResponse_DeleteTerminal& default_instance() {
    return *internal_default_instance();
  }
  static inline const EditResponse_DeleteTerminal* internal_default_instance() {
    return reinterpret_cast<const EditResponse_DeleteTerminal*>(
               &_EditResponse_DeleteTerminal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(EditResponse_DeleteTerminal& a, EditResponse_DeleteTerminal& b) {
    a.Swap(&b);
  }
  inline void Swap(EditResponse_DeleteTerminal* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EditResponse_DeleteTerminal* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EditResponse_DeleteTerminal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EditResponse_DeleteTerminal>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EditResponse_DeleteTerminal& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EditResponse_DeleteTerminal& from) {
    EditResponse_DeleteTerminal::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EditResponse_DeleteTerminal* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "auth.EditResponse.DeleteTerminal";
  }
  protected:
  explicit EditResponse_DeleteTerminal(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 1,
  };
  // optional .auth.EditResponse.Error error = 1;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::auth::EditResponse_Error& error() const;
  PROTOBUF_NODISCARD ::auth::EditResponse_Error* release_error();
  ::auth::EditResponse_Error* mutable_error();
  void set_allocated_error(::auth::EditResponse_Error* error);
  private:
  const ::auth::EditResponse_Error& _internal_error() const;
  ::auth::EditResponse_Error* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::auth::EditResponse_Error* error);
  ::auth::EditResponse_Error* unsafe_arena_release_error();

  // @@protoc_insertion_point(class_scope:auth.EditResponse.DeleteTerminal)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::auth::EditResponse_Error* error_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lc_5fkasse_5fauth_2fauth_2eproto;
};
// -------------------------------------------------------------------

class EditResponse_GetTerminals final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:auth.EditResponse.GetTerminals) */ {
 public:
  inline EditResponse_GetTerminals() : EditResponse_GetTerminals(nullptr) {}
  ~EditResponse_GetTerminals() override;
  explicit PROTOBUF_CONSTEXPR EditResponse_GetTerminals(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EditResponse_GetTerminals(const EditResponse_GetTerminals& from);
  EditResponse_GetTerminals(EditResponse_GetTerminals&& from) noexcept
    : EditResponse_GetTerminals() {
    *this = ::std::move(from);
  }

  inline EditResponse_GetTerminals& operator=(const EditResponse_GetTerminals& from) {
    CopyFrom(from);
    return *this;
  }
  inline EditResponse_GetTerminals& operator=(EditResponse_GetTerminals&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EditResponse_GetTerminals& default_instance() {
    return *internal_default_instance();
  }
  static inline const EditResponse_GetTerminals* internal_default_instance() {
    return reinterpret_cast<const EditResponse_GetTerminals*>(
               &_EditResponse_GetTerminals_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(EditResponse_GetTerminals& a, EditResponse_GetTerminals& b) {
    a.Swap(&b);
  }
  inline void Swap(EditResponse_GetTerminals* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EditResponse_GetTerminals* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EditResponse_GetTerminals* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EditResponse_GetTerminals>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EditResponse_GetTerminals& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EditResponse_GetTerminals& from) {
    EditResponse_GetTerminals::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EditResponse_GetTerminals* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "auth.EditResponse.GetTerminals";
  }
  protected:
  explicit EditResponse_GetTerminals(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTerminalsFieldNumber = 1,
    kErrorFieldNumber = 2,
  };
  // optional .auth.EditResponse.TerminalsResp terminals = 1;
  bool has_terminals() const;
  private:
  bool _internal_has_terminals() const;
  public:
  void clear_terminals();
  const ::auth::EditResponse_TerminalsResp& terminals() const;
  PROTOBUF_NODISCARD ::auth::EditResponse_TerminalsResp* release_terminals();
  ::auth::EditResponse_TerminalsResp* mutable_terminals();
  void set_allocated_terminals(::auth::EditResponse_TerminalsResp* terminals);
  private:
  const ::auth::EditResponse_TerminalsResp& _internal_terminals() const;
  ::auth::EditResponse_TerminalsResp* _internal_mutable_terminals();
  public:
  void unsafe_arena_set_allocated_terminals(
      ::auth::EditResponse_TerminalsResp* terminals);
  ::auth::EditResponse_TerminalsResp* unsafe_arena_release_terminals();

  // optional .auth.EditResponse.Error error = 2;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::auth::EditResponse_Error& error() const;
  PROTOBUF_NODISCARD ::auth::EditResponse_Error* release_error();
  ::auth::EditResponse_Error* mutable_error();
  void set_allocated_error(::auth::EditResponse_Error* error);
  private:
  const ::auth::EditResponse_Error& _internal_error() const;
  ::auth::EditResponse_Error* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::auth::EditResponse_Error* error);
  ::auth::EditResponse_Error* unsafe_arena_release_error();

  // @@protoc_insertion_point(class_scope:auth.EditResponse.GetTerminals)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::auth::EditResponse_TerminalsResp* terminals_;
    ::auth::EditResponse_Error* error_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lc_5fkasse_5fauth_2fauth_2eproto;
};
// -------------------------------------------------------------------

class EditResponse_CreateTerminal final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:auth.EditResponse.CreateTerminal) */ {
 public:
  inline EditResponse_CreateTerminal() : EditResponse_CreateTerminal(nullptr) {}
  ~EditResponse_CreateTerminal() override;
  explicit PROTOBUF_CONSTEXPR EditResponse_CreateTerminal(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EditResponse_CreateTerminal(const EditResponse_CreateTerminal& from);
  EditResponse_CreateTerminal(EditResponse_CreateTerminal&& from) noexcept
    : EditResponse_CreateTerminal() {
    *this = ::std::move(from);
  }

  inline EditResponse_CreateTerminal& operator=(const EditResponse_CreateTerminal& from) {
    CopyFrom(from);
    return *this;
  }
  inline EditResponse_CreateTerminal& operator=(EditResponse_CreateTerminal&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EditResponse_CreateTerminal& default_instance() {
    return *internal_default_instance();
  }
  static inline const EditResponse_CreateTerminal* internal_default_instance() {
    return reinterpret_cast<const EditResponse_CreateTerminal*>(
               &_EditResponse_CreateTerminal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(EditResponse_CreateTerminal& a, EditResponse_CreateTerminal& b) {
    a.Swap(&b);
  }
  inline void Swap(EditResponse_CreateTerminal* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EditResponse_CreateTerminal* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EditResponse_CreateTerminal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EditResponse_CreateTerminal>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EditResponse_CreateTerminal& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EditResponse_CreateTerminal& from) {
    EditResponse_CreateTerminal::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EditResponse_CreateTerminal* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "auth.EditResponse.CreateTerminal";
  }
  protected:
  explicit EditResponse_CreateTerminal(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTerminalFieldNumber = 1,
    kErrorFieldNumber = 2,
  };
  // optional .auth.Terminal terminal = 1;
  bool has_terminal() const;
  private:
  bool _internal_has_terminal() const;
  public:
  void clear_terminal();
  const ::auth::Terminal& terminal() const;
  PROTOBUF_NODISCARD ::auth::Terminal* release_terminal();
  ::auth::Terminal* mutable_terminal();
  void set_allocated_terminal(::auth::Terminal* terminal);
  private:
  const ::auth::Terminal& _internal_terminal() const;
  ::auth::Terminal* _internal_mutable_terminal();
  public:
  void unsafe_arena_set_allocated_terminal(
      ::auth::Terminal* terminal);
  ::auth::Terminal* unsafe_arena_release_terminal();

  // optional .auth.EditResponse.Error error = 2;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::auth::EditResponse_Error& error() const;
  PROTOBUF_NODISCARD ::auth::EditResponse_Error* release_error();
  ::auth::EditResponse_Error* mutable_error();
  void set_allocated_error(::auth::EditResponse_Error* error);
  private:
  const ::auth::EditResponse_Error& _internal_error() const;
  ::auth::EditResponse_Error* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::auth::EditResponse_Error* error);
  ::auth::EditResponse_Error* unsafe_arena_release_error();

  // @@protoc_insertion_point(class_scope:auth.EditResponse.CreateTerminal)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::auth::Terminal* terminal_;
    ::auth::EditResponse_Error* error_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lc_5fkasse_5fauth_2fauth_2eproto;
};
// -------------------------------------------------------------------

class EditResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:auth.EditResponse) */ {
 public:
  inline EditResponse() : EditResponse(nullptr) {}
  ~EditResponse() override;
  explicit PROTOBUF_CONSTEXPR EditResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EditResponse(const EditResponse& from);
  EditResponse(EditResponse&& from) noexcept
    : EditResponse() {
    *this = ::std::move(from);
  }

  inline EditResponse& operator=(const EditResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline EditResponse& operator=(EditResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EditResponse& default_instance() {
    return *internal_default_instance();
  }
  enum ResponseCase {
    kGetUserResponse = 1,
    kGetUserGroupResponse = 2,
    kUpdateUserResponse = 3,
    kUpdateUserGroupResponse = 4,
    kDeleteUserResponse = 5,
    kDeleteUserGroupResponse = 6,
    kCreateUserResponse = 7,
    kCreateUserGroupResponse = 8,
    kGetUserGroupsResp = 9,
    kGetUsersByGroupResp = 10,
    kGetTerminalResponse = 11,
    kUpdateTerminalResponse = 12,
    kDeleteTerminalResponse = 13,
    kGetTerminals = 14,
    kCreateTerminalResponse = 15,
    RESPONSE_NOT_SET = 0,
  };

  static inline const EditResponse* internal_default_instance() {
    return reinterpret_cast<const EditResponse*>(
               &_EditResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(EditResponse& a, EditResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(EditResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EditResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EditResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EditResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EditResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EditResponse& from) {
    EditResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EditResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "auth.EditResponse";
  }
  protected:
  explicit EditResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef EditResponse_TerminalsResp TerminalsResp;
  typedef EditResponse_Error Error;
  typedef EditResponse_GetUser GetUser;
  typedef EditResponse_GetUserGroup GetUserGroup;
  typedef EditResponse_UpdateUser UpdateUser;
  typedef EditResponse_UpdateUserGroup UpdateUserGroup;
  typedef EditResponse_DeleteUser DeleteUser;
  typedef EditResponse_DeleteUserGroup DeleteUserGroup;
  typedef EditResponse_CreateUser CreateUser;
  typedef EditResponse_CreateUserGroup CreateUserGroup;
  typedef EditResponse_GetUserGroupsResponse GetUserGroupsResponse;
  typedef EditResponse_GetUsersByGroupResponse GetUsersByGroupResponse;
  typedef EditResponse_GetTerminal GetTerminal;
  typedef EditResponse_UpdateTerminal UpdateTerminal;
  typedef EditResponse_DeleteTerminal DeleteTerminal;
  typedef EditResponse_GetTerminals GetTerminals;
  typedef EditResponse_CreateTerminal CreateTerminal;

  // accessors -------------------------------------------------------

  enum : int {
    kGetUserResponseFieldNumber = 1,
    kGetUserGroupResponseFieldNumber = 2,
    kUpdateUserResponseFieldNumber = 3,
    kUpdateUserGroupResponseFieldNumber = 4,
    kDeleteUserResponseFieldNumber = 5,
    kDeleteUserGroupResponseFieldNumber = 6,
    kCreateUserResponseFieldNumber = 7,
    kCreateUserGroupResponseFieldNumber = 8,
    kGetUserGroupsRespFieldNumber = 9,
    kGetUsersByGroupRespFieldNumber = 10,
    kGetTerminalResponseFieldNumber = 11,
    kUpdateTerminalResponseFieldNumber = 12,
    kDeleteTerminalResponseFieldNumber = 13,
    kGetTerminalsFieldNumber = 14,
    kCreateTerminalResponseFieldNumber = 15,
  };
  // .auth.EditResponse.GetUser getUserResponse = 1;
  bool has_getuserresponse() const;
  private:
  bool _internal_has_getuserresponse() const;
  public:
  void clear_getuserresponse();
  const ::auth::EditResponse_GetUser& getuserresponse() const;
  PROTOBUF_NODISCARD ::auth::EditResponse_GetUser* release_getuserresponse();
  ::auth::EditResponse_GetUser* mutable_getuserresponse();
  void set_allocated_getuserresponse(::auth::EditResponse_GetUser* getuserresponse);
  private:
  const ::auth::EditResponse_GetUser& _internal_getuserresponse() const;
  ::auth::EditResponse_GetUser* _internal_mutable_getuserresponse();
  public:
  void unsafe_arena_set_allocated_getuserresponse(
      ::auth::EditResponse_GetUser* getuserresponse);
  ::auth::EditResponse_GetUser* unsafe_arena_release_getuserresponse();

  // .auth.EditResponse.GetUserGroup getUserGroupResponse = 2;
  bool has_getusergroupresponse() const;
  private:
  bool _internal_has_getusergroupresponse() const;
  public:
  void clear_getusergroupresponse();
  const ::auth::EditResponse_GetUserGroup& getusergroupresponse() const;
  PROTOBUF_NODISCARD ::auth::EditResponse_GetUserGroup* release_getusergroupresponse();
  ::auth::EditResponse_GetUserGroup* mutable_getusergroupresponse();
  void set_allocated_getusergroupresponse(::auth::EditResponse_GetUserGroup* getusergroupresponse);
  private:
  const ::auth::EditResponse_GetUserGroup& _internal_getusergroupresponse() const;
  ::auth::EditResponse_GetUserGroup* _internal_mutable_getusergroupresponse();
  public:
  void unsafe_arena_set_allocated_getusergroupresponse(
      ::auth::EditResponse_GetUserGroup* getusergroupresponse);
  ::auth::EditResponse_GetUserGroup* unsafe_arena_release_getusergroupresponse();

  // .auth.EditResponse.UpdateUser updateUserResponse = 3;
  bool has_updateuserresponse() const;
  private:
  bool _internal_has_updateuserresponse() const;
  public:
  void clear_updateuserresponse();
  const ::auth::EditResponse_UpdateUser& updateuserresponse() const;
  PROTOBUF_NODISCARD ::auth::EditResponse_UpdateUser* release_updateuserresponse();
  ::auth::EditResponse_UpdateUser* mutable_updateuserresponse();
  void set_allocated_updateuserresponse(::auth::EditResponse_UpdateUser* updateuserresponse);
  private:
  const ::auth::EditResponse_UpdateUser& _internal_updateuserresponse() const;
  ::auth::EditResponse_UpdateUser* _internal_mutable_updateuserresponse();
  public:
  void unsafe_arena_set_allocated_updateuserresponse(
      ::auth::EditResponse_UpdateUser* updateuserresponse);
  ::auth::EditResponse_UpdateUser* unsafe_arena_release_updateuserresponse();

  // .auth.EditResponse.UpdateUserGroup updateUserGroupResponse = 4;
  bool has_updateusergroupresponse() const;
  private:
  bool _internal_has_updateusergroupresponse() const;
  public:
  void clear_updateusergroupresponse();
  const ::auth::EditResponse_UpdateUserGroup& updateusergroupresponse() const;
  PROTOBUF_NODISCARD ::auth::EditResponse_UpdateUserGroup* release_updateusergroupresponse();
  ::auth::EditResponse_UpdateUserGroup* mutable_updateusergroupresponse();
  void set_allocated_updateusergroupresponse(::auth::EditResponse_UpdateUserGroup* updateusergroupresponse);
  private:
  const ::auth::EditResponse_UpdateUserGroup& _internal_updateusergroupresponse() const;
  ::auth::EditResponse_UpdateUserGroup* _internal_mutable_updateusergroupresponse();
  public:
  void unsafe_arena_set_allocated_updateusergroupresponse(
      ::auth::EditResponse_UpdateUserGroup* updateusergroupresponse);
  ::auth::EditResponse_UpdateUserGroup* unsafe_arena_release_updateusergroupresponse();

  // .auth.EditResponse.DeleteUser deleteUserResponse = 5;
  bool has_deleteuserresponse() const;
  private:
  bool _internal_has_deleteuserresponse() const;
  public:
  void clear_deleteuserresponse();
  const ::auth::EditResponse_DeleteUser& deleteuserresponse() const;
  PROTOBUF_NODISCARD ::auth::EditResponse_DeleteUser* release_deleteuserresponse();
  ::auth::EditResponse_DeleteUser* mutable_deleteuserresponse();
  void set_allocated_deleteuserresponse(::auth::EditResponse_DeleteUser* deleteuserresponse);
  private:
  const ::auth::EditResponse_DeleteUser& _internal_deleteuserresponse() const;
  ::auth::EditResponse_DeleteUser* _internal_mutable_deleteuserresponse();
  public:
  void unsafe_arena_set_allocated_deleteuserresponse(
      ::auth::EditResponse_DeleteUser* deleteuserresponse);
  ::auth::EditResponse_DeleteUser* unsafe_arena_release_deleteuserresponse();

  // .auth.EditResponse.DeleteUserGroup deleteUserGroupResponse = 6;
  bool has_deleteusergroupresponse() const;
  private:
  bool _internal_has_deleteusergroupresponse() const;
  public:
  void clear_deleteusergroupresponse();
  const ::auth::EditResponse_DeleteUserGroup& deleteusergroupresponse() const;
  PROTOBUF_NODISCARD ::auth::EditResponse_DeleteUserGroup* release_deleteusergroupresponse();
  ::auth::EditResponse_DeleteUserGroup* mutable_deleteusergroupresponse();
  void set_allocated_deleteusergroupresponse(::auth::EditResponse_DeleteUserGroup* deleteusergroupresponse);
  private:
  const ::auth::EditResponse_DeleteUserGroup& _internal_deleteusergroupresponse() const;
  ::auth::EditResponse_DeleteUserGroup* _internal_mutable_deleteusergroupresponse();
  public:
  void unsafe_arena_set_allocated_deleteusergroupresponse(
      ::auth::EditResponse_DeleteUserGroup* deleteusergroupresponse);
  ::auth::EditResponse_DeleteUserGroup* unsafe_arena_release_deleteusergroupresponse();

  // .auth.EditResponse.CreateUser createUserResponse = 7;
  bool has_createuserresponse() const;
  private:
  bool _internal_has_createuserresponse() const;
  public:
  void clear_createuserresponse();
  const ::auth::EditResponse_CreateUser& createuserresponse() const;
  PROTOBUF_NODISCARD ::auth::EditResponse_CreateUser* release_createuserresponse();
  ::auth::EditResponse_CreateUser* mutable_createuserresponse();
  void set_allocated_createuserresponse(::auth::EditResponse_CreateUser* createuserresponse);
  private:
  const ::auth::EditResponse_CreateUser& _internal_createuserresponse() const;
  ::auth::EditResponse_CreateUser* _internal_mutable_createuserresponse();
  public:
  void unsafe_arena_set_allocated_createuserresponse(
      ::auth::EditResponse_CreateUser* createuserresponse);
  ::auth::EditResponse_CreateUser* unsafe_arena_release_createuserresponse();

  // .auth.EditResponse.CreateUserGroup createUserGroupResponse = 8;
  bool has_createusergroupresponse() const;
  private:
  bool _internal_has_createusergroupresponse() const;
  public:
  void clear_createusergroupresponse();
  const ::auth::EditResponse_CreateUserGroup& createusergroupresponse() const;
  PROTOBUF_NODISCARD ::auth::EditResponse_CreateUserGroup* release_createusergroupresponse();
  ::auth::EditResponse_CreateUserGroup* mutable_createusergroupresponse();
  void set_allocated_createusergroupresponse(::auth::EditResponse_CreateUserGroup* createusergroupresponse);
  private:
  const ::auth::EditResponse_CreateUserGroup& _internal_createusergroupresponse() const;
  ::auth::EditResponse_CreateUserGroup* _internal_mutable_createusergroupresponse();
  public:
  void unsafe_arena_set_allocated_createusergroupresponse(
      ::auth::EditResponse_CreateUserGroup* createusergroupresponse);
  ::auth::EditResponse_CreateUserGroup* unsafe_arena_release_createusergroupresponse();

  // .auth.EditResponse.GetUserGroupsResponse getUserGroupsResp = 9;
  bool has_getusergroupsresp() const;
  private:
  bool _internal_has_getusergroupsresp() const;
  public:
  void clear_getusergroupsresp();
  const ::auth::EditResponse_GetUserGroupsResponse& getusergroupsresp() const;
  PROTOBUF_NODISCARD ::auth::EditResponse_GetUserGroupsResponse* release_getusergroupsresp();
  ::auth::EditResponse_GetUserGroupsResponse* mutable_getusergroupsresp();
  void set_allocated_getusergroupsresp(::auth::EditResponse_GetUserGroupsResponse* getusergroupsresp);
  private:
  const ::auth::EditResponse_GetUserGroupsResponse& _internal_getusergroupsresp() const;
  ::auth::EditResponse_GetUserGroupsResponse* _internal_mutable_getusergroupsresp();
  public:
  void unsafe_arena_set_allocated_getusergroupsresp(
      ::auth::EditResponse_GetUserGroupsResponse* getusergroupsresp);
  ::auth::EditResponse_GetUserGroupsResponse* unsafe_arena_release_getusergroupsresp();

  // .auth.EditResponse.GetUsersByGroupResponse getUsersByGroupResp = 10;
  bool has_getusersbygroupresp() const;
  private:
  bool _internal_has_getusersbygroupresp() const;
  public:
  void clear_getusersbygroupresp();
  const ::auth::EditResponse_GetUsersByGroupResponse& getusersbygroupresp() const;
  PROTOBUF_NODISCARD ::auth::EditResponse_GetUsersByGroupResponse* release_getusersbygroupresp();
  ::auth::EditResponse_GetUsersByGroupResponse* mutable_getusersbygroupresp();
  void set_allocated_getusersbygroupresp(::auth::EditResponse_GetUsersByGroupResponse* getusersbygroupresp);
  private:
  const ::auth::EditResponse_GetUsersByGroupResponse& _internal_getusersbygroupresp() const;
  ::auth::EditResponse_GetUsersByGroupResponse* _internal_mutable_getusersbygroupresp();
  public:
  void unsafe_arena_set_allocated_getusersbygroupresp(
      ::auth::EditResponse_GetUsersByGroupResponse* getusersbygroupresp);
  ::auth::EditResponse_GetUsersByGroupResponse* unsafe_arena_release_getusersbygroupresp();

  // .auth.EditResponse.GetTerminal getTerminalResponse = 11;
  bool has_getterminalresponse() const;
  private:
  bool _internal_has_getterminalresponse() const;
  public:
  void clear_getterminalresponse();
  const ::auth::EditResponse_GetTerminal& getterminalresponse() const;
  PROTOBUF_NODISCARD ::auth::EditResponse_GetTerminal* release_getterminalresponse();
  ::auth::EditResponse_GetTerminal* mutable_getterminalresponse();
  void set_allocated_getterminalresponse(::auth::EditResponse_GetTerminal* getterminalresponse);
  private:
  const ::auth::EditResponse_GetTerminal& _internal_getterminalresponse() const;
  ::auth::EditResponse_GetTerminal* _internal_mutable_getterminalresponse();
  public:
  void unsafe_arena_set_allocated_getterminalresponse(
      ::auth::EditResponse_GetTerminal* getterminalresponse);
  ::auth::EditResponse_GetTerminal* unsafe_arena_release_getterminalresponse();

  // .auth.EditResponse.UpdateTerminal updateTerminalResponse = 12;
  bool has_updateterminalresponse() const;
  private:
  bool _internal_has_updateterminalresponse() const;
  public:
  void clear_updateterminalresponse();
  const ::auth::EditResponse_UpdateTerminal& updateterminalresponse() const;
  PROTOBUF_NODISCARD ::auth::EditResponse_UpdateTerminal* release_updateterminalresponse();
  ::auth::EditResponse_UpdateTerminal* mutable_updateterminalresponse();
  void set_allocated_updateterminalresponse(::auth::EditResponse_UpdateTerminal* updateterminalresponse);
  private:
  const ::auth::EditResponse_UpdateTerminal& _internal_updateterminalresponse() const;
  ::auth::EditResponse_UpdateTerminal* _internal_mutable_updateterminalresponse();
  public:
  void unsafe_arena_set_allocated_updateterminalresponse(
      ::auth::EditResponse_UpdateTerminal* updateterminalresponse);
  ::auth::EditResponse_UpdateTerminal* unsafe_arena_release_updateterminalresponse();

  // .auth.EditResponse.DeleteTerminal deleteTerminalResponse = 13;
  bool has_deleteterminalresponse() const;
  private:
  bool _internal_has_deleteterminalresponse() const;
  public:
  void clear_deleteterminalresponse();
  const ::auth::EditResponse_DeleteTerminal& deleteterminalresponse() const;
  PROTOBUF_NODISCARD ::auth::EditResponse_DeleteTerminal* release_deleteterminalresponse();
  ::auth::EditResponse_DeleteTerminal* mutable_deleteterminalresponse();
  void set_allocated_deleteterminalresponse(::auth::EditResponse_DeleteTerminal* deleteterminalresponse);
  private:
  const ::auth::EditResponse_DeleteTerminal& _internal_deleteterminalresponse() const;
  ::auth::EditResponse_DeleteTerminal* _internal_mutable_deleteterminalresponse();
  public:
  void unsafe_arena_set_allocated_deleteterminalresponse(
      ::auth::EditResponse_DeleteTerminal* deleteterminalresponse);
  ::auth::EditResponse_DeleteTerminal* unsafe_arena_release_deleteterminalresponse();

  // .auth.EditResponse.GetTerminals getTerminals = 14;
  bool has_getterminals() const;
  private:
  bool _internal_has_getterminals() const;
  public:
  void clear_getterminals();
  const ::auth::EditResponse_GetTerminals& getterminals() const;
  PROTOBUF_NODISCARD ::auth::EditResponse_GetTerminals* release_getterminals();
  ::auth::EditResponse_GetTerminals* mutable_getterminals();
  void set_allocated_getterminals(::auth::EditResponse_GetTerminals* getterminals);
  private:
  const ::auth::EditResponse_GetTerminals& _internal_getterminals() const;
  ::auth::EditResponse_GetTerminals* _internal_mutable_getterminals();
  public:
  void unsafe_arena_set_allocated_getterminals(
      ::auth::EditResponse_GetTerminals* getterminals);
  ::auth::EditResponse_GetTerminals* unsafe_arena_release_getterminals();

  // .auth.EditResponse.CreateTerminal createTerminalResponse = 15;
  bool has_createterminalresponse() const;
  private:
  bool _internal_has_createterminalresponse() const;
  public:
  void clear_createterminalresponse();
  const ::auth::EditResponse_CreateTerminal& createterminalresponse() const;
  PROTOBUF_NODISCARD ::auth::EditResponse_CreateTerminal* release_createterminalresponse();
  ::auth::EditResponse_CreateTerminal* mutable_createterminalresponse();
  void set_allocated_createterminalresponse(::auth::EditResponse_CreateTerminal* createterminalresponse);
  private:
  const ::auth::EditResponse_CreateTerminal& _internal_createterminalresponse() const;
  ::auth::EditResponse_CreateTerminal* _internal_mutable_createterminalresponse();
  public:
  void unsafe_arena_set_allocated_createterminalresponse(
      ::auth::EditResponse_CreateTerminal* createterminalresponse);
  ::auth::EditResponse_CreateTerminal* unsafe_arena_release_createterminalresponse();

  void clear_response();
  ResponseCase response_case() const;
  // @@protoc_insertion_point(class_scope:auth.EditResponse)
 private:
  class _Internal;
  void set_has_getuserresponse();
  void set_has_getusergroupresponse();
  void set_has_updateuserresponse();
  void set_has_updateusergroupresponse();
  void set_has_deleteuserresponse();
  void set_has_deleteusergroupresponse();
  void set_has_createuserresponse();
  void set_has_createusergroupresponse();
  void set_has_getusergroupsresp();
  void set_has_getusersbygroupresp();
  void set_has_getterminalresponse();
  void set_has_updateterminalresponse();
  void set_has_deleteterminalresponse();
  void set_has_getterminals();
  void set_has_createterminalresponse();

  inline bool has_response() const;
  inline void clear_has_response();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ResponseUnion {
      constexpr ResponseUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::auth::EditResponse_GetUser* getuserresponse_;
      ::auth::EditResponse_GetUserGroup* getusergroupresponse_;
      ::auth::EditResponse_UpdateUser* updateuserresponse_;
      ::auth::EditResponse_UpdateUserGroup* updateusergroupresponse_;
      ::auth::EditResponse_DeleteUser* deleteuserresponse_;
      ::auth::EditResponse_DeleteUserGroup* deleteusergroupresponse_;
      ::auth::EditResponse_CreateUser* createuserresponse_;
      ::auth::EditResponse_CreateUserGroup* createusergroupresponse_;
      ::auth::EditResponse_GetUserGroupsResponse* getusergroupsresp_;
      ::auth::EditResponse_GetUsersByGroupResponse* getusersbygroupresp_;
      ::auth::EditResponse_GetTerminal* getterminalresponse_;
      ::auth::EditResponse_UpdateTerminal* updateterminalresponse_;
      ::auth::EditResponse_DeleteTerminal* deleteterminalresponse_;
      ::auth::EditResponse_GetTerminals* getterminals_;
      ::auth::EditResponse_CreateTerminal* createterminalresponse_;
    } response_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lc_5fkasse_5fauth_2fauth_2eproto;
};
// -------------------------------------------------------------------

class SubscribeCommands_Subscribe final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:auth.SubscribeCommands.Subscribe) */ {
 public:
  inline SubscribeCommands_Subscribe() : SubscribeCommands_Subscribe(nullptr) {}
  explicit PROTOBUF_CONSTEXPR SubscribeCommands_Subscribe(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubscribeCommands_Subscribe(const SubscribeCommands_Subscribe& from);
  SubscribeCommands_Subscribe(SubscribeCommands_Subscribe&& from) noexcept
    : SubscribeCommands_Subscribe() {
    *this = ::std::move(from);
  }

  inline SubscribeCommands_Subscribe& operator=(const SubscribeCommands_Subscribe& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribeCommands_Subscribe& operator=(SubscribeCommands_Subscribe&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscribeCommands_Subscribe& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubscribeCommands_Subscribe* internal_default_instance() {
    return reinterpret_cast<const SubscribeCommands_Subscribe*>(
               &_SubscribeCommands_Subscribe_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(SubscribeCommands_Subscribe& a, SubscribeCommands_Subscribe& b) {
    a.Swap(&b);
  }
  inline void Swap(SubscribeCommands_Subscribe* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscribeCommands_Subscribe* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscribeCommands_Subscribe* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubscribeCommands_Subscribe>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SubscribeCommands_Subscribe& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SubscribeCommands_Subscribe& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "auth.SubscribeCommands.Subscribe";
  }
  protected:
  explicit SubscribeCommands_Subscribe(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:auth.SubscribeCommands.Subscribe)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_lc_5fkasse_5fauth_2fauth_2eproto;
};
// -------------------------------------------------------------------

class SubscribeCommands_Unsubscribe final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:auth.SubscribeCommands.Unsubscribe) */ {
 public:
  inline SubscribeCommands_Unsubscribe() : SubscribeCommands_Unsubscribe(nullptr) {}
  explicit PROTOBUF_CONSTEXPR SubscribeCommands_Unsubscribe(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubscribeCommands_Unsubscribe(const SubscribeCommands_Unsubscribe& from);
  SubscribeCommands_Unsubscribe(SubscribeCommands_Unsubscribe&& from) noexcept
    : SubscribeCommands_Unsubscribe() {
    *this = ::std::move(from);
  }

  inline SubscribeCommands_Unsubscribe& operator=(const SubscribeCommands_Unsubscribe& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribeCommands_Unsubscribe& operator=(SubscribeCommands_Unsubscribe&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscribeCommands_Unsubscribe& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubscribeCommands_Unsubscribe* internal_default_instance() {
    return reinterpret_cast<const SubscribeCommands_Unsubscribe*>(
               &_SubscribeCommands_Unsubscribe_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(SubscribeCommands_Unsubscribe& a, SubscribeCommands_Unsubscribe& b) {
    a.Swap(&b);
  }
  inline void Swap(SubscribeCommands_Unsubscribe* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscribeCommands_Unsubscribe* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscribeCommands_Unsubscribe* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubscribeCommands_Unsubscribe>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SubscribeCommands_Unsubscribe& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SubscribeCommands_Unsubscribe& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "auth.SubscribeCommands.Unsubscribe";
  }
  protected:
  explicit SubscribeCommands_Unsubscribe(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:auth.SubscribeCommands.Unsubscribe)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_lc_5fkasse_5fauth_2fauth_2eproto;
};
// -------------------------------------------------------------------

class SubscribeCommands final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:auth.SubscribeCommands) */ {
 public:
  inline SubscribeCommands() : SubscribeCommands(nullptr) {}
  ~SubscribeCommands() override;
  explicit PROTOBUF_CONSTEXPR SubscribeCommands(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubscribeCommands(const SubscribeCommands& from);
  SubscribeCommands(SubscribeCommands&& from) noexcept
    : SubscribeCommands() {
    *this = ::std::move(from);
  }

  inline SubscribeCommands& operator=(const SubscribeCommands& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribeCommands& operator=(SubscribeCommands&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscribeCommands& default_instance() {
    return *internal_default_instance();
  }
  enum EventCase {
    kSubscribe = 1,
    kUnsubscribe = 2,
    EVENT_NOT_SET = 0,
  };

  static inline const SubscribeCommands* internal_default_instance() {
    return reinterpret_cast<const SubscribeCommands*>(
               &_SubscribeCommands_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(SubscribeCommands& a, SubscribeCommands& b) {
    a.Swap(&b);
  }
  inline void Swap(SubscribeCommands* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscribeCommands* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscribeCommands* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubscribeCommands>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubscribeCommands& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SubscribeCommands& from) {
    SubscribeCommands::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubscribeCommands* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "auth.SubscribeCommands";
  }
  protected:
  explicit SubscribeCommands(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SubscribeCommands_Subscribe Subscribe;
  typedef SubscribeCommands_Unsubscribe Unsubscribe;

  // accessors -------------------------------------------------------

  enum : int {
    kSubscribeFieldNumber = 1,
    kUnsubscribeFieldNumber = 2,
  };
  // .auth.SubscribeCommands.Subscribe subscribe = 1;
  bool has_subscribe() const;
  private:
  bool _internal_has_subscribe() const;
  public:
  void clear_subscribe();
  const ::auth::SubscribeCommands_Subscribe& subscribe() const;
  PROTOBUF_NODISCARD ::auth::SubscribeCommands_Subscribe* release_subscribe();
  ::auth::SubscribeCommands_Subscribe* mutable_subscribe();
  void set_allocated_subscribe(::auth::SubscribeCommands_Subscribe* subscribe);
  private:
  const ::auth::SubscribeCommands_Subscribe& _internal_subscribe() const;
  ::auth::SubscribeCommands_Subscribe* _internal_mutable_subscribe();
  public:
  void unsafe_arena_set_allocated_subscribe(
      ::auth::SubscribeCommands_Subscribe* subscribe);
  ::auth::SubscribeCommands_Subscribe* unsafe_arena_release_subscribe();

  // .auth.SubscribeCommands.Unsubscribe unsubscribe = 2;
  bool has_unsubscribe() const;
  private:
  bool _internal_has_unsubscribe() const;
  public:
  void clear_unsubscribe();
  const ::auth::SubscribeCommands_Unsubscribe& unsubscribe() const;
  PROTOBUF_NODISCARD ::auth::SubscribeCommands_Unsubscribe* release_unsubscribe();
  ::auth::SubscribeCommands_Unsubscribe* mutable_unsubscribe();
  void set_allocated_unsubscribe(::auth::SubscribeCommands_Unsubscribe* unsubscribe);
  private:
  const ::auth::SubscribeCommands_Unsubscribe& _internal_unsubscribe() const;
  ::auth::SubscribeCommands_Unsubscribe* _internal_mutable_unsubscribe();
  public:
  void unsafe_arena_set_allocated_unsubscribe(
      ::auth::SubscribeCommands_Unsubscribe* unsubscribe);
  ::auth::SubscribeCommands_Unsubscribe* unsafe_arena_release_unsubscribe();

  void clear_event();
  EventCase event_case() const;
  // @@protoc_insertion_point(class_scope:auth.SubscribeCommands)
 private:
  class _Internal;
  void set_has_subscribe();
  void set_has_unsubscribe();

  inline bool has_event() const;
  inline void clear_has_event();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union EventUnion {
      constexpr EventUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::auth::SubscribeCommands_Subscribe* subscribe_;
      ::auth::SubscribeCommands_Unsubscribe* unsubscribe_;
    } event_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lc_5fkasse_5fauth_2fauth_2eproto;
};
// -------------------------------------------------------------------

class Events_Event final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:auth.Events.Event) */ {
 public:
  inline Events_Event() : Events_Event(nullptr) {}
  ~Events_Event() override;
  explicit PROTOBUF_CONSTEXPR Events_Event(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Events_Event(const Events_Event& from);
  Events_Event(Events_Event&& from) noexcept
    : Events_Event() {
    *this = ::std::move(from);
  }

  inline Events_Event& operator=(const Events_Event& from) {
    CopyFrom(from);
    return *this;
  }
  inline Events_Event& operator=(Events_Event&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Events_Event& default_instance() {
    return *internal_default_instance();
  }
  static inline const Events_Event* internal_default_instance() {
    return reinterpret_cast<const Events_Event*>(
               &_Events_Event_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(Events_Event& a, Events_Event& b) {
    a.Swap(&b);
  }
  inline void Swap(Events_Event* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Events_Event* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Events_Event* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Events_Event>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Events_Event& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Events_Event& from) {
    Events_Event::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Events_Event* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "auth.Events.Event";
  }
  protected:
  explicit Events_Event(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdsFieldNumber = 2,
    kEtypeFieldNumber = 1,
  };
  // repeated uint64 ids = 2;
  int ids_size() const;
  private:
  int _internal_ids_size() const;
  public:
  void clear_ids();
  private:
  uint64_t _internal_ids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_ids() const;
  void _internal_add_ids(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_ids();
  public:
  uint64_t ids(int index) const;
  void set_ids(int index, uint64_t value);
  void add_ids(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_ids();

  // .auth.EventType etype = 1;
  void clear_etype();
  ::auth::EventType etype() const;
  void set_etype(::auth::EventType value);
  private:
  ::auth::EventType _internal_etype() const;
  void _internal_set_etype(::auth::EventType value);
  public:

  // @@protoc_insertion_point(class_scope:auth.Events.Event)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > ids_;
    mutable std::atomic<int> _ids_cached_byte_size_;
    int etype_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lc_5fkasse_5fauth_2fauth_2eproto;
};
// -------------------------------------------------------------------

class Events final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:auth.Events) */ {
 public:
  inline Events() : Events(nullptr) {}
  ~Events() override;
  explicit PROTOBUF_CONSTEXPR Events(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Events(const Events& from);
  Events(Events&& from) noexcept
    : Events() {
    *this = ::std::move(from);
  }

  inline Events& operator=(const Events& from) {
    CopyFrom(from);
    return *this;
  }
  inline Events& operator=(Events&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Events& default_instance() {
    return *internal_default_instance();
  }
  static inline const Events* internal_default_instance() {
    return reinterpret_cast<const Events*>(
               &_Events_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(Events& a, Events& b) {
    a.Swap(&b);
  }
  inline void Swap(Events* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Events* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Events* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Events>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Events& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Events& from) {
    Events::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Events* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "auth.Events";
  }
  protected:
  explicit Events(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Events_Event Event;

  // accessors -------------------------------------------------------

  enum : int {
    kEventsFieldNumber = 2,
    kAuthorFieldNumber = 1,
  };
  // repeated .auth.Events.Event events = 2;
  int events_size() const;
  private:
  int _internal_events_size() const;
  public:
  void clear_events();
  ::auth::Events_Event* mutable_events(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::auth::Events_Event >*
      mutable_events();
  private:
  const ::auth::Events_Event& _internal_events(int index) const;
  ::auth::Events_Event* _internal_add_events();
  public:
  const ::auth::Events_Event& events(int index) const;
  ::auth::Events_Event* add_events();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::auth::Events_Event >&
      events() const;

  // string author = 1;
  void clear_author();
  const std::string& author() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_author(ArgT0&& arg0, ArgT... args);
  std::string* mutable_author();
  PROTOBUF_NODISCARD std::string* release_author();
  void set_allocated_author(std::string* author);
  private:
  const std::string& _internal_author() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_author(const std::string& value);
  std::string* _internal_mutable_author();
  public:

  // @@protoc_insertion_point(class_scope:auth.Events)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::auth::Events_Event > events_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr author_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lc_5fkasse_5fauth_2fauth_2eproto;
};
// -------------------------------------------------------------------

class User final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:auth.User) */ {
 public:
  inline User() : User(nullptr) {}
  ~User() override;
  explicit PROTOBUF_CONSTEXPR User(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  User(const User& from);
  User(User&& from) noexcept
    : User() {
    *this = ::std::move(from);
  }

  inline User& operator=(const User& from) {
    CopyFrom(from);
    return *this;
  }
  inline User& operator=(User&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const User& default_instance() {
    return *internal_default_instance();
  }
  static inline const User* internal_default_instance() {
    return reinterpret_cast<const User*>(
               &_User_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(User& a, User& b) {
    a.Swap(&b);
  }
  inline void Swap(User* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(User* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  User* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<User>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const User& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const User& from) {
    User::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(User* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "auth.User";
  }
  protected:
  explicit User(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLoginFieldNumber = 2,
    kPassFieldNumber = 3,
    kIdFieldNumber = 1,
    kGroupidFieldNumber = 4,
    kSessionidFieldNumber = 5,
  };
  // string login = 2;
  void clear_login();
  const std::string& login() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_login(ArgT0&& arg0, ArgT... args);
  std::string* mutable_login();
  PROTOBUF_NODISCARD std::string* release_login();
  void set_allocated_login(std::string* login);
  private:
  const std::string& _internal_login() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_login(const std::string& value);
  std::string* _internal_mutable_login();
  public:

  // string pass = 3;
  void clear_pass();
  const std::string& pass() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pass(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pass();
  PROTOBUF_NODISCARD std::string* release_pass();
  void set_allocated_pass(std::string* pass);
  private:
  const std::string& _internal_pass() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pass(const std::string& value);
  std::string* _internal_mutable_pass();
  public:

  // uint64 id = 1;
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // uint64 groupid = 4;
  void clear_groupid();
  uint64_t groupid() const;
  void set_groupid(uint64_t value);
  private:
  uint64_t _internal_groupid() const;
  void _internal_set_groupid(uint64_t value);
  public:

  // uint64 sessionid = 5;
  void clear_sessionid();
  uint64_t sessionid() const;
  void set_sessionid(uint64_t value);
  private:
  uint64_t _internal_sessionid() const;
  void _internal_set_sessionid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:auth.User)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr login_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pass_;
    uint64_t id_;
    uint64_t groupid_;
    uint64_t sessionid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lc_5fkasse_5fauth_2fauth_2eproto;
};
// -------------------------------------------------------------------

class Credentials final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:auth.Credentials) */ {
 public:
  inline Credentials() : Credentials(nullptr) {}
  ~Credentials() override;
  explicit PROTOBUF_CONSTEXPR Credentials(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Credentials(const Credentials& from);
  Credentials(Credentials&& from) noexcept
    : Credentials() {
    *this = ::std::move(from);
  }

  inline Credentials& operator=(const Credentials& from) {
    CopyFrom(from);
    return *this;
  }
  inline Credentials& operator=(Credentials&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Credentials& default_instance() {
    return *internal_default_instance();
  }
  static inline const Credentials* internal_default_instance() {
    return reinterpret_cast<const Credentials*>(
               &_Credentials_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  friend void swap(Credentials& a, Credentials& b) {
    a.Swap(&b);
  }
  inline void Swap(Credentials* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Credentials* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Credentials* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Credentials>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Credentials& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Credentials& from) {
    Credentials::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Credentials* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "auth.Credentials";
  }
  protected:
  explicit Credentials(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLoginFieldNumber = 1,
    kPassFieldNumber = 2,
    kTerminalNumberFieldNumber = 3,
  };
  // string login = 1;
  void clear_login();
  const std::string& login() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_login(ArgT0&& arg0, ArgT... args);
  std::string* mutable_login();
  PROTOBUF_NODISCARD std::string* release_login();
  void set_allocated_login(std::string* login);
  private:
  const std::string& _internal_login() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_login(const std::string& value);
  std::string* _internal_mutable_login();
  public:

  // string pass = 2;
  void clear_pass();
  const std::string& pass() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pass(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pass();
  PROTOBUF_NODISCARD std::string* release_pass();
  void set_allocated_pass(std::string* pass);
  private:
  const std::string& _internal_pass() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pass(const std::string& value);
  std::string* _internal_mutable_pass();
  public:

  // string terminalNumber = 3;
  void clear_terminalnumber();
  const std::string& terminalnumber() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_terminalnumber(ArgT0&& arg0, ArgT... args);
  std::string* mutable_terminalnumber();
  PROTOBUF_NODISCARD std::string* release_terminalnumber();
  void set_allocated_terminalnumber(std::string* terminalnumber);
  private:
  const std::string& _internal_terminalnumber() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_terminalnumber(const std::string& value);
  std::string* _internal_mutable_terminalnumber();
  public:

  // @@protoc_insertion_point(class_scope:auth.Credentials)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr login_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pass_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr terminalnumber_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lc_5fkasse_5fauth_2fauth_2eproto;
};
// -------------------------------------------------------------------

class LoginRequest_Logout final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:auth.LoginRequest.Logout) */ {
 public:
  inline LoginRequest_Logout() : LoginRequest_Logout(nullptr) {}
  explicit PROTOBUF_CONSTEXPR LoginRequest_Logout(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginRequest_Logout(const LoginRequest_Logout& from);
  LoginRequest_Logout(LoginRequest_Logout&& from) noexcept
    : LoginRequest_Logout() {
    *this = ::std::move(from);
  }

  inline LoginRequest_Logout& operator=(const LoginRequest_Logout& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginRequest_Logout& operator=(LoginRequest_Logout&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginRequest_Logout& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginRequest_Logout* internal_default_instance() {
    return reinterpret_cast<const LoginRequest_Logout*>(
               &_LoginRequest_Logout_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  friend void swap(LoginRequest_Logout& a, LoginRequest_Logout& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginRequest_Logout* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginRequest_Logout* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginRequest_Logout* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginRequest_Logout>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const LoginRequest_Logout& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const LoginRequest_Logout& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "auth.LoginRequest.Logout";
  }
  protected:
  explicit LoginRequest_Logout(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:auth.LoginRequest.Logout)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_lc_5fkasse_5fauth_2fauth_2eproto;
};
// -------------------------------------------------------------------

class LoginRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:auth.LoginRequest) */ {
 public:
  inline LoginRequest() : LoginRequest(nullptr) {}
  ~LoginRequest() override;
  explicit PROTOBUF_CONSTEXPR LoginRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginRequest(const LoginRequest& from);
  LoginRequest(LoginRequest&& from) noexcept
    : LoginRequest() {
    *this = ::std::move(from);
  }

  inline LoginRequest& operator=(const LoginRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginRequest& operator=(LoginRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginRequest& default_instance() {
    return *internal_default_instance();
  }
  enum ReqCase {
    kCredentials = 1,
    kLogout = 2,
    REQ_NOT_SET = 0,
  };

  static inline const LoginRequest* internal_default_instance() {
    return reinterpret_cast<const LoginRequest*>(
               &_LoginRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  friend void swap(LoginRequest& a, LoginRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoginRequest& from) {
    LoginRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "auth.LoginRequest";
  }
  protected:
  explicit LoginRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef LoginRequest_Logout Logout;

  // accessors -------------------------------------------------------

  enum : int {
    kCredentialsFieldNumber = 1,
    kLogoutFieldNumber = 2,
  };
  // .auth.Credentials credentials = 1;
  bool has_credentials() const;
  private:
  bool _internal_has_credentials() const;
  public:
  void clear_credentials();
  const ::auth::Credentials& credentials() const;
  PROTOBUF_NODISCARD ::auth::Credentials* release_credentials();
  ::auth::Credentials* mutable_credentials();
  void set_allocated_credentials(::auth::Credentials* credentials);
  private:
  const ::auth::Credentials& _internal_credentials() const;
  ::auth::Credentials* _internal_mutable_credentials();
  public:
  void unsafe_arena_set_allocated_credentials(
      ::auth::Credentials* credentials);
  ::auth::Credentials* unsafe_arena_release_credentials();

  // .auth.LoginRequest.Logout logout = 2;
  bool has_logout() const;
  private:
  bool _internal_has_logout() const;
  public:
  void clear_logout();
  const ::auth::LoginRequest_Logout& logout() const;
  PROTOBUF_NODISCARD ::auth::LoginRequest_Logout* release_logout();
  ::auth::LoginRequest_Logout* mutable_logout();
  void set_allocated_logout(::auth::LoginRequest_Logout* logout);
  private:
  const ::auth::LoginRequest_Logout& _internal_logout() const;
  ::auth::LoginRequest_Logout* _internal_mutable_logout();
  public:
  void unsafe_arena_set_allocated_logout(
      ::auth::LoginRequest_Logout* logout);
  ::auth::LoginRequest_Logout* unsafe_arena_release_logout();

  void clear_req();
  ReqCase req_case() const;
  // @@protoc_insertion_point(class_scope:auth.LoginRequest)
 private:
  class _Internal;
  void set_has_credentials();
  void set_has_logout();

  inline bool has_req() const;
  inline void clear_has_req();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ReqUnion {
      constexpr ReqUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::auth::Credentials* credentials_;
      ::auth::LoginRequest_Logout* logout_;
    } req_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lc_5fkasse_5fauth_2fauth_2eproto;
};
// -------------------------------------------------------------------

class LoginResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:auth.LoginResponse) */ {
 public:
  inline LoginResponse() : LoginResponse(nullptr) {}
  ~LoginResponse() override;
  explicit PROTOBUF_CONSTEXPR LoginResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginResponse(const LoginResponse& from);
  LoginResponse(LoginResponse&& from) noexcept
    : LoginResponse() {
    *this = ::std::move(from);
  }

  inline LoginResponse& operator=(const LoginResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginResponse& operator=(LoginResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginResponse& default_instance() {
    return *internal_default_instance();
  }
  enum ResCase {
    kToken = 1,
    kError = 2,
    RES_NOT_SET = 0,
  };

  static inline const LoginResponse* internal_default_instance() {
    return reinterpret_cast<const LoginResponse*>(
               &_LoginResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  friend void swap(LoginResponse& a, LoginResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoginResponse& from) {
    LoginResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "auth.LoginResponse";
  }
  protected:
  explicit LoginResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenFieldNumber = 1,
    kErrorFieldNumber = 2,
  };
  // .auth.Token token = 1;
  bool has_token() const;
  private:
  bool _internal_has_token() const;
  public:
  void clear_token();
  const ::auth::Token& token() const;
  PROTOBUF_NODISCARD ::auth::Token* release_token();
  ::auth::Token* mutable_token();
  void set_allocated_token(::auth::Token* token);
  private:
  const ::auth::Token& _internal_token() const;
  ::auth::Token* _internal_mutable_token();
  public:
  void unsafe_arena_set_allocated_token(
      ::auth::Token* token);
  ::auth::Token* unsafe_arena_release_token();

  // .auth.Error error = 2;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::auth::Error& error() const;
  PROTOBUF_NODISCARD ::auth::Error* release_error();
  ::auth::Error* mutable_error();
  void set_allocated_error(::auth::Error* error);
  private:
  const ::auth::Error& _internal_error() const;
  ::auth::Error* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::auth::Error* error);
  ::auth::Error* unsafe_arena_release_error();

  void clear_res();
  ResCase res_case() const;
  // @@protoc_insertion_point(class_scope:auth.LoginResponse)
 private:
  class _Internal;
  void set_has_token();
  void set_has_error();

  inline bool has_res() const;
  inline void clear_has_res();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ResUnion {
      constexpr ResUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::auth::Token* token_;
      ::auth::Error* error_;
    } res_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lc_5fkasse_5fauth_2fauth_2eproto;
};
// -------------------------------------------------------------------

class Token final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:auth.Token) */ {
 public:
  inline Token() : Token(nullptr) {}
  ~Token() override;
  explicit PROTOBUF_CONSTEXPR Token(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Token(const Token& from);
  Token(Token&& from) noexcept
    : Token() {
    *this = ::std::move(from);
  }

  inline Token& operator=(const Token& from) {
    CopyFrom(from);
    return *this;
  }
  inline Token& operator=(Token&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Token& default_instance() {
    return *internal_default_instance();
  }
  static inline const Token* internal_default_instance() {
    return reinterpret_cast<const Token*>(
               &_Token_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  friend void swap(Token& a, Token& b) {
    a.Swap(&b);
  }
  inline void Swap(Token* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Token* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Token* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Token>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Token& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Token& from) {
    Token::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Token* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "auth.Token";
  }
  protected:
  explicit Token(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // bytes data = 1;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // @@protoc_insertion_point(class_scope:auth.Token)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lc_5fkasse_5fauth_2fauth_2eproto;
};
// -------------------------------------------------------------------

class Error final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:auth.Error) */ {
 public:
  inline Error() : Error(nullptr) {}
  ~Error() override;
  explicit PROTOBUF_CONSTEXPR Error(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Error(const Error& from);
  Error(Error&& from) noexcept
    : Error() {
    *this = ::std::move(from);
  }

  inline Error& operator=(const Error& from) {
    CopyFrom(from);
    return *this;
  }
  inline Error& operator=(Error&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Error& default_instance() {
    return *internal_default_instance();
  }
  static inline const Error* internal_default_instance() {
    return reinterpret_cast<const Error*>(
               &_Error_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    53;

  friend void swap(Error& a, Error& b) {
    a.Swap(&b);
  }
  inline void Swap(Error* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Error* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Error* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Error>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Error& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Error& from) {
    Error::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Error* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "auth.Error";
  }
  protected:
  explicit Error(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 1,
  };
  // string message = 1;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // @@protoc_insertion_point(class_scope:auth.Error)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lc_5fkasse_5fauth_2fauth_2eproto;
};
// -------------------------------------------------------------------

class Terminal final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:auth.Terminal) */ {
 public:
  inline Terminal() : Terminal(nullptr) {}
  ~Terminal() override;
  explicit PROTOBUF_CONSTEXPR Terminal(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Terminal(const Terminal& from);
  Terminal(Terminal&& from) noexcept
    : Terminal() {
    *this = ::std::move(from);
  }

  inline Terminal& operator=(const Terminal& from) {
    CopyFrom(from);
    return *this;
  }
  inline Terminal& operator=(Terminal&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Terminal& default_instance() {
    return *internal_default_instance();
  }
  static inline const Terminal* internal_default_instance() {
    return reinterpret_cast<const Terminal*>(
               &_Terminal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    54;

  friend void swap(Terminal& a, Terminal& b) {
    a.Swap(&b);
  }
  inline void Swap(Terminal* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Terminal* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Terminal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Terminal>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Terminal& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Terminal& from) {
    Terminal::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Terminal* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "auth.Terminal";
  }
  protected:
  explicit Terminal(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNumberFieldNumber = 2,
    kIdentificatorFieldNumber = 3,
    kDescriptionFieldNumber = 4,
    kNumberHashFieldNumber = 6,
    kIdFieldNumber = 1,
    kSessionidFieldNumber = 5,
  };
  // string number = 2;
  void clear_number();
  const std::string& number() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_number(ArgT0&& arg0, ArgT... args);
  std::string* mutable_number();
  PROTOBUF_NODISCARD std::string* release_number();
  void set_allocated_number(std::string* number);
  private:
  const std::string& _internal_number() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_number(const std::string& value);
  std::string* _internal_mutable_number();
  public:

  // string identificator = 3;
  void clear_identificator();
  const std::string& identificator() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_identificator(ArgT0&& arg0, ArgT... args);
  std::string* mutable_identificator();
  PROTOBUF_NODISCARD std::string* release_identificator();
  void set_allocated_identificator(std::string* identificator);
  private:
  const std::string& _internal_identificator() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_identificator(const std::string& value);
  std::string* _internal_mutable_identificator();
  public:

  // string description = 4;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // string number_hash = 6;
  void clear_number_hash();
  const std::string& number_hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_number_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_number_hash();
  PROTOBUF_NODISCARD std::string* release_number_hash();
  void set_allocated_number_hash(std::string* number_hash);
  private:
  const std::string& _internal_number_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_number_hash(const std::string& value);
  std::string* _internal_mutable_number_hash();
  public:

  // uint64 id = 1;
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // uint64 sessionid = 5;
  void clear_sessionid();
  uint64_t sessionid() const;
  void set_sessionid(uint64_t value);
  private:
  uint64_t _internal_sessionid() const;
  void _internal_set_sessionid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:auth.Terminal)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr number_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr identificator_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr number_hash_;
    uint64_t id_;
    uint64_t sessionid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lc_5fkasse_5fauth_2fauth_2eproto;
};
// -------------------------------------------------------------------

class UserGroup final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:auth.UserGroup) */ {
 public:
  inline UserGroup() : UserGroup(nullptr) {}
  ~UserGroup() override;
  explicit PROTOBUF_CONSTEXPR UserGroup(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserGroup(const UserGroup& from);
  UserGroup(UserGroup&& from) noexcept
    : UserGroup() {
    *this = ::std::move(from);
  }

  inline UserGroup& operator=(const UserGroup& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserGroup& operator=(UserGroup&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserGroup& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserGroup* internal_default_instance() {
    return reinterpret_cast<const UserGroup*>(
               &_UserGroup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    55;

  friend void swap(UserGroup& a, UserGroup& b) {
    a.Swap(&b);
  }
  inline void Swap(UserGroup* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserGroup* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserGroup* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserGroup>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserGroup& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UserGroup& from) {
    UserGroup::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserGroup* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "auth.UserGroup";
  }
  protected:
  explicit UserGroup(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kDescriptionFieldNumber = 3,
    kIdFieldNumber = 1,
    kSessionidFieldNumber = 5,
    kSuperFieldNumber = 4,
  };
  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string description = 3;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // uint64 id = 1;
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // uint64 sessionid = 5;
  void clear_sessionid();
  uint64_t sessionid() const;
  void set_sessionid(uint64_t value);
  private:
  uint64_t _internal_sessionid() const;
  void _internal_set_sessionid(uint64_t value);
  public:

  // bool super = 4;
  void clear_super();
  bool super() const;
  void set_super(bool value);
  private:
  bool _internal_super() const;
  void _internal_set_super(bool value);
  public:

  // @@protoc_insertion_point(class_scope:auth.UserGroup)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    uint64_t id_;
    uint64_t sessionid_;
    bool super_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lc_5fkasse_5fauth_2fauth_2eproto;
};
// -------------------------------------------------------------------

class Session final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:auth.Session) */ {
 public:
  inline Session() : Session(nullptr) {}
  ~Session() override;
  explicit PROTOBUF_CONSTEXPR Session(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Session(const Session& from);
  Session(Session&& from) noexcept
    : Session() {
    *this = ::std::move(from);
  }

  inline Session& operator=(const Session& from) {
    CopyFrom(from);
    return *this;
  }
  inline Session& operator=(Session&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Session& default_instance() {
    return *internal_default_instance();
  }
  static inline const Session* internal_default_instance() {
    return reinterpret_cast<const Session*>(
               &_Session_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    56;

  friend void swap(Session& a, Session& b) {
    a.Swap(&b);
  }
  inline void Swap(Session* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Session* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Session* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Session>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Session& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Session& from) {
    Session::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Session* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "auth.Session";
  }
  protected:
  explicit Session(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVersionFieldNumber = 9,
    kStartatFieldNumber = 6,
    kEndatFieldNumber = 7,
    kIdFieldNumber = 1,
    kUseridFieldNumber = 2,
    kEmployeidFieldNumber = 3,
    kTerminalidFieldNumber = 4,
    kBranchidFieldNumber = 5,
    kCrashFieldNumber = 8,
  };
  // string version = 9;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // .google.protobuf.Timestamp startat = 6;
  bool has_startat() const;
  private:
  bool _internal_has_startat() const;
  public:
  void clear_startat();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& startat() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_startat();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_startat();
  void set_allocated_startat(::PROTOBUF_NAMESPACE_ID::Timestamp* startat);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_startat() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_startat();
  public:
  void unsafe_arena_set_allocated_startat(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* startat);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_startat();

  // .google.protobuf.Timestamp endat = 7;
  bool has_endat() const;
  private:
  bool _internal_has_endat() const;
  public:
  void clear_endat();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& endat() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_endat();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_endat();
  void set_allocated_endat(::PROTOBUF_NAMESPACE_ID::Timestamp* endat);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_endat() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_endat();
  public:
  void unsafe_arena_set_allocated_endat(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* endat);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_endat();

  // uint64 id = 1;
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // uint64 userid = 2;
  void clear_userid();
  uint64_t userid() const;
  void set_userid(uint64_t value);
  private:
  uint64_t _internal_userid() const;
  void _internal_set_userid(uint64_t value);
  public:

  // uint64 employeid = 3;
  void clear_employeid();
  uint64_t employeid() const;
  void set_employeid(uint64_t value);
  private:
  uint64_t _internal_employeid() const;
  void _internal_set_employeid(uint64_t value);
  public:

  // uint64 terminalid = 4;
  void clear_terminalid();
  uint64_t terminalid() const;
  void set_terminalid(uint64_t value);
  private:
  uint64_t _internal_terminalid() const;
  void _internal_set_terminalid(uint64_t value);
  public:

  // uint64 branchid = 5;
  void clear_branchid();
  uint64_t branchid() const;
  void set_branchid(uint64_t value);
  private:
  uint64_t _internal_branchid() const;
  void _internal_set_branchid(uint64_t value);
  public:

  // bool crash = 8;
  void clear_crash();
  bool crash() const;
  void set_crash(bool value);
  private:
  bool _internal_crash() const;
  void _internal_set_crash(bool value);
  public:

  // @@protoc_insertion_point(class_scope:auth.Session)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* startat_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* endat_;
    uint64_t id_;
    uint64_t userid_;
    uint64_t employeid_;
    uint64_t terminalid_;
    uint64_t branchid_;
    bool crash_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lc_5fkasse_5fauth_2fauth_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Empty

// -------------------------------------------------------------------

// Terminals

// repeated .auth.Terminal terminals = 1;
inline int Terminals::_internal_terminals_size() const {
  return _impl_.terminals_.size();
}
inline int Terminals::terminals_size() const {
  return _internal_terminals_size();
}
inline void Terminals::clear_terminals() {
  _impl_.terminals_.Clear();
}
inline ::auth::Terminal* Terminals::mutable_terminals(int index) {
  // @@protoc_insertion_point(field_mutable:auth.Terminals.terminals)
  return _impl_.terminals_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::auth::Terminal >*
Terminals::mutable_terminals() {
  // @@protoc_insertion_point(field_mutable_list:auth.Terminals.terminals)
  return &_impl_.terminals_;
}
inline const ::auth::Terminal& Terminals::_internal_terminals(int index) const {
  return _impl_.terminals_.Get(index);
}
inline const ::auth::Terminal& Terminals::terminals(int index) const {
  // @@protoc_insertion_point(field_get:auth.Terminals.terminals)
  return _internal_terminals(index);
}
inline ::auth::Terminal* Terminals::_internal_add_terminals() {
  return _impl_.terminals_.Add();
}
inline ::auth::Terminal* Terminals::add_terminals() {
  ::auth::Terminal* _add = _internal_add_terminals();
  // @@protoc_insertion_point(field_add:auth.Terminals.terminals)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::auth::Terminal >&
Terminals::terminals() const {
  // @@protoc_insertion_point(field_list:auth.Terminals.terminals)
  return _impl_.terminals_;
}

// -------------------------------------------------------------------

// PaginationRequest

// uint64 items = 1;
inline void PaginationRequest::clear_items() {
  _impl_.items_ = uint64_t{0u};
}
inline uint64_t PaginationRequest::_internal_items() const {
  return _impl_.items_;
}
inline uint64_t PaginationRequest::items() const {
  // @@protoc_insertion_point(field_get:auth.PaginationRequest.items)
  return _internal_items();
}
inline void PaginationRequest::_internal_set_items(uint64_t value) {
  
  _impl_.items_ = value;
}
inline void PaginationRequest::set_items(uint64_t value) {
  _internal_set_items(value);
  // @@protoc_insertion_point(field_set:auth.PaginationRequest.items)
}

// uint64 page = 2;
inline void PaginationRequest::clear_page() {
  _impl_.page_ = uint64_t{0u};
}
inline uint64_t PaginationRequest::_internal_page() const {
  return _impl_.page_;
}
inline uint64_t PaginationRequest::page() const {
  // @@protoc_insertion_point(field_get:auth.PaginationRequest.page)
  return _internal_page();
}
inline void PaginationRequest::_internal_set_page(uint64_t value) {
  
  _impl_.page_ = value;
}
inline void PaginationRequest::set_page(uint64_t value) {
  _internal_set_page(value);
  // @@protoc_insertion_point(field_set:auth.PaginationRequest.page)
}

// uint64 startfromID = 3;
inline void PaginationRequest::clear_startfromid() {
  _impl_.startfromid_ = uint64_t{0u};
}
inline uint64_t PaginationRequest::_internal_startfromid() const {
  return _impl_.startfromid_;
}
inline uint64_t PaginationRequest::startfromid() const {
  // @@protoc_insertion_point(field_get:auth.PaginationRequest.startfromID)
  return _internal_startfromid();
}
inline void PaginationRequest::_internal_set_startfromid(uint64_t value) {
  
  _impl_.startfromid_ = value;
}
inline void PaginationRequest::set_startfromid(uint64_t value) {
  _internal_set_startfromid(value);
  // @@protoc_insertion_point(field_set:auth.PaginationRequest.startfromID)
}

// -------------------------------------------------------------------

// PaginationResponse

// uint64 page = 1;
inline void PaginationResponse::clear_page() {
  _impl_.page_ = uint64_t{0u};
}
inline uint64_t PaginationResponse::_internal_page() const {
  return _impl_.page_;
}
inline uint64_t PaginationResponse::page() const {
  // @@protoc_insertion_point(field_get:auth.PaginationResponse.page)
  return _internal_page();
}
inline void PaginationResponse::_internal_set_page(uint64_t value) {
  
  _impl_.page_ = value;
}
inline void PaginationResponse::set_page(uint64_t value) {
  _internal_set_page(value);
  // @@protoc_insertion_point(field_set:auth.PaginationResponse.page)
}

// uint64 pages = 2;
inline void PaginationResponse::clear_pages() {
  _impl_.pages_ = uint64_t{0u};
}
inline uint64_t PaginationResponse::_internal_pages() const {
  return _impl_.pages_;
}
inline uint64_t PaginationResponse::pages() const {
  // @@protoc_insertion_point(field_get:auth.PaginationResponse.pages)
  return _internal_pages();
}
inline void PaginationResponse::_internal_set_pages(uint64_t value) {
  
  _impl_.pages_ = value;
}
inline void PaginationResponse::set_pages(uint64_t value) {
  _internal_set_pages(value);
  // @@protoc_insertion_point(field_set:auth.PaginationResponse.pages)
}

// -------------------------------------------------------------------

// GetUsersByGroupReq

// uint64 groupid = 1;
inline void GetUsersByGroupReq::clear_groupid() {
  _impl_.groupid_ = uint64_t{0u};
}
inline uint64_t GetUsersByGroupReq::_internal_groupid() const {
  return _impl_.groupid_;
}
inline uint64_t GetUsersByGroupReq::groupid() const {
  // @@protoc_insertion_point(field_get:auth.GetUsersByGroupReq.groupid)
  return _internal_groupid();
}
inline void GetUsersByGroupReq::_internal_set_groupid(uint64_t value) {
  
  _impl_.groupid_ = value;
}
inline void GetUsersByGroupReq::set_groupid(uint64_t value) {
  _internal_set_groupid(value);
  // @@protoc_insertion_point(field_set:auth.GetUsersByGroupReq.groupid)
}

// .auth.PaginationRequest paginationreq = 2;
inline bool GetUsersByGroupReq::_internal_has_paginationreq() const {
  return this != internal_default_instance() && _impl_.paginationreq_ != nullptr;
}
inline bool GetUsersByGroupReq::has_paginationreq() const {
  return _internal_has_paginationreq();
}
inline void GetUsersByGroupReq::clear_paginationreq() {
  if (GetArenaForAllocation() == nullptr && _impl_.paginationreq_ != nullptr) {
    delete _impl_.paginationreq_;
  }
  _impl_.paginationreq_ = nullptr;
}
inline const ::auth::PaginationRequest& GetUsersByGroupReq::_internal_paginationreq() const {
  const ::auth::PaginationRequest* p = _impl_.paginationreq_;
  return p != nullptr ? *p : reinterpret_cast<const ::auth::PaginationRequest&>(
      ::auth::_PaginationRequest_default_instance_);
}
inline const ::auth::PaginationRequest& GetUsersByGroupReq::paginationreq() const {
  // @@protoc_insertion_point(field_get:auth.GetUsersByGroupReq.paginationreq)
  return _internal_paginationreq();
}
inline void GetUsersByGroupReq::unsafe_arena_set_allocated_paginationreq(
    ::auth::PaginationRequest* paginationreq) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.paginationreq_);
  }
  _impl_.paginationreq_ = paginationreq;
  if (paginationreq) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:auth.GetUsersByGroupReq.paginationreq)
}
inline ::auth::PaginationRequest* GetUsersByGroupReq::release_paginationreq() {
  
  ::auth::PaginationRequest* temp = _impl_.paginationreq_;
  _impl_.paginationreq_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::auth::PaginationRequest* GetUsersByGroupReq::unsafe_arena_release_paginationreq() {
  // @@protoc_insertion_point(field_release:auth.GetUsersByGroupReq.paginationreq)
  
  ::auth::PaginationRequest* temp = _impl_.paginationreq_;
  _impl_.paginationreq_ = nullptr;
  return temp;
}
inline ::auth::PaginationRequest* GetUsersByGroupReq::_internal_mutable_paginationreq() {
  
  if (_impl_.paginationreq_ == nullptr) {
    auto* p = CreateMaybeMessage<::auth::PaginationRequest>(GetArenaForAllocation());
    _impl_.paginationreq_ = p;
  }
  return _impl_.paginationreq_;
}
inline ::auth::PaginationRequest* GetUsersByGroupReq::mutable_paginationreq() {
  ::auth::PaginationRequest* _msg = _internal_mutable_paginationreq();
  // @@protoc_insertion_point(field_mutable:auth.GetUsersByGroupReq.paginationreq)
  return _msg;
}
inline void GetUsersByGroupReq::set_allocated_paginationreq(::auth::PaginationRequest* paginationreq) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.paginationreq_;
  }
  if (paginationreq) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(paginationreq);
    if (message_arena != submessage_arena) {
      paginationreq = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, paginationreq, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.paginationreq_ = paginationreq;
  // @@protoc_insertion_point(field_set_allocated:auth.GetUsersByGroupReq.paginationreq)
}

// -------------------------------------------------------------------

// GetUsersByGroupResp

// repeated .auth.User users = 1;
inline int GetUsersByGroupResp::_internal_users_size() const {
  return _impl_.users_.size();
}
inline int GetUsersByGroupResp::users_size() const {
  return _internal_users_size();
}
inline void GetUsersByGroupResp::clear_users() {
  _impl_.users_.Clear();
}
inline ::auth::User* GetUsersByGroupResp::mutable_users(int index) {
  // @@protoc_insertion_point(field_mutable:auth.GetUsersByGroupResp.users)
  return _impl_.users_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::auth::User >*
GetUsersByGroupResp::mutable_users() {
  // @@protoc_insertion_point(field_mutable_list:auth.GetUsersByGroupResp.users)
  return &_impl_.users_;
}
inline const ::auth::User& GetUsersByGroupResp::_internal_users(int index) const {
  return _impl_.users_.Get(index);
}
inline const ::auth::User& GetUsersByGroupResp::users(int index) const {
  // @@protoc_insertion_point(field_get:auth.GetUsersByGroupResp.users)
  return _internal_users(index);
}
inline ::auth::User* GetUsersByGroupResp::_internal_add_users() {
  return _impl_.users_.Add();
}
inline ::auth::User* GetUsersByGroupResp::add_users() {
  ::auth::User* _add = _internal_add_users();
  // @@protoc_insertion_point(field_add:auth.GetUsersByGroupResp.users)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::auth::User >&
GetUsersByGroupResp::users() const {
  // @@protoc_insertion_point(field_list:auth.GetUsersByGroupResp.users)
  return _impl_.users_;
}

// .auth.PaginationResponse paginationresp = 2;
inline bool GetUsersByGroupResp::_internal_has_paginationresp() const {
  return this != internal_default_instance() && _impl_.paginationresp_ != nullptr;
}
inline bool GetUsersByGroupResp::has_paginationresp() const {
  return _internal_has_paginationresp();
}
inline void GetUsersByGroupResp::clear_paginationresp() {
  if (GetArenaForAllocation() == nullptr && _impl_.paginationresp_ != nullptr) {
    delete _impl_.paginationresp_;
  }
  _impl_.paginationresp_ = nullptr;
}
inline const ::auth::PaginationResponse& GetUsersByGroupResp::_internal_paginationresp() const {
  const ::auth::PaginationResponse* p = _impl_.paginationresp_;
  return p != nullptr ? *p : reinterpret_cast<const ::auth::PaginationResponse&>(
      ::auth::_PaginationResponse_default_instance_);
}
inline const ::auth::PaginationResponse& GetUsersByGroupResp::paginationresp() const {
  // @@protoc_insertion_point(field_get:auth.GetUsersByGroupResp.paginationresp)
  return _internal_paginationresp();
}
inline void GetUsersByGroupResp::unsafe_arena_set_allocated_paginationresp(
    ::auth::PaginationResponse* paginationresp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.paginationresp_);
  }
  _impl_.paginationresp_ = paginationresp;
  if (paginationresp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:auth.GetUsersByGroupResp.paginationresp)
}
inline ::auth::PaginationResponse* GetUsersByGroupResp::release_paginationresp() {
  
  ::auth::PaginationResponse* temp = _impl_.paginationresp_;
  _impl_.paginationresp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::auth::PaginationResponse* GetUsersByGroupResp::unsafe_arena_release_paginationresp() {
  // @@protoc_insertion_point(field_release:auth.GetUsersByGroupResp.paginationresp)
  
  ::auth::PaginationResponse* temp = _impl_.paginationresp_;
  _impl_.paginationresp_ = nullptr;
  return temp;
}
inline ::auth::PaginationResponse* GetUsersByGroupResp::_internal_mutable_paginationresp() {
  
  if (_impl_.paginationresp_ == nullptr) {
    auto* p = CreateMaybeMessage<::auth::PaginationResponse>(GetArenaForAllocation());
    _impl_.paginationresp_ = p;
  }
  return _impl_.paginationresp_;
}
inline ::auth::PaginationResponse* GetUsersByGroupResp::mutable_paginationresp() {
  ::auth::PaginationResponse* _msg = _internal_mutable_paginationresp();
  // @@protoc_insertion_point(field_mutable:auth.GetUsersByGroupResp.paginationresp)
  return _msg;
}
inline void GetUsersByGroupResp::set_allocated_paginationresp(::auth::PaginationResponse* paginationresp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.paginationresp_;
  }
  if (paginationresp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(paginationresp);
    if (message_arena != submessage_arena) {
      paginationresp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, paginationresp, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.paginationresp_ = paginationresp;
  // @@protoc_insertion_point(field_set_allocated:auth.GetUsersByGroupResp.paginationresp)
}

// -------------------------------------------------------------------

// GetUserGroupsReq

// .auth.PaginationRequest paginationreq = 1;
inline bool GetUserGroupsReq::_internal_has_paginationreq() const {
  return this != internal_default_instance() && _impl_.paginationreq_ != nullptr;
}
inline bool GetUserGroupsReq::has_paginationreq() const {
  return _internal_has_paginationreq();
}
inline void GetUserGroupsReq::clear_paginationreq() {
  if (GetArenaForAllocation() == nullptr && _impl_.paginationreq_ != nullptr) {
    delete _impl_.paginationreq_;
  }
  _impl_.paginationreq_ = nullptr;
}
inline const ::auth::PaginationRequest& GetUserGroupsReq::_internal_paginationreq() const {
  const ::auth::PaginationRequest* p = _impl_.paginationreq_;
  return p != nullptr ? *p : reinterpret_cast<const ::auth::PaginationRequest&>(
      ::auth::_PaginationRequest_default_instance_);
}
inline const ::auth::PaginationRequest& GetUserGroupsReq::paginationreq() const {
  // @@protoc_insertion_point(field_get:auth.GetUserGroupsReq.paginationreq)
  return _internal_paginationreq();
}
inline void GetUserGroupsReq::unsafe_arena_set_allocated_paginationreq(
    ::auth::PaginationRequest* paginationreq) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.paginationreq_);
  }
  _impl_.paginationreq_ = paginationreq;
  if (paginationreq) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:auth.GetUserGroupsReq.paginationreq)
}
inline ::auth::PaginationRequest* GetUserGroupsReq::release_paginationreq() {
  
  ::auth::PaginationRequest* temp = _impl_.paginationreq_;
  _impl_.paginationreq_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::auth::PaginationRequest* GetUserGroupsReq::unsafe_arena_release_paginationreq() {
  // @@protoc_insertion_point(field_release:auth.GetUserGroupsReq.paginationreq)
  
  ::auth::PaginationRequest* temp = _impl_.paginationreq_;
  _impl_.paginationreq_ = nullptr;
  return temp;
}
inline ::auth::PaginationRequest* GetUserGroupsReq::_internal_mutable_paginationreq() {
  
  if (_impl_.paginationreq_ == nullptr) {
    auto* p = CreateMaybeMessage<::auth::PaginationRequest>(GetArenaForAllocation());
    _impl_.paginationreq_ = p;
  }
  return _impl_.paginationreq_;
}
inline ::auth::PaginationRequest* GetUserGroupsReq::mutable_paginationreq() {
  ::auth::PaginationRequest* _msg = _internal_mutable_paginationreq();
  // @@protoc_insertion_point(field_mutable:auth.GetUserGroupsReq.paginationreq)
  return _msg;
}
inline void GetUserGroupsReq::set_allocated_paginationreq(::auth::PaginationRequest* paginationreq) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.paginationreq_;
  }
  if (paginationreq) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(paginationreq);
    if (message_arena != submessage_arena) {
      paginationreq = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, paginationreq, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.paginationreq_ = paginationreq;
  // @@protoc_insertion_point(field_set_allocated:auth.GetUserGroupsReq.paginationreq)
}

// -------------------------------------------------------------------

// GetUserGroupsResp

// repeated .auth.UserGroup groups = 1;
inline int GetUserGroupsResp::_internal_groups_size() const {
  return _impl_.groups_.size();
}
inline int GetUserGroupsResp::groups_size() const {
  return _internal_groups_size();
}
inline void GetUserGroupsResp::clear_groups() {
  _impl_.groups_.Clear();
}
inline ::auth::UserGroup* GetUserGroupsResp::mutable_groups(int index) {
  // @@protoc_insertion_point(field_mutable:auth.GetUserGroupsResp.groups)
  return _impl_.groups_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::auth::UserGroup >*
GetUserGroupsResp::mutable_groups() {
  // @@protoc_insertion_point(field_mutable_list:auth.GetUserGroupsResp.groups)
  return &_impl_.groups_;
}
inline const ::auth::UserGroup& GetUserGroupsResp::_internal_groups(int index) const {
  return _impl_.groups_.Get(index);
}
inline const ::auth::UserGroup& GetUserGroupsResp::groups(int index) const {
  // @@protoc_insertion_point(field_get:auth.GetUserGroupsResp.groups)
  return _internal_groups(index);
}
inline ::auth::UserGroup* GetUserGroupsResp::_internal_add_groups() {
  return _impl_.groups_.Add();
}
inline ::auth::UserGroup* GetUserGroupsResp::add_groups() {
  ::auth::UserGroup* _add = _internal_add_groups();
  // @@protoc_insertion_point(field_add:auth.GetUserGroupsResp.groups)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::auth::UserGroup >&
GetUserGroupsResp::groups() const {
  // @@protoc_insertion_point(field_list:auth.GetUserGroupsResp.groups)
  return _impl_.groups_;
}

// .auth.PaginationResponse paginationresp = 2;
inline bool GetUserGroupsResp::_internal_has_paginationresp() const {
  return this != internal_default_instance() && _impl_.paginationresp_ != nullptr;
}
inline bool GetUserGroupsResp::has_paginationresp() const {
  return _internal_has_paginationresp();
}
inline void GetUserGroupsResp::clear_paginationresp() {
  if (GetArenaForAllocation() == nullptr && _impl_.paginationresp_ != nullptr) {
    delete _impl_.paginationresp_;
  }
  _impl_.paginationresp_ = nullptr;
}
inline const ::auth::PaginationResponse& GetUserGroupsResp::_internal_paginationresp() const {
  const ::auth::PaginationResponse* p = _impl_.paginationresp_;
  return p != nullptr ? *p : reinterpret_cast<const ::auth::PaginationResponse&>(
      ::auth::_PaginationResponse_default_instance_);
}
inline const ::auth::PaginationResponse& GetUserGroupsResp::paginationresp() const {
  // @@protoc_insertion_point(field_get:auth.GetUserGroupsResp.paginationresp)
  return _internal_paginationresp();
}
inline void GetUserGroupsResp::unsafe_arena_set_allocated_paginationresp(
    ::auth::PaginationResponse* paginationresp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.paginationresp_);
  }
  _impl_.paginationresp_ = paginationresp;
  if (paginationresp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:auth.GetUserGroupsResp.paginationresp)
}
inline ::auth::PaginationResponse* GetUserGroupsResp::release_paginationresp() {
  
  ::auth::PaginationResponse* temp = _impl_.paginationresp_;
  _impl_.paginationresp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::auth::PaginationResponse* GetUserGroupsResp::unsafe_arena_release_paginationresp() {
  // @@protoc_insertion_point(field_release:auth.GetUserGroupsResp.paginationresp)
  
  ::auth::PaginationResponse* temp = _impl_.paginationresp_;
  _impl_.paginationresp_ = nullptr;
  return temp;
}
inline ::auth::PaginationResponse* GetUserGroupsResp::_internal_mutable_paginationresp() {
  
  if (_impl_.paginationresp_ == nullptr) {
    auto* p = CreateMaybeMessage<::auth::PaginationResponse>(GetArenaForAllocation());
    _impl_.paginationresp_ = p;
  }
  return _impl_.paginationresp_;
}
inline ::auth::PaginationResponse* GetUserGroupsResp::mutable_paginationresp() {
  ::auth::PaginationResponse* _msg = _internal_mutable_paginationresp();
  // @@protoc_insertion_point(field_mutable:auth.GetUserGroupsResp.paginationresp)
  return _msg;
}
inline void GetUserGroupsResp::set_allocated_paginationresp(::auth::PaginationResponse* paginationresp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.paginationresp_;
  }
  if (paginationresp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(paginationresp);
    if (message_arena != submessage_arena) {
      paginationresp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, paginationresp, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.paginationresp_ = paginationresp;
  // @@protoc_insertion_point(field_set_allocated:auth.GetUserGroupsResp.paginationresp)
}

// -------------------------------------------------------------------

// EditCommand_GetUser

// uint64 id = 1;
inline void EditCommand_GetUser::clear_id() {
  _impl_.id_ = uint64_t{0u};
}
inline uint64_t EditCommand_GetUser::_internal_id() const {
  return _impl_.id_;
}
inline uint64_t EditCommand_GetUser::id() const {
  // @@protoc_insertion_point(field_get:auth.EditCommand.GetUser.id)
  return _internal_id();
}
inline void EditCommand_GetUser::_internal_set_id(uint64_t value) {
  
  _impl_.id_ = value;
}
inline void EditCommand_GetUser::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:auth.EditCommand.GetUser.id)
}

// -------------------------------------------------------------------

// EditCommand_GetUserGroup

// uint64 id = 1;
inline void EditCommand_GetUserGroup::clear_id() {
  _impl_.id_ = uint64_t{0u};
}
inline uint64_t EditCommand_GetUserGroup::_internal_id() const {
  return _impl_.id_;
}
inline uint64_t EditCommand_GetUserGroup::id() const {
  // @@protoc_insertion_point(field_get:auth.EditCommand.GetUserGroup.id)
  return _internal_id();
}
inline void EditCommand_GetUserGroup::_internal_set_id(uint64_t value) {
  
  _impl_.id_ = value;
}
inline void EditCommand_GetUserGroup::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:auth.EditCommand.GetUserGroup.id)
}

// -------------------------------------------------------------------

// EditCommand_UpdateUser

// .auth.User user = 1;
inline bool EditCommand_UpdateUser::_internal_has_user() const {
  return this != internal_default_instance() && _impl_.user_ != nullptr;
}
inline bool EditCommand_UpdateUser::has_user() const {
  return _internal_has_user();
}
inline void EditCommand_UpdateUser::clear_user() {
  if (GetArenaForAllocation() == nullptr && _impl_.user_ != nullptr) {
    delete _impl_.user_;
  }
  _impl_.user_ = nullptr;
}
inline const ::auth::User& EditCommand_UpdateUser::_internal_user() const {
  const ::auth::User* p = _impl_.user_;
  return p != nullptr ? *p : reinterpret_cast<const ::auth::User&>(
      ::auth::_User_default_instance_);
}
inline const ::auth::User& EditCommand_UpdateUser::user() const {
  // @@protoc_insertion_point(field_get:auth.EditCommand.UpdateUser.user)
  return _internal_user();
}
inline void EditCommand_UpdateUser::unsafe_arena_set_allocated_user(
    ::auth::User* user) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.user_);
  }
  _impl_.user_ = user;
  if (user) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:auth.EditCommand.UpdateUser.user)
}
inline ::auth::User* EditCommand_UpdateUser::release_user() {
  
  ::auth::User* temp = _impl_.user_;
  _impl_.user_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::auth::User* EditCommand_UpdateUser::unsafe_arena_release_user() {
  // @@protoc_insertion_point(field_release:auth.EditCommand.UpdateUser.user)
  
  ::auth::User* temp = _impl_.user_;
  _impl_.user_ = nullptr;
  return temp;
}
inline ::auth::User* EditCommand_UpdateUser::_internal_mutable_user() {
  
  if (_impl_.user_ == nullptr) {
    auto* p = CreateMaybeMessage<::auth::User>(GetArenaForAllocation());
    _impl_.user_ = p;
  }
  return _impl_.user_;
}
inline ::auth::User* EditCommand_UpdateUser::mutable_user() {
  ::auth::User* _msg = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:auth.EditCommand.UpdateUser.user)
  return _msg;
}
inline void EditCommand_UpdateUser::set_allocated_user(::auth::User* user) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.user_;
  }
  if (user) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(user);
    if (message_arena != submessage_arena) {
      user = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.user_ = user;
  // @@protoc_insertion_point(field_set_allocated:auth.EditCommand.UpdateUser.user)
}

// -------------------------------------------------------------------

// EditCommand_UpdateUserGroup

// .auth.UserGroup group = 1;
inline bool EditCommand_UpdateUserGroup::_internal_has_group() const {
  return this != internal_default_instance() && _impl_.group_ != nullptr;
}
inline bool EditCommand_UpdateUserGroup::has_group() const {
  return _internal_has_group();
}
inline void EditCommand_UpdateUserGroup::clear_group() {
  if (GetArenaForAllocation() == nullptr && _impl_.group_ != nullptr) {
    delete _impl_.group_;
  }
  _impl_.group_ = nullptr;
}
inline const ::auth::UserGroup& EditCommand_UpdateUserGroup::_internal_group() const {
  const ::auth::UserGroup* p = _impl_.group_;
  return p != nullptr ? *p : reinterpret_cast<const ::auth::UserGroup&>(
      ::auth::_UserGroup_default_instance_);
}
inline const ::auth::UserGroup& EditCommand_UpdateUserGroup::group() const {
  // @@protoc_insertion_point(field_get:auth.EditCommand.UpdateUserGroup.group)
  return _internal_group();
}
inline void EditCommand_UpdateUserGroup::unsafe_arena_set_allocated_group(
    ::auth::UserGroup* group) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.group_);
  }
  _impl_.group_ = group;
  if (group) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:auth.EditCommand.UpdateUserGroup.group)
}
inline ::auth::UserGroup* EditCommand_UpdateUserGroup::release_group() {
  
  ::auth::UserGroup* temp = _impl_.group_;
  _impl_.group_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::auth::UserGroup* EditCommand_UpdateUserGroup::unsafe_arena_release_group() {
  // @@protoc_insertion_point(field_release:auth.EditCommand.UpdateUserGroup.group)
  
  ::auth::UserGroup* temp = _impl_.group_;
  _impl_.group_ = nullptr;
  return temp;
}
inline ::auth::UserGroup* EditCommand_UpdateUserGroup::_internal_mutable_group() {
  
  if (_impl_.group_ == nullptr) {
    auto* p = CreateMaybeMessage<::auth::UserGroup>(GetArenaForAllocation());
    _impl_.group_ = p;
  }
  return _impl_.group_;
}
inline ::auth::UserGroup* EditCommand_UpdateUserGroup::mutable_group() {
  ::auth::UserGroup* _msg = _internal_mutable_group();
  // @@protoc_insertion_point(field_mutable:auth.EditCommand.UpdateUserGroup.group)
  return _msg;
}
inline void EditCommand_UpdateUserGroup::set_allocated_group(::auth::UserGroup* group) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.group_;
  }
  if (group) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(group);
    if (message_arena != submessage_arena) {
      group = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, group, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.group_ = group;
  // @@protoc_insertion_point(field_set_allocated:auth.EditCommand.UpdateUserGroup.group)
}

// -------------------------------------------------------------------

// EditCommand_DeleteUser

// uint64 id = 1;
inline void EditCommand_DeleteUser::clear_id() {
  _impl_.id_ = uint64_t{0u};
}
inline uint64_t EditCommand_DeleteUser::_internal_id() const {
  return _impl_.id_;
}
inline uint64_t EditCommand_DeleteUser::id() const {
  // @@protoc_insertion_point(field_get:auth.EditCommand.DeleteUser.id)
  return _internal_id();
}
inline void EditCommand_DeleteUser::_internal_set_id(uint64_t value) {
  
  _impl_.id_ = value;
}
inline void EditCommand_DeleteUser::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:auth.EditCommand.DeleteUser.id)
}

// -------------------------------------------------------------------

// EditCommand_DeleteUserGroup

// uint64 id = 1;
inline void EditCommand_DeleteUserGroup::clear_id() {
  _impl_.id_ = uint64_t{0u};
}
inline uint64_t EditCommand_DeleteUserGroup::_internal_id() const {
  return _impl_.id_;
}
inline uint64_t EditCommand_DeleteUserGroup::id() const {
  // @@protoc_insertion_point(field_get:auth.EditCommand.DeleteUserGroup.id)
  return _internal_id();
}
inline void EditCommand_DeleteUserGroup::_internal_set_id(uint64_t value) {
  
  _impl_.id_ = value;
}
inline void EditCommand_DeleteUserGroup::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:auth.EditCommand.DeleteUserGroup.id)
}

// -------------------------------------------------------------------

// EditCommand_CreateUser

// .auth.User user = 1;
inline bool EditCommand_CreateUser::_internal_has_user() const {
  return this != internal_default_instance() && _impl_.user_ != nullptr;
}
inline bool EditCommand_CreateUser::has_user() const {
  return _internal_has_user();
}
inline void EditCommand_CreateUser::clear_user() {
  if (GetArenaForAllocation() == nullptr && _impl_.user_ != nullptr) {
    delete _impl_.user_;
  }
  _impl_.user_ = nullptr;
}
inline const ::auth::User& EditCommand_CreateUser::_internal_user() const {
  const ::auth::User* p = _impl_.user_;
  return p != nullptr ? *p : reinterpret_cast<const ::auth::User&>(
      ::auth::_User_default_instance_);
}
inline const ::auth::User& EditCommand_CreateUser::user() const {
  // @@protoc_insertion_point(field_get:auth.EditCommand.CreateUser.user)
  return _internal_user();
}
inline void EditCommand_CreateUser::unsafe_arena_set_allocated_user(
    ::auth::User* user) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.user_);
  }
  _impl_.user_ = user;
  if (user) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:auth.EditCommand.CreateUser.user)
}
inline ::auth::User* EditCommand_CreateUser::release_user() {
  
  ::auth::User* temp = _impl_.user_;
  _impl_.user_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::auth::User* EditCommand_CreateUser::unsafe_arena_release_user() {
  // @@protoc_insertion_point(field_release:auth.EditCommand.CreateUser.user)
  
  ::auth::User* temp = _impl_.user_;
  _impl_.user_ = nullptr;
  return temp;
}
inline ::auth::User* EditCommand_CreateUser::_internal_mutable_user() {
  
  if (_impl_.user_ == nullptr) {
    auto* p = CreateMaybeMessage<::auth::User>(GetArenaForAllocation());
    _impl_.user_ = p;
  }
  return _impl_.user_;
}
inline ::auth::User* EditCommand_CreateUser::mutable_user() {
  ::auth::User* _msg = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:auth.EditCommand.CreateUser.user)
  return _msg;
}
inline void EditCommand_CreateUser::set_allocated_user(::auth::User* user) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.user_;
  }
  if (user) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(user);
    if (message_arena != submessage_arena) {
      user = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.user_ = user;
  // @@protoc_insertion_point(field_set_allocated:auth.EditCommand.CreateUser.user)
}

// -------------------------------------------------------------------

// EditCommand_CreateUserGroup

// .auth.UserGroup group = 1;
inline bool EditCommand_CreateUserGroup::_internal_has_group() const {
  return this != internal_default_instance() && _impl_.group_ != nullptr;
}
inline bool EditCommand_CreateUserGroup::has_group() const {
  return _internal_has_group();
}
inline void EditCommand_CreateUserGroup::clear_group() {
  if (GetArenaForAllocation() == nullptr && _impl_.group_ != nullptr) {
    delete _impl_.group_;
  }
  _impl_.group_ = nullptr;
}
inline const ::auth::UserGroup& EditCommand_CreateUserGroup::_internal_group() const {
  const ::auth::UserGroup* p = _impl_.group_;
  return p != nullptr ? *p : reinterpret_cast<const ::auth::UserGroup&>(
      ::auth::_UserGroup_default_instance_);
}
inline const ::auth::UserGroup& EditCommand_CreateUserGroup::group() const {
  // @@protoc_insertion_point(field_get:auth.EditCommand.CreateUserGroup.group)
  return _internal_group();
}
inline void EditCommand_CreateUserGroup::unsafe_arena_set_allocated_group(
    ::auth::UserGroup* group) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.group_);
  }
  _impl_.group_ = group;
  if (group) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:auth.EditCommand.CreateUserGroup.group)
}
inline ::auth::UserGroup* EditCommand_CreateUserGroup::release_group() {
  
  ::auth::UserGroup* temp = _impl_.group_;
  _impl_.group_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::auth::UserGroup* EditCommand_CreateUserGroup::unsafe_arena_release_group() {
  // @@protoc_insertion_point(field_release:auth.EditCommand.CreateUserGroup.group)
  
  ::auth::UserGroup* temp = _impl_.group_;
  _impl_.group_ = nullptr;
  return temp;
}
inline ::auth::UserGroup* EditCommand_CreateUserGroup::_internal_mutable_group() {
  
  if (_impl_.group_ == nullptr) {
    auto* p = CreateMaybeMessage<::auth::UserGroup>(GetArenaForAllocation());
    _impl_.group_ = p;
  }
  return _impl_.group_;
}
inline ::auth::UserGroup* EditCommand_CreateUserGroup::mutable_group() {
  ::auth::UserGroup* _msg = _internal_mutable_group();
  // @@protoc_insertion_point(field_mutable:auth.EditCommand.CreateUserGroup.group)
  return _msg;
}
inline void EditCommand_CreateUserGroup::set_allocated_group(::auth::UserGroup* group) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.group_;
  }
  if (group) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(group);
    if (message_arena != submessage_arena) {
      group = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, group, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.group_ = group;
  // @@protoc_insertion_point(field_set_allocated:auth.EditCommand.CreateUserGroup.group)
}

// -------------------------------------------------------------------

// EditCommand_GetTerminal

// uint64 id = 1;
inline void EditCommand_GetTerminal::clear_id() {
  _impl_.id_ = uint64_t{0u};
}
inline uint64_t EditCommand_GetTerminal::_internal_id() const {
  return _impl_.id_;
}
inline uint64_t EditCommand_GetTerminal::id() const {
  // @@protoc_insertion_point(field_get:auth.EditCommand.GetTerminal.id)
  return _internal_id();
}
inline void EditCommand_GetTerminal::_internal_set_id(uint64_t value) {
  
  _impl_.id_ = value;
}
inline void EditCommand_GetTerminal::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:auth.EditCommand.GetTerminal.id)
}

// -------------------------------------------------------------------

// EditCommand_UpdateTerminal

// .auth.Terminal terminal = 1;
inline bool EditCommand_UpdateTerminal::_internal_has_terminal() const {
  return this != internal_default_instance() && _impl_.terminal_ != nullptr;
}
inline bool EditCommand_UpdateTerminal::has_terminal() const {
  return _internal_has_terminal();
}
inline void EditCommand_UpdateTerminal::clear_terminal() {
  if (GetArenaForAllocation() == nullptr && _impl_.terminal_ != nullptr) {
    delete _impl_.terminal_;
  }
  _impl_.terminal_ = nullptr;
}
inline const ::auth::Terminal& EditCommand_UpdateTerminal::_internal_terminal() const {
  const ::auth::Terminal* p = _impl_.terminal_;
  return p != nullptr ? *p : reinterpret_cast<const ::auth::Terminal&>(
      ::auth::_Terminal_default_instance_);
}
inline const ::auth::Terminal& EditCommand_UpdateTerminal::terminal() const {
  // @@protoc_insertion_point(field_get:auth.EditCommand.UpdateTerminal.terminal)
  return _internal_terminal();
}
inline void EditCommand_UpdateTerminal::unsafe_arena_set_allocated_terminal(
    ::auth::Terminal* terminal) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.terminal_);
  }
  _impl_.terminal_ = terminal;
  if (terminal) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:auth.EditCommand.UpdateTerminal.terminal)
}
inline ::auth::Terminal* EditCommand_UpdateTerminal::release_terminal() {
  
  ::auth::Terminal* temp = _impl_.terminal_;
  _impl_.terminal_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::auth::Terminal* EditCommand_UpdateTerminal::unsafe_arena_release_terminal() {
  // @@protoc_insertion_point(field_release:auth.EditCommand.UpdateTerminal.terminal)
  
  ::auth::Terminal* temp = _impl_.terminal_;
  _impl_.terminal_ = nullptr;
  return temp;
}
inline ::auth::Terminal* EditCommand_UpdateTerminal::_internal_mutable_terminal() {
  
  if (_impl_.terminal_ == nullptr) {
    auto* p = CreateMaybeMessage<::auth::Terminal>(GetArenaForAllocation());
    _impl_.terminal_ = p;
  }
  return _impl_.terminal_;
}
inline ::auth::Terminal* EditCommand_UpdateTerminal::mutable_terminal() {
  ::auth::Terminal* _msg = _internal_mutable_terminal();
  // @@protoc_insertion_point(field_mutable:auth.EditCommand.UpdateTerminal.terminal)
  return _msg;
}
inline void EditCommand_UpdateTerminal::set_allocated_terminal(::auth::Terminal* terminal) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.terminal_;
  }
  if (terminal) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(terminal);
    if (message_arena != submessage_arena) {
      terminal = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, terminal, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.terminal_ = terminal;
  // @@protoc_insertion_point(field_set_allocated:auth.EditCommand.UpdateTerminal.terminal)
}

// -------------------------------------------------------------------

// EditCommand_DeleteTerminal

// uint64 id = 1;
inline void EditCommand_DeleteTerminal::clear_id() {
  _impl_.id_ = uint64_t{0u};
}
inline uint64_t EditCommand_DeleteTerminal::_internal_id() const {
  return _impl_.id_;
}
inline uint64_t EditCommand_DeleteTerminal::id() const {
  // @@protoc_insertion_point(field_get:auth.EditCommand.DeleteTerminal.id)
  return _internal_id();
}
inline void EditCommand_DeleteTerminal::_internal_set_id(uint64_t value) {
  
  _impl_.id_ = value;
}
inline void EditCommand_DeleteTerminal::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:auth.EditCommand.DeleteTerminal.id)
}

// -------------------------------------------------------------------

// EditCommand_GetTerminals

// .auth.PaginationRequest request = 1;
inline bool EditCommand_GetTerminals::_internal_has_request() const {
  return this != internal_default_instance() && _impl_.request_ != nullptr;
}
inline bool EditCommand_GetTerminals::has_request() const {
  return _internal_has_request();
}
inline void EditCommand_GetTerminals::clear_request() {
  if (GetArenaForAllocation() == nullptr && _impl_.request_ != nullptr) {
    delete _impl_.request_;
  }
  _impl_.request_ = nullptr;
}
inline const ::auth::PaginationRequest& EditCommand_GetTerminals::_internal_request() const {
  const ::auth::PaginationRequest* p = _impl_.request_;
  return p != nullptr ? *p : reinterpret_cast<const ::auth::PaginationRequest&>(
      ::auth::_PaginationRequest_default_instance_);
}
inline const ::auth::PaginationRequest& EditCommand_GetTerminals::request() const {
  // @@protoc_insertion_point(field_get:auth.EditCommand.GetTerminals.request)
  return _internal_request();
}
inline void EditCommand_GetTerminals::unsafe_arena_set_allocated_request(
    ::auth::PaginationRequest* request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  _impl_.request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:auth.EditCommand.GetTerminals.request)
}
inline ::auth::PaginationRequest* EditCommand_GetTerminals::release_request() {
  
  ::auth::PaginationRequest* temp = _impl_.request_;
  _impl_.request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::auth::PaginationRequest* EditCommand_GetTerminals::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:auth.EditCommand.GetTerminals.request)
  
  ::auth::PaginationRequest* temp = _impl_.request_;
  _impl_.request_ = nullptr;
  return temp;
}
inline ::auth::PaginationRequest* EditCommand_GetTerminals::_internal_mutable_request() {
  
  if (_impl_.request_ == nullptr) {
    auto* p = CreateMaybeMessage<::auth::PaginationRequest>(GetArenaForAllocation());
    _impl_.request_ = p;
  }
  return _impl_.request_;
}
inline ::auth::PaginationRequest* EditCommand_GetTerminals::mutable_request() {
  ::auth::PaginationRequest* _msg = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:auth.EditCommand.GetTerminals.request)
  return _msg;
}
inline void EditCommand_GetTerminals::set_allocated_request(::auth::PaginationRequest* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.request_;
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(request);
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.request_ = request;
  // @@protoc_insertion_point(field_set_allocated:auth.EditCommand.GetTerminals.request)
}

// -------------------------------------------------------------------

// EditCommand_CreateTerminal

// .auth.Terminal terminal = 1;
inline bool EditCommand_CreateTerminal::_internal_has_terminal() const {
  return this != internal_default_instance() && _impl_.terminal_ != nullptr;
}
inline bool EditCommand_CreateTerminal::has_terminal() const {
  return _internal_has_terminal();
}
inline void EditCommand_CreateTerminal::clear_terminal() {
  if (GetArenaForAllocation() == nullptr && _impl_.terminal_ != nullptr) {
    delete _impl_.terminal_;
  }
  _impl_.terminal_ = nullptr;
}
inline const ::auth::Terminal& EditCommand_CreateTerminal::_internal_terminal() const {
  const ::auth::Terminal* p = _impl_.terminal_;
  return p != nullptr ? *p : reinterpret_cast<const ::auth::Terminal&>(
      ::auth::_Terminal_default_instance_);
}
inline const ::auth::Terminal& EditCommand_CreateTerminal::terminal() const {
  // @@protoc_insertion_point(field_get:auth.EditCommand.CreateTerminal.terminal)
  return _internal_terminal();
}
inline void EditCommand_CreateTerminal::unsafe_arena_set_allocated_terminal(
    ::auth::Terminal* terminal) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.terminal_);
  }
  _impl_.terminal_ = terminal;
  if (terminal) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:auth.EditCommand.CreateTerminal.terminal)
}
inline ::auth::Terminal* EditCommand_CreateTerminal::release_terminal() {
  
  ::auth::Terminal* temp = _impl_.terminal_;
  _impl_.terminal_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::auth::Terminal* EditCommand_CreateTerminal::unsafe_arena_release_terminal() {
  // @@protoc_insertion_point(field_release:auth.EditCommand.CreateTerminal.terminal)
  
  ::auth::Terminal* temp = _impl_.terminal_;
  _impl_.terminal_ = nullptr;
  return temp;
}
inline ::auth::Terminal* EditCommand_CreateTerminal::_internal_mutable_terminal() {
  
  if (_impl_.terminal_ == nullptr) {
    auto* p = CreateMaybeMessage<::auth::Terminal>(GetArenaForAllocation());
    _impl_.terminal_ = p;
  }
  return _impl_.terminal_;
}
inline ::auth::Terminal* EditCommand_CreateTerminal::mutable_terminal() {
  ::auth::Terminal* _msg = _internal_mutable_terminal();
  // @@protoc_insertion_point(field_mutable:auth.EditCommand.CreateTerminal.terminal)
  return _msg;
}
inline void EditCommand_CreateTerminal::set_allocated_terminal(::auth::Terminal* terminal) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.terminal_;
  }
  if (terminal) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(terminal);
    if (message_arena != submessage_arena) {
      terminal = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, terminal, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.terminal_ = terminal;
  // @@protoc_insertion_point(field_set_allocated:auth.EditCommand.CreateTerminal.terminal)
}

// -------------------------------------------------------------------

// EditCommand_Save

// -------------------------------------------------------------------

// EditCommand_Cancel

// -------------------------------------------------------------------

// EditCommand

// .auth.EditCommand.GetUser getuser = 1;
inline bool EditCommand::_internal_has_getuser() const {
  return cmd_case() == kGetuser;
}
inline bool EditCommand::has_getuser() const {
  return _internal_has_getuser();
}
inline void EditCommand::set_has_getuser() {
  _impl_._oneof_case_[0] = kGetuser;
}
inline void EditCommand::clear_getuser() {
  if (_internal_has_getuser()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.cmd_.getuser_;
    }
    clear_has_cmd();
  }
}
inline ::auth::EditCommand_GetUser* EditCommand::release_getuser() {
  // @@protoc_insertion_point(field_release:auth.EditCommand.getuser)
  if (_internal_has_getuser()) {
    clear_has_cmd();
    ::auth::EditCommand_GetUser* temp = _impl_.cmd_.getuser_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.cmd_.getuser_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::auth::EditCommand_GetUser& EditCommand::_internal_getuser() const {
  return _internal_has_getuser()
      ? *_impl_.cmd_.getuser_
      : reinterpret_cast< ::auth::EditCommand_GetUser&>(::auth::_EditCommand_GetUser_default_instance_);
}
inline const ::auth::EditCommand_GetUser& EditCommand::getuser() const {
  // @@protoc_insertion_point(field_get:auth.EditCommand.getuser)
  return _internal_getuser();
}
inline ::auth::EditCommand_GetUser* EditCommand::unsafe_arena_release_getuser() {
  // @@protoc_insertion_point(field_unsafe_arena_release:auth.EditCommand.getuser)
  if (_internal_has_getuser()) {
    clear_has_cmd();
    ::auth::EditCommand_GetUser* temp = _impl_.cmd_.getuser_;
    _impl_.cmd_.getuser_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EditCommand::unsafe_arena_set_allocated_getuser(::auth::EditCommand_GetUser* getuser) {
  clear_cmd();
  if (getuser) {
    set_has_getuser();
    _impl_.cmd_.getuser_ = getuser;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:auth.EditCommand.getuser)
}
inline ::auth::EditCommand_GetUser* EditCommand::_internal_mutable_getuser() {
  if (!_internal_has_getuser()) {
    clear_cmd();
    set_has_getuser();
    _impl_.cmd_.getuser_ = CreateMaybeMessage< ::auth::EditCommand_GetUser >(GetArenaForAllocation());
  }
  return _impl_.cmd_.getuser_;
}
inline ::auth::EditCommand_GetUser* EditCommand::mutable_getuser() {
  ::auth::EditCommand_GetUser* _msg = _internal_mutable_getuser();
  // @@protoc_insertion_point(field_mutable:auth.EditCommand.getuser)
  return _msg;
}

// .auth.EditCommand.GetUserGroup getusergroup = 2;
inline bool EditCommand::_internal_has_getusergroup() const {
  return cmd_case() == kGetusergroup;
}
inline bool EditCommand::has_getusergroup() const {
  return _internal_has_getusergroup();
}
inline void EditCommand::set_has_getusergroup() {
  _impl_._oneof_case_[0] = kGetusergroup;
}
inline void EditCommand::clear_getusergroup() {
  if (_internal_has_getusergroup()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.cmd_.getusergroup_;
    }
    clear_has_cmd();
  }
}
inline ::auth::EditCommand_GetUserGroup* EditCommand::release_getusergroup() {
  // @@protoc_insertion_point(field_release:auth.EditCommand.getusergroup)
  if (_internal_has_getusergroup()) {
    clear_has_cmd();
    ::auth::EditCommand_GetUserGroup* temp = _impl_.cmd_.getusergroup_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.cmd_.getusergroup_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::auth::EditCommand_GetUserGroup& EditCommand::_internal_getusergroup() const {
  return _internal_has_getusergroup()
      ? *_impl_.cmd_.getusergroup_
      : reinterpret_cast< ::auth::EditCommand_GetUserGroup&>(::auth::_EditCommand_GetUserGroup_default_instance_);
}
inline const ::auth::EditCommand_GetUserGroup& EditCommand::getusergroup() const {
  // @@protoc_insertion_point(field_get:auth.EditCommand.getusergroup)
  return _internal_getusergroup();
}
inline ::auth::EditCommand_GetUserGroup* EditCommand::unsafe_arena_release_getusergroup() {
  // @@protoc_insertion_point(field_unsafe_arena_release:auth.EditCommand.getusergroup)
  if (_internal_has_getusergroup()) {
    clear_has_cmd();
    ::auth::EditCommand_GetUserGroup* temp = _impl_.cmd_.getusergroup_;
    _impl_.cmd_.getusergroup_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EditCommand::unsafe_arena_set_allocated_getusergroup(::auth::EditCommand_GetUserGroup* getusergroup) {
  clear_cmd();
  if (getusergroup) {
    set_has_getusergroup();
    _impl_.cmd_.getusergroup_ = getusergroup;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:auth.EditCommand.getusergroup)
}
inline ::auth::EditCommand_GetUserGroup* EditCommand::_internal_mutable_getusergroup() {
  if (!_internal_has_getusergroup()) {
    clear_cmd();
    set_has_getusergroup();
    _impl_.cmd_.getusergroup_ = CreateMaybeMessage< ::auth::EditCommand_GetUserGroup >(GetArenaForAllocation());
  }
  return _impl_.cmd_.getusergroup_;
}
inline ::auth::EditCommand_GetUserGroup* EditCommand::mutable_getusergroup() {
  ::auth::EditCommand_GetUserGroup* _msg = _internal_mutable_getusergroup();
  // @@protoc_insertion_point(field_mutable:auth.EditCommand.getusergroup)
  return _msg;
}

// .auth.EditCommand.UpdateUser updateuser = 3;
inline bool EditCommand::_internal_has_updateuser() const {
  return cmd_case() == kUpdateuser;
}
inline bool EditCommand::has_updateuser() const {
  return _internal_has_updateuser();
}
inline void EditCommand::set_has_updateuser() {
  _impl_._oneof_case_[0] = kUpdateuser;
}
inline void EditCommand::clear_updateuser() {
  if (_internal_has_updateuser()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.cmd_.updateuser_;
    }
    clear_has_cmd();
  }
}
inline ::auth::EditCommand_UpdateUser* EditCommand::release_updateuser() {
  // @@protoc_insertion_point(field_release:auth.EditCommand.updateuser)
  if (_internal_has_updateuser()) {
    clear_has_cmd();
    ::auth::EditCommand_UpdateUser* temp = _impl_.cmd_.updateuser_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.cmd_.updateuser_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::auth::EditCommand_UpdateUser& EditCommand::_internal_updateuser() const {
  return _internal_has_updateuser()
      ? *_impl_.cmd_.updateuser_
      : reinterpret_cast< ::auth::EditCommand_UpdateUser&>(::auth::_EditCommand_UpdateUser_default_instance_);
}
inline const ::auth::EditCommand_UpdateUser& EditCommand::updateuser() const {
  // @@protoc_insertion_point(field_get:auth.EditCommand.updateuser)
  return _internal_updateuser();
}
inline ::auth::EditCommand_UpdateUser* EditCommand::unsafe_arena_release_updateuser() {
  // @@protoc_insertion_point(field_unsafe_arena_release:auth.EditCommand.updateuser)
  if (_internal_has_updateuser()) {
    clear_has_cmd();
    ::auth::EditCommand_UpdateUser* temp = _impl_.cmd_.updateuser_;
    _impl_.cmd_.updateuser_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EditCommand::unsafe_arena_set_allocated_updateuser(::auth::EditCommand_UpdateUser* updateuser) {
  clear_cmd();
  if (updateuser) {
    set_has_updateuser();
    _impl_.cmd_.updateuser_ = updateuser;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:auth.EditCommand.updateuser)
}
inline ::auth::EditCommand_UpdateUser* EditCommand::_internal_mutable_updateuser() {
  if (!_internal_has_updateuser()) {
    clear_cmd();
    set_has_updateuser();
    _impl_.cmd_.updateuser_ = CreateMaybeMessage< ::auth::EditCommand_UpdateUser >(GetArenaForAllocation());
  }
  return _impl_.cmd_.updateuser_;
}
inline ::auth::EditCommand_UpdateUser* EditCommand::mutable_updateuser() {
  ::auth::EditCommand_UpdateUser* _msg = _internal_mutable_updateuser();
  // @@protoc_insertion_point(field_mutable:auth.EditCommand.updateuser)
  return _msg;
}

// .auth.EditCommand.UpdateUserGroup updateusergroup = 4;
inline bool EditCommand::_internal_has_updateusergroup() const {
  return cmd_case() == kUpdateusergroup;
}
inline bool EditCommand::has_updateusergroup() const {
  return _internal_has_updateusergroup();
}
inline void EditCommand::set_has_updateusergroup() {
  _impl_._oneof_case_[0] = kUpdateusergroup;
}
inline void EditCommand::clear_updateusergroup() {
  if (_internal_has_updateusergroup()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.cmd_.updateusergroup_;
    }
    clear_has_cmd();
  }
}
inline ::auth::EditCommand_UpdateUserGroup* EditCommand::release_updateusergroup() {
  // @@protoc_insertion_point(field_release:auth.EditCommand.updateusergroup)
  if (_internal_has_updateusergroup()) {
    clear_has_cmd();
    ::auth::EditCommand_UpdateUserGroup* temp = _impl_.cmd_.updateusergroup_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.cmd_.updateusergroup_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::auth::EditCommand_UpdateUserGroup& EditCommand::_internal_updateusergroup() const {
  return _internal_has_updateusergroup()
      ? *_impl_.cmd_.updateusergroup_
      : reinterpret_cast< ::auth::EditCommand_UpdateUserGroup&>(::auth::_EditCommand_UpdateUserGroup_default_instance_);
}
inline const ::auth::EditCommand_UpdateUserGroup& EditCommand::updateusergroup() const {
  // @@protoc_insertion_point(field_get:auth.EditCommand.updateusergroup)
  return _internal_updateusergroup();
}
inline ::auth::EditCommand_UpdateUserGroup* EditCommand::unsafe_arena_release_updateusergroup() {
  // @@protoc_insertion_point(field_unsafe_arena_release:auth.EditCommand.updateusergroup)
  if (_internal_has_updateusergroup()) {
    clear_has_cmd();
    ::auth::EditCommand_UpdateUserGroup* temp = _impl_.cmd_.updateusergroup_;
    _impl_.cmd_.updateusergroup_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EditCommand::unsafe_arena_set_allocated_updateusergroup(::auth::EditCommand_UpdateUserGroup* updateusergroup) {
  clear_cmd();
  if (updateusergroup) {
    set_has_updateusergroup();
    _impl_.cmd_.updateusergroup_ = updateusergroup;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:auth.EditCommand.updateusergroup)
}
inline ::auth::EditCommand_UpdateUserGroup* EditCommand::_internal_mutable_updateusergroup() {
  if (!_internal_has_updateusergroup()) {
    clear_cmd();
    set_has_updateusergroup();
    _impl_.cmd_.updateusergroup_ = CreateMaybeMessage< ::auth::EditCommand_UpdateUserGroup >(GetArenaForAllocation());
  }
  return _impl_.cmd_.updateusergroup_;
}
inline ::auth::EditCommand_UpdateUserGroup* EditCommand::mutable_updateusergroup() {
  ::auth::EditCommand_UpdateUserGroup* _msg = _internal_mutable_updateusergroup();
  // @@protoc_insertion_point(field_mutable:auth.EditCommand.updateusergroup)
  return _msg;
}

// .auth.EditCommand.DeleteUser deleteuser = 5;
inline bool EditCommand::_internal_has_deleteuser() const {
  return cmd_case() == kDeleteuser;
}
inline bool EditCommand::has_deleteuser() const {
  return _internal_has_deleteuser();
}
inline void EditCommand::set_has_deleteuser() {
  _impl_._oneof_case_[0] = kDeleteuser;
}
inline void EditCommand::clear_deleteuser() {
  if (_internal_has_deleteuser()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.cmd_.deleteuser_;
    }
    clear_has_cmd();
  }
}
inline ::auth::EditCommand_DeleteUser* EditCommand::release_deleteuser() {
  // @@protoc_insertion_point(field_release:auth.EditCommand.deleteuser)
  if (_internal_has_deleteuser()) {
    clear_has_cmd();
    ::auth::EditCommand_DeleteUser* temp = _impl_.cmd_.deleteuser_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.cmd_.deleteuser_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::auth::EditCommand_DeleteUser& EditCommand::_internal_deleteuser() const {
  return _internal_has_deleteuser()
      ? *_impl_.cmd_.deleteuser_
      : reinterpret_cast< ::auth::EditCommand_DeleteUser&>(::auth::_EditCommand_DeleteUser_default_instance_);
}
inline const ::auth::EditCommand_DeleteUser& EditCommand::deleteuser() const {
  // @@protoc_insertion_point(field_get:auth.EditCommand.deleteuser)
  return _internal_deleteuser();
}
inline ::auth::EditCommand_DeleteUser* EditCommand::unsafe_arena_release_deleteuser() {
  // @@protoc_insertion_point(field_unsafe_arena_release:auth.EditCommand.deleteuser)
  if (_internal_has_deleteuser()) {
    clear_has_cmd();
    ::auth::EditCommand_DeleteUser* temp = _impl_.cmd_.deleteuser_;
    _impl_.cmd_.deleteuser_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EditCommand::unsafe_arena_set_allocated_deleteuser(::auth::EditCommand_DeleteUser* deleteuser) {
  clear_cmd();
  if (deleteuser) {
    set_has_deleteuser();
    _impl_.cmd_.deleteuser_ = deleteuser;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:auth.EditCommand.deleteuser)
}
inline ::auth::EditCommand_DeleteUser* EditCommand::_internal_mutable_deleteuser() {
  if (!_internal_has_deleteuser()) {
    clear_cmd();
    set_has_deleteuser();
    _impl_.cmd_.deleteuser_ = CreateMaybeMessage< ::auth::EditCommand_DeleteUser >(GetArenaForAllocation());
  }
  return _impl_.cmd_.deleteuser_;
}
inline ::auth::EditCommand_DeleteUser* EditCommand::mutable_deleteuser() {
  ::auth::EditCommand_DeleteUser* _msg = _internal_mutable_deleteuser();
  // @@protoc_insertion_point(field_mutable:auth.EditCommand.deleteuser)
  return _msg;
}

// .auth.EditCommand.DeleteUserGroup deleteusergroup = 6;
inline bool EditCommand::_internal_has_deleteusergroup() const {
  return cmd_case() == kDeleteusergroup;
}
inline bool EditCommand::has_deleteusergroup() const {
  return _internal_has_deleteusergroup();
}
inline void EditCommand::set_has_deleteusergroup() {
  _impl_._oneof_case_[0] = kDeleteusergroup;
}
inline void EditCommand::clear_deleteusergroup() {
  if (_internal_has_deleteusergroup()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.cmd_.deleteusergroup_;
    }
    clear_has_cmd();
  }
}
inline ::auth::EditCommand_DeleteUserGroup* EditCommand::release_deleteusergroup() {
  // @@protoc_insertion_point(field_release:auth.EditCommand.deleteusergroup)
  if (_internal_has_deleteusergroup()) {
    clear_has_cmd();
    ::auth::EditCommand_DeleteUserGroup* temp = _impl_.cmd_.deleteusergroup_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.cmd_.deleteusergroup_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::auth::EditCommand_DeleteUserGroup& EditCommand::_internal_deleteusergroup() const {
  return _internal_has_deleteusergroup()
      ? *_impl_.cmd_.deleteusergroup_
      : reinterpret_cast< ::auth::EditCommand_DeleteUserGroup&>(::auth::_EditCommand_DeleteUserGroup_default_instance_);
}
inline const ::auth::EditCommand_DeleteUserGroup& EditCommand::deleteusergroup() const {
  // @@protoc_insertion_point(field_get:auth.EditCommand.deleteusergroup)
  return _internal_deleteusergroup();
}
inline ::auth::EditCommand_DeleteUserGroup* EditCommand::unsafe_arena_release_deleteusergroup() {
  // @@protoc_insertion_point(field_unsafe_arena_release:auth.EditCommand.deleteusergroup)
  if (_internal_has_deleteusergroup()) {
    clear_has_cmd();
    ::auth::EditCommand_DeleteUserGroup* temp = _impl_.cmd_.deleteusergroup_;
    _impl_.cmd_.deleteusergroup_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EditCommand::unsafe_arena_set_allocated_deleteusergroup(::auth::EditCommand_DeleteUserGroup* deleteusergroup) {
  clear_cmd();
  if (deleteusergroup) {
    set_has_deleteusergroup();
    _impl_.cmd_.deleteusergroup_ = deleteusergroup;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:auth.EditCommand.deleteusergroup)
}
inline ::auth::EditCommand_DeleteUserGroup* EditCommand::_internal_mutable_deleteusergroup() {
  if (!_internal_has_deleteusergroup()) {
    clear_cmd();
    set_has_deleteusergroup();
    _impl_.cmd_.deleteusergroup_ = CreateMaybeMessage< ::auth::EditCommand_DeleteUserGroup >(GetArenaForAllocation());
  }
  return _impl_.cmd_.deleteusergroup_;
}
inline ::auth::EditCommand_DeleteUserGroup* EditCommand::mutable_deleteusergroup() {
  ::auth::EditCommand_DeleteUserGroup* _msg = _internal_mutable_deleteusergroup();
  // @@protoc_insertion_point(field_mutable:auth.EditCommand.deleteusergroup)
  return _msg;
}

// .auth.EditCommand.CreateUser createuser = 7;
inline bool EditCommand::_internal_has_createuser() const {
  return cmd_case() == kCreateuser;
}
inline bool EditCommand::has_createuser() const {
  return _internal_has_createuser();
}
inline void EditCommand::set_has_createuser() {
  _impl_._oneof_case_[0] = kCreateuser;
}
inline void EditCommand::clear_createuser() {
  if (_internal_has_createuser()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.cmd_.createuser_;
    }
    clear_has_cmd();
  }
}
inline ::auth::EditCommand_CreateUser* EditCommand::release_createuser() {
  // @@protoc_insertion_point(field_release:auth.EditCommand.createuser)
  if (_internal_has_createuser()) {
    clear_has_cmd();
    ::auth::EditCommand_CreateUser* temp = _impl_.cmd_.createuser_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.cmd_.createuser_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::auth::EditCommand_CreateUser& EditCommand::_internal_createuser() const {
  return _internal_has_createuser()
      ? *_impl_.cmd_.createuser_
      : reinterpret_cast< ::auth::EditCommand_CreateUser&>(::auth::_EditCommand_CreateUser_default_instance_);
}
inline const ::auth::EditCommand_CreateUser& EditCommand::createuser() const {
  // @@protoc_insertion_point(field_get:auth.EditCommand.createuser)
  return _internal_createuser();
}
inline ::auth::EditCommand_CreateUser* EditCommand::unsafe_arena_release_createuser() {
  // @@protoc_insertion_point(field_unsafe_arena_release:auth.EditCommand.createuser)
  if (_internal_has_createuser()) {
    clear_has_cmd();
    ::auth::EditCommand_CreateUser* temp = _impl_.cmd_.createuser_;
    _impl_.cmd_.createuser_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EditCommand::unsafe_arena_set_allocated_createuser(::auth::EditCommand_CreateUser* createuser) {
  clear_cmd();
  if (createuser) {
    set_has_createuser();
    _impl_.cmd_.createuser_ = createuser;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:auth.EditCommand.createuser)
}
inline ::auth::EditCommand_CreateUser* EditCommand::_internal_mutable_createuser() {
  if (!_internal_has_createuser()) {
    clear_cmd();
    set_has_createuser();
    _impl_.cmd_.createuser_ = CreateMaybeMessage< ::auth::EditCommand_CreateUser >(GetArenaForAllocation());
  }
  return _impl_.cmd_.createuser_;
}
inline ::auth::EditCommand_CreateUser* EditCommand::mutable_createuser() {
  ::auth::EditCommand_CreateUser* _msg = _internal_mutable_createuser();
  // @@protoc_insertion_point(field_mutable:auth.EditCommand.createuser)
  return _msg;
}

// .auth.EditCommand.CreateUserGroup createusergroup = 8;
inline bool EditCommand::_internal_has_createusergroup() const {
  return cmd_case() == kCreateusergroup;
}
inline bool EditCommand::has_createusergroup() const {
  return _internal_has_createusergroup();
}
inline void EditCommand::set_has_createusergroup() {
  _impl_._oneof_case_[0] = kCreateusergroup;
}
inline void EditCommand::clear_createusergroup() {
  if (_internal_has_createusergroup()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.cmd_.createusergroup_;
    }
    clear_has_cmd();
  }
}
inline ::auth::EditCommand_CreateUserGroup* EditCommand::release_createusergroup() {
  // @@protoc_insertion_point(field_release:auth.EditCommand.createusergroup)
  if (_internal_has_createusergroup()) {
    clear_has_cmd();
    ::auth::EditCommand_CreateUserGroup* temp = _impl_.cmd_.createusergroup_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.cmd_.createusergroup_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::auth::EditCommand_CreateUserGroup& EditCommand::_internal_createusergroup() const {
  return _internal_has_createusergroup()
      ? *_impl_.cmd_.createusergroup_
      : reinterpret_cast< ::auth::EditCommand_CreateUserGroup&>(::auth::_EditCommand_CreateUserGroup_default_instance_);
}
inline const ::auth::EditCommand_CreateUserGroup& EditCommand::createusergroup() const {
  // @@protoc_insertion_point(field_get:auth.EditCommand.createusergroup)
  return _internal_createusergroup();
}
inline ::auth::EditCommand_CreateUserGroup* EditCommand::unsafe_arena_release_createusergroup() {
  // @@protoc_insertion_point(field_unsafe_arena_release:auth.EditCommand.createusergroup)
  if (_internal_has_createusergroup()) {
    clear_has_cmd();
    ::auth::EditCommand_CreateUserGroup* temp = _impl_.cmd_.createusergroup_;
    _impl_.cmd_.createusergroup_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EditCommand::unsafe_arena_set_allocated_createusergroup(::auth::EditCommand_CreateUserGroup* createusergroup) {
  clear_cmd();
  if (createusergroup) {
    set_has_createusergroup();
    _impl_.cmd_.createusergroup_ = createusergroup;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:auth.EditCommand.createusergroup)
}
inline ::auth::EditCommand_CreateUserGroup* EditCommand::_internal_mutable_createusergroup() {
  if (!_internal_has_createusergroup()) {
    clear_cmd();
    set_has_createusergroup();
    _impl_.cmd_.createusergroup_ = CreateMaybeMessage< ::auth::EditCommand_CreateUserGroup >(GetArenaForAllocation());
  }
  return _impl_.cmd_.createusergroup_;
}
inline ::auth::EditCommand_CreateUserGroup* EditCommand::mutable_createusergroup() {
  ::auth::EditCommand_CreateUserGroup* _msg = _internal_mutable_createusergroup();
  // @@protoc_insertion_point(field_mutable:auth.EditCommand.createusergroup)
  return _msg;
}

// .auth.GetUserGroupsReq getUserGroups = 9;
inline bool EditCommand::_internal_has_getusergroups() const {
  return cmd_case() == kGetUserGroups;
}
inline bool EditCommand::has_getusergroups() const {
  return _internal_has_getusergroups();
}
inline void EditCommand::set_has_getusergroups() {
  _impl_._oneof_case_[0] = kGetUserGroups;
}
inline void EditCommand::clear_getusergroups() {
  if (_internal_has_getusergroups()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.cmd_.getusergroups_;
    }
    clear_has_cmd();
  }
}
inline ::auth::GetUserGroupsReq* EditCommand::release_getusergroups() {
  // @@protoc_insertion_point(field_release:auth.EditCommand.getUserGroups)
  if (_internal_has_getusergroups()) {
    clear_has_cmd();
    ::auth::GetUserGroupsReq* temp = _impl_.cmd_.getusergroups_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.cmd_.getusergroups_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::auth::GetUserGroupsReq& EditCommand::_internal_getusergroups() const {
  return _internal_has_getusergroups()
      ? *_impl_.cmd_.getusergroups_
      : reinterpret_cast< ::auth::GetUserGroupsReq&>(::auth::_GetUserGroupsReq_default_instance_);
}
inline const ::auth::GetUserGroupsReq& EditCommand::getusergroups() const {
  // @@protoc_insertion_point(field_get:auth.EditCommand.getUserGroups)
  return _internal_getusergroups();
}
inline ::auth::GetUserGroupsReq* EditCommand::unsafe_arena_release_getusergroups() {
  // @@protoc_insertion_point(field_unsafe_arena_release:auth.EditCommand.getUserGroups)
  if (_internal_has_getusergroups()) {
    clear_has_cmd();
    ::auth::GetUserGroupsReq* temp = _impl_.cmd_.getusergroups_;
    _impl_.cmd_.getusergroups_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EditCommand::unsafe_arena_set_allocated_getusergroups(::auth::GetUserGroupsReq* getusergroups) {
  clear_cmd();
  if (getusergroups) {
    set_has_getusergroups();
    _impl_.cmd_.getusergroups_ = getusergroups;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:auth.EditCommand.getUserGroups)
}
inline ::auth::GetUserGroupsReq* EditCommand::_internal_mutable_getusergroups() {
  if (!_internal_has_getusergroups()) {
    clear_cmd();
    set_has_getusergroups();
    _impl_.cmd_.getusergroups_ = CreateMaybeMessage< ::auth::GetUserGroupsReq >(GetArenaForAllocation());
  }
  return _impl_.cmd_.getusergroups_;
}
inline ::auth::GetUserGroupsReq* EditCommand::mutable_getusergroups() {
  ::auth::GetUserGroupsReq* _msg = _internal_mutable_getusergroups();
  // @@protoc_insertion_point(field_mutable:auth.EditCommand.getUserGroups)
  return _msg;
}

// .auth.GetUsersByGroupReq getUsersByGroup = 10;
inline bool EditCommand::_internal_has_getusersbygroup() const {
  return cmd_case() == kGetUsersByGroup;
}
inline bool EditCommand::has_getusersbygroup() const {
  return _internal_has_getusersbygroup();
}
inline void EditCommand::set_has_getusersbygroup() {
  _impl_._oneof_case_[0] = kGetUsersByGroup;
}
inline void EditCommand::clear_getusersbygroup() {
  if (_internal_has_getusersbygroup()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.cmd_.getusersbygroup_;
    }
    clear_has_cmd();
  }
}
inline ::auth::GetUsersByGroupReq* EditCommand::release_getusersbygroup() {
  // @@protoc_insertion_point(field_release:auth.EditCommand.getUsersByGroup)
  if (_internal_has_getusersbygroup()) {
    clear_has_cmd();
    ::auth::GetUsersByGroupReq* temp = _impl_.cmd_.getusersbygroup_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.cmd_.getusersbygroup_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::auth::GetUsersByGroupReq& EditCommand::_internal_getusersbygroup() const {
  return _internal_has_getusersbygroup()
      ? *_impl_.cmd_.getusersbygroup_
      : reinterpret_cast< ::auth::GetUsersByGroupReq&>(::auth::_GetUsersByGroupReq_default_instance_);
}
inline const ::auth::GetUsersByGroupReq& EditCommand::getusersbygroup() const {
  // @@protoc_insertion_point(field_get:auth.EditCommand.getUsersByGroup)
  return _internal_getusersbygroup();
}
inline ::auth::GetUsersByGroupReq* EditCommand::unsafe_arena_release_getusersbygroup() {
  // @@protoc_insertion_point(field_unsafe_arena_release:auth.EditCommand.getUsersByGroup)
  if (_internal_has_getusersbygroup()) {
    clear_has_cmd();
    ::auth::GetUsersByGroupReq* temp = _impl_.cmd_.getusersbygroup_;
    _impl_.cmd_.getusersbygroup_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EditCommand::unsafe_arena_set_allocated_getusersbygroup(::auth::GetUsersByGroupReq* getusersbygroup) {
  clear_cmd();
  if (getusersbygroup) {
    set_has_getusersbygroup();
    _impl_.cmd_.getusersbygroup_ = getusersbygroup;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:auth.EditCommand.getUsersByGroup)
}
inline ::auth::GetUsersByGroupReq* EditCommand::_internal_mutable_getusersbygroup() {
  if (!_internal_has_getusersbygroup()) {
    clear_cmd();
    set_has_getusersbygroup();
    _impl_.cmd_.getusersbygroup_ = CreateMaybeMessage< ::auth::GetUsersByGroupReq >(GetArenaForAllocation());
  }
  return _impl_.cmd_.getusersbygroup_;
}
inline ::auth::GetUsersByGroupReq* EditCommand::mutable_getusersbygroup() {
  ::auth::GetUsersByGroupReq* _msg = _internal_mutable_getusersbygroup();
  // @@protoc_insertion_point(field_mutable:auth.EditCommand.getUsersByGroup)
  return _msg;
}

// .auth.EditCommand.GetTerminal getTerminal = 11;
inline bool EditCommand::_internal_has_getterminal() const {
  return cmd_case() == kGetTerminal;
}
inline bool EditCommand::has_getterminal() const {
  return _internal_has_getterminal();
}
inline void EditCommand::set_has_getterminal() {
  _impl_._oneof_case_[0] = kGetTerminal;
}
inline void EditCommand::clear_getterminal() {
  if (_internal_has_getterminal()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.cmd_.getterminal_;
    }
    clear_has_cmd();
  }
}
inline ::auth::EditCommand_GetTerminal* EditCommand::release_getterminal() {
  // @@protoc_insertion_point(field_release:auth.EditCommand.getTerminal)
  if (_internal_has_getterminal()) {
    clear_has_cmd();
    ::auth::EditCommand_GetTerminal* temp = _impl_.cmd_.getterminal_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.cmd_.getterminal_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::auth::EditCommand_GetTerminal& EditCommand::_internal_getterminal() const {
  return _internal_has_getterminal()
      ? *_impl_.cmd_.getterminal_
      : reinterpret_cast< ::auth::EditCommand_GetTerminal&>(::auth::_EditCommand_GetTerminal_default_instance_);
}
inline const ::auth::EditCommand_GetTerminal& EditCommand::getterminal() const {
  // @@protoc_insertion_point(field_get:auth.EditCommand.getTerminal)
  return _internal_getterminal();
}
inline ::auth::EditCommand_GetTerminal* EditCommand::unsafe_arena_release_getterminal() {
  // @@protoc_insertion_point(field_unsafe_arena_release:auth.EditCommand.getTerminal)
  if (_internal_has_getterminal()) {
    clear_has_cmd();
    ::auth::EditCommand_GetTerminal* temp = _impl_.cmd_.getterminal_;
    _impl_.cmd_.getterminal_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EditCommand::unsafe_arena_set_allocated_getterminal(::auth::EditCommand_GetTerminal* getterminal) {
  clear_cmd();
  if (getterminal) {
    set_has_getterminal();
    _impl_.cmd_.getterminal_ = getterminal;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:auth.EditCommand.getTerminal)
}
inline ::auth::EditCommand_GetTerminal* EditCommand::_internal_mutable_getterminal() {
  if (!_internal_has_getterminal()) {
    clear_cmd();
    set_has_getterminal();
    _impl_.cmd_.getterminal_ = CreateMaybeMessage< ::auth::EditCommand_GetTerminal >(GetArenaForAllocation());
  }
  return _impl_.cmd_.getterminal_;
}
inline ::auth::EditCommand_GetTerminal* EditCommand::mutable_getterminal() {
  ::auth::EditCommand_GetTerminal* _msg = _internal_mutable_getterminal();
  // @@protoc_insertion_point(field_mutable:auth.EditCommand.getTerminal)
  return _msg;
}

// .auth.EditCommand.UpdateTerminal updateTerminal = 12;
inline bool EditCommand::_internal_has_updateterminal() const {
  return cmd_case() == kUpdateTerminal;
}
inline bool EditCommand::has_updateterminal() const {
  return _internal_has_updateterminal();
}
inline void EditCommand::set_has_updateterminal() {
  _impl_._oneof_case_[0] = kUpdateTerminal;
}
inline void EditCommand::clear_updateterminal() {
  if (_internal_has_updateterminal()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.cmd_.updateterminal_;
    }
    clear_has_cmd();
  }
}
inline ::auth::EditCommand_UpdateTerminal* EditCommand::release_updateterminal() {
  // @@protoc_insertion_point(field_release:auth.EditCommand.updateTerminal)
  if (_internal_has_updateterminal()) {
    clear_has_cmd();
    ::auth::EditCommand_UpdateTerminal* temp = _impl_.cmd_.updateterminal_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.cmd_.updateterminal_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::auth::EditCommand_UpdateTerminal& EditCommand::_internal_updateterminal() const {
  return _internal_has_updateterminal()
      ? *_impl_.cmd_.updateterminal_
      : reinterpret_cast< ::auth::EditCommand_UpdateTerminal&>(::auth::_EditCommand_UpdateTerminal_default_instance_);
}
inline const ::auth::EditCommand_UpdateTerminal& EditCommand::updateterminal() const {
  // @@protoc_insertion_point(field_get:auth.EditCommand.updateTerminal)
  return _internal_updateterminal();
}
inline ::auth::EditCommand_UpdateTerminal* EditCommand::unsafe_arena_release_updateterminal() {
  // @@protoc_insertion_point(field_unsafe_arena_release:auth.EditCommand.updateTerminal)
  if (_internal_has_updateterminal()) {
    clear_has_cmd();
    ::auth::EditCommand_UpdateTerminal* temp = _impl_.cmd_.updateterminal_;
    _impl_.cmd_.updateterminal_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EditCommand::unsafe_arena_set_allocated_updateterminal(::auth::EditCommand_UpdateTerminal* updateterminal) {
  clear_cmd();
  if (updateterminal) {
    set_has_updateterminal();
    _impl_.cmd_.updateterminal_ = updateterminal;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:auth.EditCommand.updateTerminal)
}
inline ::auth::EditCommand_UpdateTerminal* EditCommand::_internal_mutable_updateterminal() {
  if (!_internal_has_updateterminal()) {
    clear_cmd();
    set_has_updateterminal();
    _impl_.cmd_.updateterminal_ = CreateMaybeMessage< ::auth::EditCommand_UpdateTerminal >(GetArenaForAllocation());
  }
  return _impl_.cmd_.updateterminal_;
}
inline ::auth::EditCommand_UpdateTerminal* EditCommand::mutable_updateterminal() {
  ::auth::EditCommand_UpdateTerminal* _msg = _internal_mutable_updateterminal();
  // @@protoc_insertion_point(field_mutable:auth.EditCommand.updateTerminal)
  return _msg;
}

// .auth.EditCommand.DeleteTerminal deleteTerminal = 13;
inline bool EditCommand::_internal_has_deleteterminal() const {
  return cmd_case() == kDeleteTerminal;
}
inline bool EditCommand::has_deleteterminal() const {
  return _internal_has_deleteterminal();
}
inline void EditCommand::set_has_deleteterminal() {
  _impl_._oneof_case_[0] = kDeleteTerminal;
}
inline void EditCommand::clear_deleteterminal() {
  if (_internal_has_deleteterminal()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.cmd_.deleteterminal_;
    }
    clear_has_cmd();
  }
}
inline ::auth::EditCommand_DeleteTerminal* EditCommand::release_deleteterminal() {
  // @@protoc_insertion_point(field_release:auth.EditCommand.deleteTerminal)
  if (_internal_has_deleteterminal()) {
    clear_has_cmd();
    ::auth::EditCommand_DeleteTerminal* temp = _impl_.cmd_.deleteterminal_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.cmd_.deleteterminal_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::auth::EditCommand_DeleteTerminal& EditCommand::_internal_deleteterminal() const {
  return _internal_has_deleteterminal()
      ? *_impl_.cmd_.deleteterminal_
      : reinterpret_cast< ::auth::EditCommand_DeleteTerminal&>(::auth::_EditCommand_DeleteTerminal_default_instance_);
}
inline const ::auth::EditCommand_DeleteTerminal& EditCommand::deleteterminal() const {
  // @@protoc_insertion_point(field_get:auth.EditCommand.deleteTerminal)
  return _internal_deleteterminal();
}
inline ::auth::EditCommand_DeleteTerminal* EditCommand::unsafe_arena_release_deleteterminal() {
  // @@protoc_insertion_point(field_unsafe_arena_release:auth.EditCommand.deleteTerminal)
  if (_internal_has_deleteterminal()) {
    clear_has_cmd();
    ::auth::EditCommand_DeleteTerminal* temp = _impl_.cmd_.deleteterminal_;
    _impl_.cmd_.deleteterminal_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EditCommand::unsafe_arena_set_allocated_deleteterminal(::auth::EditCommand_DeleteTerminal* deleteterminal) {
  clear_cmd();
  if (deleteterminal) {
    set_has_deleteterminal();
    _impl_.cmd_.deleteterminal_ = deleteterminal;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:auth.EditCommand.deleteTerminal)
}
inline ::auth::EditCommand_DeleteTerminal* EditCommand::_internal_mutable_deleteterminal() {
  if (!_internal_has_deleteterminal()) {
    clear_cmd();
    set_has_deleteterminal();
    _impl_.cmd_.deleteterminal_ = CreateMaybeMessage< ::auth::EditCommand_DeleteTerminal >(GetArenaForAllocation());
  }
  return _impl_.cmd_.deleteterminal_;
}
inline ::auth::EditCommand_DeleteTerminal* EditCommand::mutable_deleteterminal() {
  ::auth::EditCommand_DeleteTerminal* _msg = _internal_mutable_deleteterminal();
  // @@protoc_insertion_point(field_mutable:auth.EditCommand.deleteTerminal)
  return _msg;
}

// .auth.EditCommand.GetTerminals getTerminals = 14;
inline bool EditCommand::_internal_has_getterminals() const {
  return cmd_case() == kGetTerminals;
}
inline bool EditCommand::has_getterminals() const {
  return _internal_has_getterminals();
}
inline void EditCommand::set_has_getterminals() {
  _impl_._oneof_case_[0] = kGetTerminals;
}
inline void EditCommand::clear_getterminals() {
  if (_internal_has_getterminals()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.cmd_.getterminals_;
    }
    clear_has_cmd();
  }
}
inline ::auth::EditCommand_GetTerminals* EditCommand::release_getterminals() {
  // @@protoc_insertion_point(field_release:auth.EditCommand.getTerminals)
  if (_internal_has_getterminals()) {
    clear_has_cmd();
    ::auth::EditCommand_GetTerminals* temp = _impl_.cmd_.getterminals_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.cmd_.getterminals_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::auth::EditCommand_GetTerminals& EditCommand::_internal_getterminals() const {
  return _internal_has_getterminals()
      ? *_impl_.cmd_.getterminals_
      : reinterpret_cast< ::auth::EditCommand_GetTerminals&>(::auth::_EditCommand_GetTerminals_default_instance_);
}
inline const ::auth::EditCommand_GetTerminals& EditCommand::getterminals() const {
  // @@protoc_insertion_point(field_get:auth.EditCommand.getTerminals)
  return _internal_getterminals();
}
inline ::auth::EditCommand_GetTerminals* EditCommand::unsafe_arena_release_getterminals() {
  // @@protoc_insertion_point(field_unsafe_arena_release:auth.EditCommand.getTerminals)
  if (_internal_has_getterminals()) {
    clear_has_cmd();
    ::auth::EditCommand_GetTerminals* temp = _impl_.cmd_.getterminals_;
    _impl_.cmd_.getterminals_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EditCommand::unsafe_arena_set_allocated_getterminals(::auth::EditCommand_GetTerminals* getterminals) {
  clear_cmd();
  if (getterminals) {
    set_has_getterminals();
    _impl_.cmd_.getterminals_ = getterminals;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:auth.EditCommand.getTerminals)
}
inline ::auth::EditCommand_GetTerminals* EditCommand::_internal_mutable_getterminals() {
  if (!_internal_has_getterminals()) {
    clear_cmd();
    set_has_getterminals();
    _impl_.cmd_.getterminals_ = CreateMaybeMessage< ::auth::EditCommand_GetTerminals >(GetArenaForAllocation());
  }
  return _impl_.cmd_.getterminals_;
}
inline ::auth::EditCommand_GetTerminals* EditCommand::mutable_getterminals() {
  ::auth::EditCommand_GetTerminals* _msg = _internal_mutable_getterminals();
  // @@protoc_insertion_point(field_mutable:auth.EditCommand.getTerminals)
  return _msg;
}

// .auth.EditCommand.CreateTerminal createTerminal = 15;
inline bool EditCommand::_internal_has_createterminal() const {
  return cmd_case() == kCreateTerminal;
}
inline bool EditCommand::has_createterminal() const {
  return _internal_has_createterminal();
}
inline void EditCommand::set_has_createterminal() {
  _impl_._oneof_case_[0] = kCreateTerminal;
}
inline void EditCommand::clear_createterminal() {
  if (_internal_has_createterminal()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.cmd_.createterminal_;
    }
    clear_has_cmd();
  }
}
inline ::auth::EditCommand_CreateTerminal* EditCommand::release_createterminal() {
  // @@protoc_insertion_point(field_release:auth.EditCommand.createTerminal)
  if (_internal_has_createterminal()) {
    clear_has_cmd();
    ::auth::EditCommand_CreateTerminal* temp = _impl_.cmd_.createterminal_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.cmd_.createterminal_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::auth::EditCommand_CreateTerminal& EditCommand::_internal_createterminal() const {
  return _internal_has_createterminal()
      ? *_impl_.cmd_.createterminal_
      : reinterpret_cast< ::auth::EditCommand_CreateTerminal&>(::auth::_EditCommand_CreateTerminal_default_instance_);
}
inline const ::auth::EditCommand_CreateTerminal& EditCommand::createterminal() const {
  // @@protoc_insertion_point(field_get:auth.EditCommand.createTerminal)
  return _internal_createterminal();
}
inline ::auth::EditCommand_CreateTerminal* EditCommand::unsafe_arena_release_createterminal() {
  // @@protoc_insertion_point(field_unsafe_arena_release:auth.EditCommand.createTerminal)
  if (_internal_has_createterminal()) {
    clear_has_cmd();
    ::auth::EditCommand_CreateTerminal* temp = _impl_.cmd_.createterminal_;
    _impl_.cmd_.createterminal_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EditCommand::unsafe_arena_set_allocated_createterminal(::auth::EditCommand_CreateTerminal* createterminal) {
  clear_cmd();
  if (createterminal) {
    set_has_createterminal();
    _impl_.cmd_.createterminal_ = createterminal;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:auth.EditCommand.createTerminal)
}
inline ::auth::EditCommand_CreateTerminal* EditCommand::_internal_mutable_createterminal() {
  if (!_internal_has_createterminal()) {
    clear_cmd();
    set_has_createterminal();
    _impl_.cmd_.createterminal_ = CreateMaybeMessage< ::auth::EditCommand_CreateTerminal >(GetArenaForAllocation());
  }
  return _impl_.cmd_.createterminal_;
}
inline ::auth::EditCommand_CreateTerminal* EditCommand::mutable_createterminal() {
  ::auth::EditCommand_CreateTerminal* _msg = _internal_mutable_createterminal();
  // @@protoc_insertion_point(field_mutable:auth.EditCommand.createTerminal)
  return _msg;
}

// .auth.EditCommand.Save save = 16;
inline bool EditCommand::_internal_has_save() const {
  return cmd_case() == kSave;
}
inline bool EditCommand::has_save() const {
  return _internal_has_save();
}
inline void EditCommand::set_has_save() {
  _impl_._oneof_case_[0] = kSave;
}
inline void EditCommand::clear_save() {
  if (_internal_has_save()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.cmd_.save_;
    }
    clear_has_cmd();
  }
}
inline ::auth::EditCommand_Save* EditCommand::release_save() {
  // @@protoc_insertion_point(field_release:auth.EditCommand.save)
  if (_internal_has_save()) {
    clear_has_cmd();
    ::auth::EditCommand_Save* temp = _impl_.cmd_.save_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.cmd_.save_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::auth::EditCommand_Save& EditCommand::_internal_save() const {
  return _internal_has_save()
      ? *_impl_.cmd_.save_
      : reinterpret_cast< ::auth::EditCommand_Save&>(::auth::_EditCommand_Save_default_instance_);
}
inline const ::auth::EditCommand_Save& EditCommand::save() const {
  // @@protoc_insertion_point(field_get:auth.EditCommand.save)
  return _internal_save();
}
inline ::auth::EditCommand_Save* EditCommand::unsafe_arena_release_save() {
  // @@protoc_insertion_point(field_unsafe_arena_release:auth.EditCommand.save)
  if (_internal_has_save()) {
    clear_has_cmd();
    ::auth::EditCommand_Save* temp = _impl_.cmd_.save_;
    _impl_.cmd_.save_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EditCommand::unsafe_arena_set_allocated_save(::auth::EditCommand_Save* save) {
  clear_cmd();
  if (save) {
    set_has_save();
    _impl_.cmd_.save_ = save;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:auth.EditCommand.save)
}
inline ::auth::EditCommand_Save* EditCommand::_internal_mutable_save() {
  if (!_internal_has_save()) {
    clear_cmd();
    set_has_save();
    _impl_.cmd_.save_ = CreateMaybeMessage< ::auth::EditCommand_Save >(GetArenaForAllocation());
  }
  return _impl_.cmd_.save_;
}
inline ::auth::EditCommand_Save* EditCommand::mutable_save() {
  ::auth::EditCommand_Save* _msg = _internal_mutable_save();
  // @@protoc_insertion_point(field_mutable:auth.EditCommand.save)
  return _msg;
}

// .auth.EditCommand.Cancel cancel = 17;
inline bool EditCommand::_internal_has_cancel() const {
  return cmd_case() == kCancel;
}
inline bool EditCommand::has_cancel() const {
  return _internal_has_cancel();
}
inline void EditCommand::set_has_cancel() {
  _impl_._oneof_case_[0] = kCancel;
}
inline void EditCommand::clear_cancel() {
  if (_internal_has_cancel()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.cmd_.cancel_;
    }
    clear_has_cmd();
  }
}
inline ::auth::EditCommand_Cancel* EditCommand::release_cancel() {
  // @@protoc_insertion_point(field_release:auth.EditCommand.cancel)
  if (_internal_has_cancel()) {
    clear_has_cmd();
    ::auth::EditCommand_Cancel* temp = _impl_.cmd_.cancel_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.cmd_.cancel_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::auth::EditCommand_Cancel& EditCommand::_internal_cancel() const {
  return _internal_has_cancel()
      ? *_impl_.cmd_.cancel_
      : reinterpret_cast< ::auth::EditCommand_Cancel&>(::auth::_EditCommand_Cancel_default_instance_);
}
inline const ::auth::EditCommand_Cancel& EditCommand::cancel() const {
  // @@protoc_insertion_point(field_get:auth.EditCommand.cancel)
  return _internal_cancel();
}
inline ::auth::EditCommand_Cancel* EditCommand::unsafe_arena_release_cancel() {
  // @@protoc_insertion_point(field_unsafe_arena_release:auth.EditCommand.cancel)
  if (_internal_has_cancel()) {
    clear_has_cmd();
    ::auth::EditCommand_Cancel* temp = _impl_.cmd_.cancel_;
    _impl_.cmd_.cancel_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EditCommand::unsafe_arena_set_allocated_cancel(::auth::EditCommand_Cancel* cancel) {
  clear_cmd();
  if (cancel) {
    set_has_cancel();
    _impl_.cmd_.cancel_ = cancel;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:auth.EditCommand.cancel)
}
inline ::auth::EditCommand_Cancel* EditCommand::_internal_mutable_cancel() {
  if (!_internal_has_cancel()) {
    clear_cmd();
    set_has_cancel();
    _impl_.cmd_.cancel_ = CreateMaybeMessage< ::auth::EditCommand_Cancel >(GetArenaForAllocation());
  }
  return _impl_.cmd_.cancel_;
}
inline ::auth::EditCommand_Cancel* EditCommand::mutable_cancel() {
  ::auth::EditCommand_Cancel* _msg = _internal_mutable_cancel();
  // @@protoc_insertion_point(field_mutable:auth.EditCommand.cancel)
  return _msg;
}

inline bool EditCommand::has_cmd() const {
  return cmd_case() != CMD_NOT_SET;
}
inline void EditCommand::clear_has_cmd() {
  _impl_._oneof_case_[0] = CMD_NOT_SET;
}
inline EditCommand::CmdCase EditCommand::cmd_case() const {
  return EditCommand::CmdCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// EditResponse_TerminalsResp

// repeated .auth.Terminal terminals = 1;
inline int EditResponse_TerminalsResp::_internal_terminals_size() const {
  return _impl_.terminals_.size();
}
inline int EditResponse_TerminalsResp::terminals_size() const {
  return _internal_terminals_size();
}
inline void EditResponse_TerminalsResp::clear_terminals() {
  _impl_.terminals_.Clear();
}
inline ::auth::Terminal* EditResponse_TerminalsResp::mutable_terminals(int index) {
  // @@protoc_insertion_point(field_mutable:auth.EditResponse.TerminalsResp.terminals)
  return _impl_.terminals_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::auth::Terminal >*
EditResponse_TerminalsResp::mutable_terminals() {
  // @@protoc_insertion_point(field_mutable_list:auth.EditResponse.TerminalsResp.terminals)
  return &_impl_.terminals_;
}
inline const ::auth::Terminal& EditResponse_TerminalsResp::_internal_terminals(int index) const {
  return _impl_.terminals_.Get(index);
}
inline const ::auth::Terminal& EditResponse_TerminalsResp::terminals(int index) const {
  // @@protoc_insertion_point(field_get:auth.EditResponse.TerminalsResp.terminals)
  return _internal_terminals(index);
}
inline ::auth::Terminal* EditResponse_TerminalsResp::_internal_add_terminals() {
  return _impl_.terminals_.Add();
}
inline ::auth::Terminal* EditResponse_TerminalsResp::add_terminals() {
  ::auth::Terminal* _add = _internal_add_terminals();
  // @@protoc_insertion_point(field_add:auth.EditResponse.TerminalsResp.terminals)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::auth::Terminal >&
EditResponse_TerminalsResp::terminals() const {
  // @@protoc_insertion_point(field_list:auth.EditResponse.TerminalsResp.terminals)
  return _impl_.terminals_;
}

// .auth.PaginationResponse paginationresp = 2;
inline bool EditResponse_TerminalsResp::_internal_has_paginationresp() const {
  return this != internal_default_instance() && _impl_.paginationresp_ != nullptr;
}
inline bool EditResponse_TerminalsResp::has_paginationresp() const {
  return _internal_has_paginationresp();
}
inline void EditResponse_TerminalsResp::clear_paginationresp() {
  if (GetArenaForAllocation() == nullptr && _impl_.paginationresp_ != nullptr) {
    delete _impl_.paginationresp_;
  }
  _impl_.paginationresp_ = nullptr;
}
inline const ::auth::PaginationResponse& EditResponse_TerminalsResp::_internal_paginationresp() const {
  const ::auth::PaginationResponse* p = _impl_.paginationresp_;
  return p != nullptr ? *p : reinterpret_cast<const ::auth::PaginationResponse&>(
      ::auth::_PaginationResponse_default_instance_);
}
inline const ::auth::PaginationResponse& EditResponse_TerminalsResp::paginationresp() const {
  // @@protoc_insertion_point(field_get:auth.EditResponse.TerminalsResp.paginationresp)
  return _internal_paginationresp();
}
inline void EditResponse_TerminalsResp::unsafe_arena_set_allocated_paginationresp(
    ::auth::PaginationResponse* paginationresp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.paginationresp_);
  }
  _impl_.paginationresp_ = paginationresp;
  if (paginationresp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:auth.EditResponse.TerminalsResp.paginationresp)
}
inline ::auth::PaginationResponse* EditResponse_TerminalsResp::release_paginationresp() {
  
  ::auth::PaginationResponse* temp = _impl_.paginationresp_;
  _impl_.paginationresp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::auth::PaginationResponse* EditResponse_TerminalsResp::unsafe_arena_release_paginationresp() {
  // @@protoc_insertion_point(field_release:auth.EditResponse.TerminalsResp.paginationresp)
  
  ::auth::PaginationResponse* temp = _impl_.paginationresp_;
  _impl_.paginationresp_ = nullptr;
  return temp;
}
inline ::auth::PaginationResponse* EditResponse_TerminalsResp::_internal_mutable_paginationresp() {
  
  if (_impl_.paginationresp_ == nullptr) {
    auto* p = CreateMaybeMessage<::auth::PaginationResponse>(GetArenaForAllocation());
    _impl_.paginationresp_ = p;
  }
  return _impl_.paginationresp_;
}
inline ::auth::PaginationResponse* EditResponse_TerminalsResp::mutable_paginationresp() {
  ::auth::PaginationResponse* _msg = _internal_mutable_paginationresp();
  // @@protoc_insertion_point(field_mutable:auth.EditResponse.TerminalsResp.paginationresp)
  return _msg;
}
inline void EditResponse_TerminalsResp::set_allocated_paginationresp(::auth::PaginationResponse* paginationresp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.paginationresp_;
  }
  if (paginationresp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(paginationresp);
    if (message_arena != submessage_arena) {
      paginationresp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, paginationresp, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.paginationresp_ = paginationresp;
  // @@protoc_insertion_point(field_set_allocated:auth.EditResponse.TerminalsResp.paginationresp)
}

// -------------------------------------------------------------------

// EditResponse_Error

// uint64 code = 1;
inline void EditResponse_Error::clear_code() {
  _impl_.code_ = uint64_t{0u};
}
inline uint64_t EditResponse_Error::_internal_code() const {
  return _impl_.code_;
}
inline uint64_t EditResponse_Error::code() const {
  // @@protoc_insertion_point(field_get:auth.EditResponse.Error.code)
  return _internal_code();
}
inline void EditResponse_Error::_internal_set_code(uint64_t value) {
  
  _impl_.code_ = value;
}
inline void EditResponse_Error::set_code(uint64_t value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:auth.EditResponse.Error.code)
}

// string message = 2;
inline void EditResponse_Error::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& EditResponse_Error::message() const {
  // @@protoc_insertion_point(field_get:auth.EditResponse.Error.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EditResponse_Error::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:auth.EditResponse.Error.message)
}
inline std::string* EditResponse_Error::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:auth.EditResponse.Error.message)
  return _s;
}
inline const std::string& EditResponse_Error::_internal_message() const {
  return _impl_.message_.Get();
}
inline void EditResponse_Error::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* EditResponse_Error::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* EditResponse_Error::release_message() {
  // @@protoc_insertion_point(field_release:auth.EditResponse.Error.message)
  return _impl_.message_.Release();
}
inline void EditResponse_Error::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:auth.EditResponse.Error.message)
}

// -------------------------------------------------------------------

// EditResponse_GetUser

// optional .auth.User user = 1;
inline bool EditResponse_GetUser::_internal_has_user() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.user_ != nullptr);
  return value;
}
inline bool EditResponse_GetUser::has_user() const {
  return _internal_has_user();
}
inline void EditResponse_GetUser::clear_user() {
  if (_impl_.user_ != nullptr) _impl_.user_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::auth::User& EditResponse_GetUser::_internal_user() const {
  const ::auth::User* p = _impl_.user_;
  return p != nullptr ? *p : reinterpret_cast<const ::auth::User&>(
      ::auth::_User_default_instance_);
}
inline const ::auth::User& EditResponse_GetUser::user() const {
  // @@protoc_insertion_point(field_get:auth.EditResponse.GetUser.user)
  return _internal_user();
}
inline void EditResponse_GetUser::unsafe_arena_set_allocated_user(
    ::auth::User* user) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.user_);
  }
  _impl_.user_ = user;
  if (user) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:auth.EditResponse.GetUser.user)
}
inline ::auth::User* EditResponse_GetUser::release_user() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::auth::User* temp = _impl_.user_;
  _impl_.user_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::auth::User* EditResponse_GetUser::unsafe_arena_release_user() {
  // @@protoc_insertion_point(field_release:auth.EditResponse.GetUser.user)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::auth::User* temp = _impl_.user_;
  _impl_.user_ = nullptr;
  return temp;
}
inline ::auth::User* EditResponse_GetUser::_internal_mutable_user() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.user_ == nullptr) {
    auto* p = CreateMaybeMessage<::auth::User>(GetArenaForAllocation());
    _impl_.user_ = p;
  }
  return _impl_.user_;
}
inline ::auth::User* EditResponse_GetUser::mutable_user() {
  ::auth::User* _msg = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:auth.EditResponse.GetUser.user)
  return _msg;
}
inline void EditResponse_GetUser::set_allocated_user(::auth::User* user) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.user_;
  }
  if (user) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(user);
    if (message_arena != submessage_arena) {
      user = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.user_ = user;
  // @@protoc_insertion_point(field_set_allocated:auth.EditResponse.GetUser.user)
}

// optional .auth.EditResponse.Error error = 2;
inline bool EditResponse_GetUser::_internal_has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.error_ != nullptr);
  return value;
}
inline bool EditResponse_GetUser::has_error() const {
  return _internal_has_error();
}
inline void EditResponse_GetUser::clear_error() {
  if (_impl_.error_ != nullptr) _impl_.error_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::auth::EditResponse_Error& EditResponse_GetUser::_internal_error() const {
  const ::auth::EditResponse_Error* p = _impl_.error_;
  return p != nullptr ? *p : reinterpret_cast<const ::auth::EditResponse_Error&>(
      ::auth::_EditResponse_Error_default_instance_);
}
inline const ::auth::EditResponse_Error& EditResponse_GetUser::error() const {
  // @@protoc_insertion_point(field_get:auth.EditResponse.GetUser.error)
  return _internal_error();
}
inline void EditResponse_GetUser::unsafe_arena_set_allocated_error(
    ::auth::EditResponse_Error* error) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.error_);
  }
  _impl_.error_ = error;
  if (error) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:auth.EditResponse.GetUser.error)
}
inline ::auth::EditResponse_Error* EditResponse_GetUser::release_error() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::auth::EditResponse_Error* temp = _impl_.error_;
  _impl_.error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::auth::EditResponse_Error* EditResponse_GetUser::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_release:auth.EditResponse.GetUser.error)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::auth::EditResponse_Error* temp = _impl_.error_;
  _impl_.error_ = nullptr;
  return temp;
}
inline ::auth::EditResponse_Error* EditResponse_GetUser::_internal_mutable_error() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.error_ == nullptr) {
    auto* p = CreateMaybeMessage<::auth::EditResponse_Error>(GetArenaForAllocation());
    _impl_.error_ = p;
  }
  return _impl_.error_;
}
inline ::auth::EditResponse_Error* EditResponse_GetUser::mutable_error() {
  ::auth::EditResponse_Error* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:auth.EditResponse.GetUser.error)
  return _msg;
}
inline void EditResponse_GetUser::set_allocated_error(::auth::EditResponse_Error* error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.error_;
  }
  if (error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(error);
    if (message_arena != submessage_arena) {
      error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.error_ = error;
  // @@protoc_insertion_point(field_set_allocated:auth.EditResponse.GetUser.error)
}

// -------------------------------------------------------------------

// EditResponse_GetUserGroup

// optional .auth.UserGroup group = 1;
inline bool EditResponse_GetUserGroup::_internal_has_group() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.group_ != nullptr);
  return value;
}
inline bool EditResponse_GetUserGroup::has_group() const {
  return _internal_has_group();
}
inline void EditResponse_GetUserGroup::clear_group() {
  if (_impl_.group_ != nullptr) _impl_.group_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::auth::UserGroup& EditResponse_GetUserGroup::_internal_group() const {
  const ::auth::UserGroup* p = _impl_.group_;
  return p != nullptr ? *p : reinterpret_cast<const ::auth::UserGroup&>(
      ::auth::_UserGroup_default_instance_);
}
inline const ::auth::UserGroup& EditResponse_GetUserGroup::group() const {
  // @@protoc_insertion_point(field_get:auth.EditResponse.GetUserGroup.group)
  return _internal_group();
}
inline void EditResponse_GetUserGroup::unsafe_arena_set_allocated_group(
    ::auth::UserGroup* group) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.group_);
  }
  _impl_.group_ = group;
  if (group) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:auth.EditResponse.GetUserGroup.group)
}
inline ::auth::UserGroup* EditResponse_GetUserGroup::release_group() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::auth::UserGroup* temp = _impl_.group_;
  _impl_.group_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::auth::UserGroup* EditResponse_GetUserGroup::unsafe_arena_release_group() {
  // @@protoc_insertion_point(field_release:auth.EditResponse.GetUserGroup.group)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::auth::UserGroup* temp = _impl_.group_;
  _impl_.group_ = nullptr;
  return temp;
}
inline ::auth::UserGroup* EditResponse_GetUserGroup::_internal_mutable_group() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.group_ == nullptr) {
    auto* p = CreateMaybeMessage<::auth::UserGroup>(GetArenaForAllocation());
    _impl_.group_ = p;
  }
  return _impl_.group_;
}
inline ::auth::UserGroup* EditResponse_GetUserGroup::mutable_group() {
  ::auth::UserGroup* _msg = _internal_mutable_group();
  // @@protoc_insertion_point(field_mutable:auth.EditResponse.GetUserGroup.group)
  return _msg;
}
inline void EditResponse_GetUserGroup::set_allocated_group(::auth::UserGroup* group) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.group_;
  }
  if (group) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(group);
    if (message_arena != submessage_arena) {
      group = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, group, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.group_ = group;
  // @@protoc_insertion_point(field_set_allocated:auth.EditResponse.GetUserGroup.group)
}

// optional .auth.EditResponse.Error error = 2;
inline bool EditResponse_GetUserGroup::_internal_has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.error_ != nullptr);
  return value;
}
inline bool EditResponse_GetUserGroup::has_error() const {
  return _internal_has_error();
}
inline void EditResponse_GetUserGroup::clear_error() {
  if (_impl_.error_ != nullptr) _impl_.error_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::auth::EditResponse_Error& EditResponse_GetUserGroup::_internal_error() const {
  const ::auth::EditResponse_Error* p = _impl_.error_;
  return p != nullptr ? *p : reinterpret_cast<const ::auth::EditResponse_Error&>(
      ::auth::_EditResponse_Error_default_instance_);
}
inline const ::auth::EditResponse_Error& EditResponse_GetUserGroup::error() const {
  // @@protoc_insertion_point(field_get:auth.EditResponse.GetUserGroup.error)
  return _internal_error();
}
inline void EditResponse_GetUserGroup::unsafe_arena_set_allocated_error(
    ::auth::EditResponse_Error* error) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.error_);
  }
  _impl_.error_ = error;
  if (error) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:auth.EditResponse.GetUserGroup.error)
}
inline ::auth::EditResponse_Error* EditResponse_GetUserGroup::release_error() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::auth::EditResponse_Error* temp = _impl_.error_;
  _impl_.error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::auth::EditResponse_Error* EditResponse_GetUserGroup::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_release:auth.EditResponse.GetUserGroup.error)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::auth::EditResponse_Error* temp = _impl_.error_;
  _impl_.error_ = nullptr;
  return temp;
}
inline ::auth::EditResponse_Error* EditResponse_GetUserGroup::_internal_mutable_error() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.error_ == nullptr) {
    auto* p = CreateMaybeMessage<::auth::EditResponse_Error>(GetArenaForAllocation());
    _impl_.error_ = p;
  }
  return _impl_.error_;
}
inline ::auth::EditResponse_Error* EditResponse_GetUserGroup::mutable_error() {
  ::auth::EditResponse_Error* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:auth.EditResponse.GetUserGroup.error)
  return _msg;
}
inline void EditResponse_GetUserGroup::set_allocated_error(::auth::EditResponse_Error* error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.error_;
  }
  if (error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(error);
    if (message_arena != submessage_arena) {
      error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.error_ = error;
  // @@protoc_insertion_point(field_set_allocated:auth.EditResponse.GetUserGroup.error)
}

// -------------------------------------------------------------------

// EditResponse_UpdateUser

// optional .auth.User user = 1;
inline bool EditResponse_UpdateUser::_internal_has_user() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.user_ != nullptr);
  return value;
}
inline bool EditResponse_UpdateUser::has_user() const {
  return _internal_has_user();
}
inline void EditResponse_UpdateUser::clear_user() {
  if (_impl_.user_ != nullptr) _impl_.user_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::auth::User& EditResponse_UpdateUser::_internal_user() const {
  const ::auth::User* p = _impl_.user_;
  return p != nullptr ? *p : reinterpret_cast<const ::auth::User&>(
      ::auth::_User_default_instance_);
}
inline const ::auth::User& EditResponse_UpdateUser::user() const {
  // @@protoc_insertion_point(field_get:auth.EditResponse.UpdateUser.user)
  return _internal_user();
}
inline void EditResponse_UpdateUser::unsafe_arena_set_allocated_user(
    ::auth::User* user) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.user_);
  }
  _impl_.user_ = user;
  if (user) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:auth.EditResponse.UpdateUser.user)
}
inline ::auth::User* EditResponse_UpdateUser::release_user() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::auth::User* temp = _impl_.user_;
  _impl_.user_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::auth::User* EditResponse_UpdateUser::unsafe_arena_release_user() {
  // @@protoc_insertion_point(field_release:auth.EditResponse.UpdateUser.user)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::auth::User* temp = _impl_.user_;
  _impl_.user_ = nullptr;
  return temp;
}
inline ::auth::User* EditResponse_UpdateUser::_internal_mutable_user() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.user_ == nullptr) {
    auto* p = CreateMaybeMessage<::auth::User>(GetArenaForAllocation());
    _impl_.user_ = p;
  }
  return _impl_.user_;
}
inline ::auth::User* EditResponse_UpdateUser::mutable_user() {
  ::auth::User* _msg = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:auth.EditResponse.UpdateUser.user)
  return _msg;
}
inline void EditResponse_UpdateUser::set_allocated_user(::auth::User* user) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.user_;
  }
  if (user) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(user);
    if (message_arena != submessage_arena) {
      user = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.user_ = user;
  // @@protoc_insertion_point(field_set_allocated:auth.EditResponse.UpdateUser.user)
}

// optional .auth.EditResponse.Error error = 2;
inline bool EditResponse_UpdateUser::_internal_has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.error_ != nullptr);
  return value;
}
inline bool EditResponse_UpdateUser::has_error() const {
  return _internal_has_error();
}
inline void EditResponse_UpdateUser::clear_error() {
  if (_impl_.error_ != nullptr) _impl_.error_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::auth::EditResponse_Error& EditResponse_UpdateUser::_internal_error() const {
  const ::auth::EditResponse_Error* p = _impl_.error_;
  return p != nullptr ? *p : reinterpret_cast<const ::auth::EditResponse_Error&>(
      ::auth::_EditResponse_Error_default_instance_);
}
inline const ::auth::EditResponse_Error& EditResponse_UpdateUser::error() const {
  // @@protoc_insertion_point(field_get:auth.EditResponse.UpdateUser.error)
  return _internal_error();
}
inline void EditResponse_UpdateUser::unsafe_arena_set_allocated_error(
    ::auth::EditResponse_Error* error) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.error_);
  }
  _impl_.error_ = error;
  if (error) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:auth.EditResponse.UpdateUser.error)
}
inline ::auth::EditResponse_Error* EditResponse_UpdateUser::release_error() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::auth::EditResponse_Error* temp = _impl_.error_;
  _impl_.error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::auth::EditResponse_Error* EditResponse_UpdateUser::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_release:auth.EditResponse.UpdateUser.error)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::auth::EditResponse_Error* temp = _impl_.error_;
  _impl_.error_ = nullptr;
  return temp;
}
inline ::auth::EditResponse_Error* EditResponse_UpdateUser::_internal_mutable_error() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.error_ == nullptr) {
    auto* p = CreateMaybeMessage<::auth::EditResponse_Error>(GetArenaForAllocation());
    _impl_.error_ = p;
  }
  return _impl_.error_;
}
inline ::auth::EditResponse_Error* EditResponse_UpdateUser::mutable_error() {
  ::auth::EditResponse_Error* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:auth.EditResponse.UpdateUser.error)
  return _msg;
}
inline void EditResponse_UpdateUser::set_allocated_error(::auth::EditResponse_Error* error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.error_;
  }
  if (error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(error);
    if (message_arena != submessage_arena) {
      error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.error_ = error;
  // @@protoc_insertion_point(field_set_allocated:auth.EditResponse.UpdateUser.error)
}

// -------------------------------------------------------------------

// EditResponse_UpdateUserGroup

// optional .auth.UserGroup group = 1;
inline bool EditResponse_UpdateUserGroup::_internal_has_group() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.group_ != nullptr);
  return value;
}
inline bool EditResponse_UpdateUserGroup::has_group() const {
  return _internal_has_group();
}
inline void EditResponse_UpdateUserGroup::clear_group() {
  if (_impl_.group_ != nullptr) _impl_.group_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::auth::UserGroup& EditResponse_UpdateUserGroup::_internal_group() const {
  const ::auth::UserGroup* p = _impl_.group_;
  return p != nullptr ? *p : reinterpret_cast<const ::auth::UserGroup&>(
      ::auth::_UserGroup_default_instance_);
}
inline const ::auth::UserGroup& EditResponse_UpdateUserGroup::group() const {
  // @@protoc_insertion_point(field_get:auth.EditResponse.UpdateUserGroup.group)
  return _internal_group();
}
inline void EditResponse_UpdateUserGroup::unsafe_arena_set_allocated_group(
    ::auth::UserGroup* group) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.group_);
  }
  _impl_.group_ = group;
  if (group) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:auth.EditResponse.UpdateUserGroup.group)
}
inline ::auth::UserGroup* EditResponse_UpdateUserGroup::release_group() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::auth::UserGroup* temp = _impl_.group_;
  _impl_.group_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::auth::UserGroup* EditResponse_UpdateUserGroup::unsafe_arena_release_group() {
  // @@protoc_insertion_point(field_release:auth.EditResponse.UpdateUserGroup.group)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::auth::UserGroup* temp = _impl_.group_;
  _impl_.group_ = nullptr;
  return temp;
}
inline ::auth::UserGroup* EditResponse_UpdateUserGroup::_internal_mutable_group() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.group_ == nullptr) {
    auto* p = CreateMaybeMessage<::auth::UserGroup>(GetArenaForAllocation());
    _impl_.group_ = p;
  }
  return _impl_.group_;
}
inline ::auth::UserGroup* EditResponse_UpdateUserGroup::mutable_group() {
  ::auth::UserGroup* _msg = _internal_mutable_group();
  // @@protoc_insertion_point(field_mutable:auth.EditResponse.UpdateUserGroup.group)
  return _msg;
}
inline void EditResponse_UpdateUserGroup::set_allocated_group(::auth::UserGroup* group) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.group_;
  }
  if (group) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(group);
    if (message_arena != submessage_arena) {
      group = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, group, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.group_ = group;
  // @@protoc_insertion_point(field_set_allocated:auth.EditResponse.UpdateUserGroup.group)
}

// optional .auth.EditResponse.Error error = 2;
inline bool EditResponse_UpdateUserGroup::_internal_has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.error_ != nullptr);
  return value;
}
inline bool EditResponse_UpdateUserGroup::has_error() const {
  return _internal_has_error();
}
inline void EditResponse_UpdateUserGroup::clear_error() {
  if (_impl_.error_ != nullptr) _impl_.error_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::auth::EditResponse_Error& EditResponse_UpdateUserGroup::_internal_error() const {
  const ::auth::EditResponse_Error* p = _impl_.error_;
  return p != nullptr ? *p : reinterpret_cast<const ::auth::EditResponse_Error&>(
      ::auth::_EditResponse_Error_default_instance_);
}
inline const ::auth::EditResponse_Error& EditResponse_UpdateUserGroup::error() const {
  // @@protoc_insertion_point(field_get:auth.EditResponse.UpdateUserGroup.error)
  return _internal_error();
}
inline void EditResponse_UpdateUserGroup::unsafe_arena_set_allocated_error(
    ::auth::EditResponse_Error* error) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.error_);
  }
  _impl_.error_ = error;
  if (error) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:auth.EditResponse.UpdateUserGroup.error)
}
inline ::auth::EditResponse_Error* EditResponse_UpdateUserGroup::release_error() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::auth::EditResponse_Error* temp = _impl_.error_;
  _impl_.error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::auth::EditResponse_Error* EditResponse_UpdateUserGroup::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_release:auth.EditResponse.UpdateUserGroup.error)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::auth::EditResponse_Error* temp = _impl_.error_;
  _impl_.error_ = nullptr;
  return temp;
}
inline ::auth::EditResponse_Error* EditResponse_UpdateUserGroup::_internal_mutable_error() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.error_ == nullptr) {
    auto* p = CreateMaybeMessage<::auth::EditResponse_Error>(GetArenaForAllocation());
    _impl_.error_ = p;
  }
  return _impl_.error_;
}
inline ::auth::EditResponse_Error* EditResponse_UpdateUserGroup::mutable_error() {
  ::auth::EditResponse_Error* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:auth.EditResponse.UpdateUserGroup.error)
  return _msg;
}
inline void EditResponse_UpdateUserGroup::set_allocated_error(::auth::EditResponse_Error* error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.error_;
  }
  if (error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(error);
    if (message_arena != submessage_arena) {
      error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.error_ = error;
  // @@protoc_insertion_point(field_set_allocated:auth.EditResponse.UpdateUserGroup.error)
}

// -------------------------------------------------------------------

// EditResponse_DeleteUser

// optional .auth.EditResponse.Error error = 1;
inline bool EditResponse_DeleteUser::_internal_has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.error_ != nullptr);
  return value;
}
inline bool EditResponse_DeleteUser::has_error() const {
  return _internal_has_error();
}
inline void EditResponse_DeleteUser::clear_error() {
  if (_impl_.error_ != nullptr) _impl_.error_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::auth::EditResponse_Error& EditResponse_DeleteUser::_internal_error() const {
  const ::auth::EditResponse_Error* p = _impl_.error_;
  return p != nullptr ? *p : reinterpret_cast<const ::auth::EditResponse_Error&>(
      ::auth::_EditResponse_Error_default_instance_);
}
inline const ::auth::EditResponse_Error& EditResponse_DeleteUser::error() const {
  // @@protoc_insertion_point(field_get:auth.EditResponse.DeleteUser.error)
  return _internal_error();
}
inline void EditResponse_DeleteUser::unsafe_arena_set_allocated_error(
    ::auth::EditResponse_Error* error) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.error_);
  }
  _impl_.error_ = error;
  if (error) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:auth.EditResponse.DeleteUser.error)
}
inline ::auth::EditResponse_Error* EditResponse_DeleteUser::release_error() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::auth::EditResponse_Error* temp = _impl_.error_;
  _impl_.error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::auth::EditResponse_Error* EditResponse_DeleteUser::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_release:auth.EditResponse.DeleteUser.error)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::auth::EditResponse_Error* temp = _impl_.error_;
  _impl_.error_ = nullptr;
  return temp;
}
inline ::auth::EditResponse_Error* EditResponse_DeleteUser::_internal_mutable_error() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.error_ == nullptr) {
    auto* p = CreateMaybeMessage<::auth::EditResponse_Error>(GetArenaForAllocation());
    _impl_.error_ = p;
  }
  return _impl_.error_;
}
inline ::auth::EditResponse_Error* EditResponse_DeleteUser::mutable_error() {
  ::auth::EditResponse_Error* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:auth.EditResponse.DeleteUser.error)
  return _msg;
}
inline void EditResponse_DeleteUser::set_allocated_error(::auth::EditResponse_Error* error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.error_;
  }
  if (error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(error);
    if (message_arena != submessage_arena) {
      error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.error_ = error;
  // @@protoc_insertion_point(field_set_allocated:auth.EditResponse.DeleteUser.error)
}

// -------------------------------------------------------------------

// EditResponse_DeleteUserGroup

// optional .auth.EditResponse.Error error = 1;
inline bool EditResponse_DeleteUserGroup::_internal_has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.error_ != nullptr);
  return value;
}
inline bool EditResponse_DeleteUserGroup::has_error() const {
  return _internal_has_error();
}
inline void EditResponse_DeleteUserGroup::clear_error() {
  if (_impl_.error_ != nullptr) _impl_.error_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::auth::EditResponse_Error& EditResponse_DeleteUserGroup::_internal_error() const {
  const ::auth::EditResponse_Error* p = _impl_.error_;
  return p != nullptr ? *p : reinterpret_cast<const ::auth::EditResponse_Error&>(
      ::auth::_EditResponse_Error_default_instance_);
}
inline const ::auth::EditResponse_Error& EditResponse_DeleteUserGroup::error() const {
  // @@protoc_insertion_point(field_get:auth.EditResponse.DeleteUserGroup.error)
  return _internal_error();
}
inline void EditResponse_DeleteUserGroup::unsafe_arena_set_allocated_error(
    ::auth::EditResponse_Error* error) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.error_);
  }
  _impl_.error_ = error;
  if (error) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:auth.EditResponse.DeleteUserGroup.error)
}
inline ::auth::EditResponse_Error* EditResponse_DeleteUserGroup::release_error() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::auth::EditResponse_Error* temp = _impl_.error_;
  _impl_.error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::auth::EditResponse_Error* EditResponse_DeleteUserGroup::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_release:auth.EditResponse.DeleteUserGroup.error)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::auth::EditResponse_Error* temp = _impl_.error_;
  _impl_.error_ = nullptr;
  return temp;
}
inline ::auth::EditResponse_Error* EditResponse_DeleteUserGroup::_internal_mutable_error() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.error_ == nullptr) {
    auto* p = CreateMaybeMessage<::auth::EditResponse_Error>(GetArenaForAllocation());
    _impl_.error_ = p;
  }
  return _impl_.error_;
}
inline ::auth::EditResponse_Error* EditResponse_DeleteUserGroup::mutable_error() {
  ::auth::EditResponse_Error* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:auth.EditResponse.DeleteUserGroup.error)
  return _msg;
}
inline void EditResponse_DeleteUserGroup::set_allocated_error(::auth::EditResponse_Error* error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.error_;
  }
  if (error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(error);
    if (message_arena != submessage_arena) {
      error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.error_ = error;
  // @@protoc_insertion_point(field_set_allocated:auth.EditResponse.DeleteUserGroup.error)
}

// -------------------------------------------------------------------

// EditResponse_CreateUser

// optional .auth.User user = 1;
inline bool EditResponse_CreateUser::_internal_has_user() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.user_ != nullptr);
  return value;
}
inline bool EditResponse_CreateUser::has_user() const {
  return _internal_has_user();
}
inline void EditResponse_CreateUser::clear_user() {
  if (_impl_.user_ != nullptr) _impl_.user_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::auth::User& EditResponse_CreateUser::_internal_user() const {
  const ::auth::User* p = _impl_.user_;
  return p != nullptr ? *p : reinterpret_cast<const ::auth::User&>(
      ::auth::_User_default_instance_);
}
inline const ::auth::User& EditResponse_CreateUser::user() const {
  // @@protoc_insertion_point(field_get:auth.EditResponse.CreateUser.user)
  return _internal_user();
}
inline void EditResponse_CreateUser::unsafe_arena_set_allocated_user(
    ::auth::User* user) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.user_);
  }
  _impl_.user_ = user;
  if (user) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:auth.EditResponse.CreateUser.user)
}
inline ::auth::User* EditResponse_CreateUser::release_user() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::auth::User* temp = _impl_.user_;
  _impl_.user_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::auth::User* EditResponse_CreateUser::unsafe_arena_release_user() {
  // @@protoc_insertion_point(field_release:auth.EditResponse.CreateUser.user)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::auth::User* temp = _impl_.user_;
  _impl_.user_ = nullptr;
  return temp;
}
inline ::auth::User* EditResponse_CreateUser::_internal_mutable_user() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.user_ == nullptr) {
    auto* p = CreateMaybeMessage<::auth::User>(GetArenaForAllocation());
    _impl_.user_ = p;
  }
  return _impl_.user_;
}
inline ::auth::User* EditResponse_CreateUser::mutable_user() {
  ::auth::User* _msg = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:auth.EditResponse.CreateUser.user)
  return _msg;
}
inline void EditResponse_CreateUser::set_allocated_user(::auth::User* user) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.user_;
  }
  if (user) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(user);
    if (message_arena != submessage_arena) {
      user = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.user_ = user;
  // @@protoc_insertion_point(field_set_allocated:auth.EditResponse.CreateUser.user)
}

// optional .auth.EditResponse.Error error = 2;
inline bool EditResponse_CreateUser::_internal_has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.error_ != nullptr);
  return value;
}
inline bool EditResponse_CreateUser::has_error() const {
  return _internal_has_error();
}
inline void EditResponse_CreateUser::clear_error() {
  if (_impl_.error_ != nullptr) _impl_.error_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::auth::EditResponse_Error& EditResponse_CreateUser::_internal_error() const {
  const ::auth::EditResponse_Error* p = _impl_.error_;
  return p != nullptr ? *p : reinterpret_cast<const ::auth::EditResponse_Error&>(
      ::auth::_EditResponse_Error_default_instance_);
}
inline const ::auth::EditResponse_Error& EditResponse_CreateUser::error() const {
  // @@protoc_insertion_point(field_get:auth.EditResponse.CreateUser.error)
  return _internal_error();
}
inline void EditResponse_CreateUser::unsafe_arena_set_allocated_error(
    ::auth::EditResponse_Error* error) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.error_);
  }
  _impl_.error_ = error;
  if (error) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:auth.EditResponse.CreateUser.error)
}
inline ::auth::EditResponse_Error* EditResponse_CreateUser::release_error() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::auth::EditResponse_Error* temp = _impl_.error_;
  _impl_.error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::auth::EditResponse_Error* EditResponse_CreateUser::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_release:auth.EditResponse.CreateUser.error)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::auth::EditResponse_Error* temp = _impl_.error_;
  _impl_.error_ = nullptr;
  return temp;
}
inline ::auth::EditResponse_Error* EditResponse_CreateUser::_internal_mutable_error() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.error_ == nullptr) {
    auto* p = CreateMaybeMessage<::auth::EditResponse_Error>(GetArenaForAllocation());
    _impl_.error_ = p;
  }
  return _impl_.error_;
}
inline ::auth::EditResponse_Error* EditResponse_CreateUser::mutable_error() {
  ::auth::EditResponse_Error* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:auth.EditResponse.CreateUser.error)
  return _msg;
}
inline void EditResponse_CreateUser::set_allocated_error(::auth::EditResponse_Error* error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.error_;
  }
  if (error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(error);
    if (message_arena != submessage_arena) {
      error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.error_ = error;
  // @@protoc_insertion_point(field_set_allocated:auth.EditResponse.CreateUser.error)
}

// -------------------------------------------------------------------

// EditResponse_CreateUserGroup

// optional .auth.UserGroup group = 1;
inline bool EditResponse_CreateUserGroup::_internal_has_group() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.group_ != nullptr);
  return value;
}
inline bool EditResponse_CreateUserGroup::has_group() const {
  return _internal_has_group();
}
inline void EditResponse_CreateUserGroup::clear_group() {
  if (_impl_.group_ != nullptr) _impl_.group_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::auth::UserGroup& EditResponse_CreateUserGroup::_internal_group() const {
  const ::auth::UserGroup* p = _impl_.group_;
  return p != nullptr ? *p : reinterpret_cast<const ::auth::UserGroup&>(
      ::auth::_UserGroup_default_instance_);
}
inline const ::auth::UserGroup& EditResponse_CreateUserGroup::group() const {
  // @@protoc_insertion_point(field_get:auth.EditResponse.CreateUserGroup.group)
  return _internal_group();
}
inline void EditResponse_CreateUserGroup::unsafe_arena_set_allocated_group(
    ::auth::UserGroup* group) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.group_);
  }
  _impl_.group_ = group;
  if (group) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:auth.EditResponse.CreateUserGroup.group)
}
inline ::auth::UserGroup* EditResponse_CreateUserGroup::release_group() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::auth::UserGroup* temp = _impl_.group_;
  _impl_.group_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::auth::UserGroup* EditResponse_CreateUserGroup::unsafe_arena_release_group() {
  // @@protoc_insertion_point(field_release:auth.EditResponse.CreateUserGroup.group)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::auth::UserGroup* temp = _impl_.group_;
  _impl_.group_ = nullptr;
  return temp;
}
inline ::auth::UserGroup* EditResponse_CreateUserGroup::_internal_mutable_group() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.group_ == nullptr) {
    auto* p = CreateMaybeMessage<::auth::UserGroup>(GetArenaForAllocation());
    _impl_.group_ = p;
  }
  return _impl_.group_;
}
inline ::auth::UserGroup* EditResponse_CreateUserGroup::mutable_group() {
  ::auth::UserGroup* _msg = _internal_mutable_group();
  // @@protoc_insertion_point(field_mutable:auth.EditResponse.CreateUserGroup.group)
  return _msg;
}
inline void EditResponse_CreateUserGroup::set_allocated_group(::auth::UserGroup* group) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.group_;
  }
  if (group) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(group);
    if (message_arena != submessage_arena) {
      group = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, group, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.group_ = group;
  // @@protoc_insertion_point(field_set_allocated:auth.EditResponse.CreateUserGroup.group)
}

// optional .auth.EditResponse.Error error = 2;
inline bool EditResponse_CreateUserGroup::_internal_has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.error_ != nullptr);
  return value;
}
inline bool EditResponse_CreateUserGroup::has_error() const {
  return _internal_has_error();
}
inline void EditResponse_CreateUserGroup::clear_error() {
  if (_impl_.error_ != nullptr) _impl_.error_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::auth::EditResponse_Error& EditResponse_CreateUserGroup::_internal_error() const {
  const ::auth::EditResponse_Error* p = _impl_.error_;
  return p != nullptr ? *p : reinterpret_cast<const ::auth::EditResponse_Error&>(
      ::auth::_EditResponse_Error_default_instance_);
}
inline const ::auth::EditResponse_Error& EditResponse_CreateUserGroup::error() const {
  // @@protoc_insertion_point(field_get:auth.EditResponse.CreateUserGroup.error)
  return _internal_error();
}
inline void EditResponse_CreateUserGroup::unsafe_arena_set_allocated_error(
    ::auth::EditResponse_Error* error) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.error_);
  }
  _impl_.error_ = error;
  if (error) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:auth.EditResponse.CreateUserGroup.error)
}
inline ::auth::EditResponse_Error* EditResponse_CreateUserGroup::release_error() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::auth::EditResponse_Error* temp = _impl_.error_;
  _impl_.error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::auth::EditResponse_Error* EditResponse_CreateUserGroup::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_release:auth.EditResponse.CreateUserGroup.error)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::auth::EditResponse_Error* temp = _impl_.error_;
  _impl_.error_ = nullptr;
  return temp;
}
inline ::auth::EditResponse_Error* EditResponse_CreateUserGroup::_internal_mutable_error() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.error_ == nullptr) {
    auto* p = CreateMaybeMessage<::auth::EditResponse_Error>(GetArenaForAllocation());
    _impl_.error_ = p;
  }
  return _impl_.error_;
}
inline ::auth::EditResponse_Error* EditResponse_CreateUserGroup::mutable_error() {
  ::auth::EditResponse_Error* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:auth.EditResponse.CreateUserGroup.error)
  return _msg;
}
inline void EditResponse_CreateUserGroup::set_allocated_error(::auth::EditResponse_Error* error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.error_;
  }
  if (error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(error);
    if (message_arena != submessage_arena) {
      error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.error_ = error;
  // @@protoc_insertion_point(field_set_allocated:auth.EditResponse.CreateUserGroup.error)
}

// -------------------------------------------------------------------

// EditResponse_GetUserGroupsResponse

// optional .auth.GetUserGroupsResp resp = 1;
inline bool EditResponse_GetUserGroupsResponse::_internal_has_resp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.resp_ != nullptr);
  return value;
}
inline bool EditResponse_GetUserGroupsResponse::has_resp() const {
  return _internal_has_resp();
}
inline void EditResponse_GetUserGroupsResponse::clear_resp() {
  if (_impl_.resp_ != nullptr) _impl_.resp_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::auth::GetUserGroupsResp& EditResponse_GetUserGroupsResponse::_internal_resp() const {
  const ::auth::GetUserGroupsResp* p = _impl_.resp_;
  return p != nullptr ? *p : reinterpret_cast<const ::auth::GetUserGroupsResp&>(
      ::auth::_GetUserGroupsResp_default_instance_);
}
inline const ::auth::GetUserGroupsResp& EditResponse_GetUserGroupsResponse::resp() const {
  // @@protoc_insertion_point(field_get:auth.EditResponse.GetUserGroupsResponse.resp)
  return _internal_resp();
}
inline void EditResponse_GetUserGroupsResponse::unsafe_arena_set_allocated_resp(
    ::auth::GetUserGroupsResp* resp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.resp_);
  }
  _impl_.resp_ = resp;
  if (resp) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:auth.EditResponse.GetUserGroupsResponse.resp)
}
inline ::auth::GetUserGroupsResp* EditResponse_GetUserGroupsResponse::release_resp() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::auth::GetUserGroupsResp* temp = _impl_.resp_;
  _impl_.resp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::auth::GetUserGroupsResp* EditResponse_GetUserGroupsResponse::unsafe_arena_release_resp() {
  // @@protoc_insertion_point(field_release:auth.EditResponse.GetUserGroupsResponse.resp)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::auth::GetUserGroupsResp* temp = _impl_.resp_;
  _impl_.resp_ = nullptr;
  return temp;
}
inline ::auth::GetUserGroupsResp* EditResponse_GetUserGroupsResponse::_internal_mutable_resp() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.resp_ == nullptr) {
    auto* p = CreateMaybeMessage<::auth::GetUserGroupsResp>(GetArenaForAllocation());
    _impl_.resp_ = p;
  }
  return _impl_.resp_;
}
inline ::auth::GetUserGroupsResp* EditResponse_GetUserGroupsResponse::mutable_resp() {
  ::auth::GetUserGroupsResp* _msg = _internal_mutable_resp();
  // @@protoc_insertion_point(field_mutable:auth.EditResponse.GetUserGroupsResponse.resp)
  return _msg;
}
inline void EditResponse_GetUserGroupsResponse::set_allocated_resp(::auth::GetUserGroupsResp* resp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.resp_;
  }
  if (resp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(resp);
    if (message_arena != submessage_arena) {
      resp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, resp, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.resp_ = resp;
  // @@protoc_insertion_point(field_set_allocated:auth.EditResponse.GetUserGroupsResponse.resp)
}

// optional .auth.EditResponse.Error error = 2;
inline bool EditResponse_GetUserGroupsResponse::_internal_has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.error_ != nullptr);
  return value;
}
inline bool EditResponse_GetUserGroupsResponse::has_error() const {
  return _internal_has_error();
}
inline void EditResponse_GetUserGroupsResponse::clear_error() {
  if (_impl_.error_ != nullptr) _impl_.error_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::auth::EditResponse_Error& EditResponse_GetUserGroupsResponse::_internal_error() const {
  const ::auth::EditResponse_Error* p = _impl_.error_;
  return p != nullptr ? *p : reinterpret_cast<const ::auth::EditResponse_Error&>(
      ::auth::_EditResponse_Error_default_instance_);
}
inline const ::auth::EditResponse_Error& EditResponse_GetUserGroupsResponse::error() const {
  // @@protoc_insertion_point(field_get:auth.EditResponse.GetUserGroupsResponse.error)
  return _internal_error();
}
inline void EditResponse_GetUserGroupsResponse::unsafe_arena_set_allocated_error(
    ::auth::EditResponse_Error* error) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.error_);
  }
  _impl_.error_ = error;
  if (error) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:auth.EditResponse.GetUserGroupsResponse.error)
}
inline ::auth::EditResponse_Error* EditResponse_GetUserGroupsResponse::release_error() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::auth::EditResponse_Error* temp = _impl_.error_;
  _impl_.error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::auth::EditResponse_Error* EditResponse_GetUserGroupsResponse::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_release:auth.EditResponse.GetUserGroupsResponse.error)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::auth::EditResponse_Error* temp = _impl_.error_;
  _impl_.error_ = nullptr;
  return temp;
}
inline ::auth::EditResponse_Error* EditResponse_GetUserGroupsResponse::_internal_mutable_error() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.error_ == nullptr) {
    auto* p = CreateMaybeMessage<::auth::EditResponse_Error>(GetArenaForAllocation());
    _impl_.error_ = p;
  }
  return _impl_.error_;
}
inline ::auth::EditResponse_Error* EditResponse_GetUserGroupsResponse::mutable_error() {
  ::auth::EditResponse_Error* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:auth.EditResponse.GetUserGroupsResponse.error)
  return _msg;
}
inline void EditResponse_GetUserGroupsResponse::set_allocated_error(::auth::EditResponse_Error* error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.error_;
  }
  if (error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(error);
    if (message_arena != submessage_arena) {
      error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.error_ = error;
  // @@protoc_insertion_point(field_set_allocated:auth.EditResponse.GetUserGroupsResponse.error)
}

// -------------------------------------------------------------------

// EditResponse_GetUsersByGroupResponse

// optional .auth.GetUsersByGroupResp resp = 1;
inline bool EditResponse_GetUsersByGroupResponse::_internal_has_resp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.resp_ != nullptr);
  return value;
}
inline bool EditResponse_GetUsersByGroupResponse::has_resp() const {
  return _internal_has_resp();
}
inline void EditResponse_GetUsersByGroupResponse::clear_resp() {
  if (_impl_.resp_ != nullptr) _impl_.resp_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::auth::GetUsersByGroupResp& EditResponse_GetUsersByGroupResponse::_internal_resp() const {
  const ::auth::GetUsersByGroupResp* p = _impl_.resp_;
  return p != nullptr ? *p : reinterpret_cast<const ::auth::GetUsersByGroupResp&>(
      ::auth::_GetUsersByGroupResp_default_instance_);
}
inline const ::auth::GetUsersByGroupResp& EditResponse_GetUsersByGroupResponse::resp() const {
  // @@protoc_insertion_point(field_get:auth.EditResponse.GetUsersByGroupResponse.resp)
  return _internal_resp();
}
inline void EditResponse_GetUsersByGroupResponse::unsafe_arena_set_allocated_resp(
    ::auth::GetUsersByGroupResp* resp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.resp_);
  }
  _impl_.resp_ = resp;
  if (resp) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:auth.EditResponse.GetUsersByGroupResponse.resp)
}
inline ::auth::GetUsersByGroupResp* EditResponse_GetUsersByGroupResponse::release_resp() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::auth::GetUsersByGroupResp* temp = _impl_.resp_;
  _impl_.resp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::auth::GetUsersByGroupResp* EditResponse_GetUsersByGroupResponse::unsafe_arena_release_resp() {
  // @@protoc_insertion_point(field_release:auth.EditResponse.GetUsersByGroupResponse.resp)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::auth::GetUsersByGroupResp* temp = _impl_.resp_;
  _impl_.resp_ = nullptr;
  return temp;
}
inline ::auth::GetUsersByGroupResp* EditResponse_GetUsersByGroupResponse::_internal_mutable_resp() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.resp_ == nullptr) {
    auto* p = CreateMaybeMessage<::auth::GetUsersByGroupResp>(GetArenaForAllocation());
    _impl_.resp_ = p;
  }
  return _impl_.resp_;
}
inline ::auth::GetUsersByGroupResp* EditResponse_GetUsersByGroupResponse::mutable_resp() {
  ::auth::GetUsersByGroupResp* _msg = _internal_mutable_resp();
  // @@protoc_insertion_point(field_mutable:auth.EditResponse.GetUsersByGroupResponse.resp)
  return _msg;
}
inline void EditResponse_GetUsersByGroupResponse::set_allocated_resp(::auth::GetUsersByGroupResp* resp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.resp_;
  }
  if (resp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(resp);
    if (message_arena != submessage_arena) {
      resp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, resp, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.resp_ = resp;
  // @@protoc_insertion_point(field_set_allocated:auth.EditResponse.GetUsersByGroupResponse.resp)
}

// optional .auth.EditResponse.Error error = 2;
inline bool EditResponse_GetUsersByGroupResponse::_internal_has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.error_ != nullptr);
  return value;
}
inline bool EditResponse_GetUsersByGroupResponse::has_error() const {
  return _internal_has_error();
}
inline void EditResponse_GetUsersByGroupResponse::clear_error() {
  if (_impl_.error_ != nullptr) _impl_.error_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::auth::EditResponse_Error& EditResponse_GetUsersByGroupResponse::_internal_error() const {
  const ::auth::EditResponse_Error* p = _impl_.error_;
  return p != nullptr ? *p : reinterpret_cast<const ::auth::EditResponse_Error&>(
      ::auth::_EditResponse_Error_default_instance_);
}
inline const ::auth::EditResponse_Error& EditResponse_GetUsersByGroupResponse::error() const {
  // @@protoc_insertion_point(field_get:auth.EditResponse.GetUsersByGroupResponse.error)
  return _internal_error();
}
inline void EditResponse_GetUsersByGroupResponse::unsafe_arena_set_allocated_error(
    ::auth::EditResponse_Error* error) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.error_);
  }
  _impl_.error_ = error;
  if (error) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:auth.EditResponse.GetUsersByGroupResponse.error)
}
inline ::auth::EditResponse_Error* EditResponse_GetUsersByGroupResponse::release_error() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::auth::EditResponse_Error* temp = _impl_.error_;
  _impl_.error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::auth::EditResponse_Error* EditResponse_GetUsersByGroupResponse::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_release:auth.EditResponse.GetUsersByGroupResponse.error)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::auth::EditResponse_Error* temp = _impl_.error_;
  _impl_.error_ = nullptr;
  return temp;
}
inline ::auth::EditResponse_Error* EditResponse_GetUsersByGroupResponse::_internal_mutable_error() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.error_ == nullptr) {
    auto* p = CreateMaybeMessage<::auth::EditResponse_Error>(GetArenaForAllocation());
    _impl_.error_ = p;
  }
  return _impl_.error_;
}
inline ::auth::EditResponse_Error* EditResponse_GetUsersByGroupResponse::mutable_error() {
  ::auth::EditResponse_Error* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:auth.EditResponse.GetUsersByGroupResponse.error)
  return _msg;
}
inline void EditResponse_GetUsersByGroupResponse::set_allocated_error(::auth::EditResponse_Error* error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.error_;
  }
  if (error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(error);
    if (message_arena != submessage_arena) {
      error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.error_ = error;
  // @@protoc_insertion_point(field_set_allocated:auth.EditResponse.GetUsersByGroupResponse.error)
}

// -------------------------------------------------------------------

// EditResponse_GetTerminal

// optional .auth.Terminal terminal = 1;
inline bool EditResponse_GetTerminal::_internal_has_terminal() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.terminal_ != nullptr);
  return value;
}
inline bool EditResponse_GetTerminal::has_terminal() const {
  return _internal_has_terminal();
}
inline void EditResponse_GetTerminal::clear_terminal() {
  if (_impl_.terminal_ != nullptr) _impl_.terminal_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::auth::Terminal& EditResponse_GetTerminal::_internal_terminal() const {
  const ::auth::Terminal* p = _impl_.terminal_;
  return p != nullptr ? *p : reinterpret_cast<const ::auth::Terminal&>(
      ::auth::_Terminal_default_instance_);
}
inline const ::auth::Terminal& EditResponse_GetTerminal::terminal() const {
  // @@protoc_insertion_point(field_get:auth.EditResponse.GetTerminal.terminal)
  return _internal_terminal();
}
inline void EditResponse_GetTerminal::unsafe_arena_set_allocated_terminal(
    ::auth::Terminal* terminal) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.terminal_);
  }
  _impl_.terminal_ = terminal;
  if (terminal) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:auth.EditResponse.GetTerminal.terminal)
}
inline ::auth::Terminal* EditResponse_GetTerminal::release_terminal() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::auth::Terminal* temp = _impl_.terminal_;
  _impl_.terminal_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::auth::Terminal* EditResponse_GetTerminal::unsafe_arena_release_terminal() {
  // @@protoc_insertion_point(field_release:auth.EditResponse.GetTerminal.terminal)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::auth::Terminal* temp = _impl_.terminal_;
  _impl_.terminal_ = nullptr;
  return temp;
}
inline ::auth::Terminal* EditResponse_GetTerminal::_internal_mutable_terminal() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.terminal_ == nullptr) {
    auto* p = CreateMaybeMessage<::auth::Terminal>(GetArenaForAllocation());
    _impl_.terminal_ = p;
  }
  return _impl_.terminal_;
}
inline ::auth::Terminal* EditResponse_GetTerminal::mutable_terminal() {
  ::auth::Terminal* _msg = _internal_mutable_terminal();
  // @@protoc_insertion_point(field_mutable:auth.EditResponse.GetTerminal.terminal)
  return _msg;
}
inline void EditResponse_GetTerminal::set_allocated_terminal(::auth::Terminal* terminal) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.terminal_;
  }
  if (terminal) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(terminal);
    if (message_arena != submessage_arena) {
      terminal = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, terminal, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.terminal_ = terminal;
  // @@protoc_insertion_point(field_set_allocated:auth.EditResponse.GetTerminal.terminal)
}

// optional .auth.EditResponse.Error error = 2;
inline bool EditResponse_GetTerminal::_internal_has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.error_ != nullptr);
  return value;
}
inline bool EditResponse_GetTerminal::has_error() const {
  return _internal_has_error();
}
inline void EditResponse_GetTerminal::clear_error() {
  if (_impl_.error_ != nullptr) _impl_.error_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::auth::EditResponse_Error& EditResponse_GetTerminal::_internal_error() const {
  const ::auth::EditResponse_Error* p = _impl_.error_;
  return p != nullptr ? *p : reinterpret_cast<const ::auth::EditResponse_Error&>(
      ::auth::_EditResponse_Error_default_instance_);
}
inline const ::auth::EditResponse_Error& EditResponse_GetTerminal::error() const {
  // @@protoc_insertion_point(field_get:auth.EditResponse.GetTerminal.error)
  return _internal_error();
}
inline void EditResponse_GetTerminal::unsafe_arena_set_allocated_error(
    ::auth::EditResponse_Error* error) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.error_);
  }
  _impl_.error_ = error;
  if (error) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:auth.EditResponse.GetTerminal.error)
}
inline ::auth::EditResponse_Error* EditResponse_GetTerminal::release_error() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::auth::EditResponse_Error* temp = _impl_.error_;
  _impl_.error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::auth::EditResponse_Error* EditResponse_GetTerminal::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_release:auth.EditResponse.GetTerminal.error)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::auth::EditResponse_Error* temp = _impl_.error_;
  _impl_.error_ = nullptr;
  return temp;
}
inline ::auth::EditResponse_Error* EditResponse_GetTerminal::_internal_mutable_error() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.error_ == nullptr) {
    auto* p = CreateMaybeMessage<::auth::EditResponse_Error>(GetArenaForAllocation());
    _impl_.error_ = p;
  }
  return _impl_.error_;
}
inline ::auth::EditResponse_Error* EditResponse_GetTerminal::mutable_error() {
  ::auth::EditResponse_Error* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:auth.EditResponse.GetTerminal.error)
  return _msg;
}
inline void EditResponse_GetTerminal::set_allocated_error(::auth::EditResponse_Error* error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.error_;
  }
  if (error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(error);
    if (message_arena != submessage_arena) {
      error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.error_ = error;
  // @@protoc_insertion_point(field_set_allocated:auth.EditResponse.GetTerminal.error)
}

// -------------------------------------------------------------------

// EditResponse_UpdateTerminal

// optional .auth.Terminal terminal = 1;
inline bool EditResponse_UpdateTerminal::_internal_has_terminal() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.terminal_ != nullptr);
  return value;
}
inline bool EditResponse_UpdateTerminal::has_terminal() const {
  return _internal_has_terminal();
}
inline void EditResponse_UpdateTerminal::clear_terminal() {
  if (_impl_.terminal_ != nullptr) _impl_.terminal_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::auth::Terminal& EditResponse_UpdateTerminal::_internal_terminal() const {
  const ::auth::Terminal* p = _impl_.terminal_;
  return p != nullptr ? *p : reinterpret_cast<const ::auth::Terminal&>(
      ::auth::_Terminal_default_instance_);
}
inline const ::auth::Terminal& EditResponse_UpdateTerminal::terminal() const {
  // @@protoc_insertion_point(field_get:auth.EditResponse.UpdateTerminal.terminal)
  return _internal_terminal();
}
inline void EditResponse_UpdateTerminal::unsafe_arena_set_allocated_terminal(
    ::auth::Terminal* terminal) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.terminal_);
  }
  _impl_.terminal_ = terminal;
  if (terminal) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:auth.EditResponse.UpdateTerminal.terminal)
}
inline ::auth::Terminal* EditResponse_UpdateTerminal::release_terminal() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::auth::Terminal* temp = _impl_.terminal_;
  _impl_.terminal_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::auth::Terminal* EditResponse_UpdateTerminal::unsafe_arena_release_terminal() {
  // @@protoc_insertion_point(field_release:auth.EditResponse.UpdateTerminal.terminal)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::auth::Terminal* temp = _impl_.terminal_;
  _impl_.terminal_ = nullptr;
  return temp;
}
inline ::auth::Terminal* EditResponse_UpdateTerminal::_internal_mutable_terminal() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.terminal_ == nullptr) {
    auto* p = CreateMaybeMessage<::auth::Terminal>(GetArenaForAllocation());
    _impl_.terminal_ = p;
  }
  return _impl_.terminal_;
}
inline ::auth::Terminal* EditResponse_UpdateTerminal::mutable_terminal() {
  ::auth::Terminal* _msg = _internal_mutable_terminal();
  // @@protoc_insertion_point(field_mutable:auth.EditResponse.UpdateTerminal.terminal)
  return _msg;
}
inline void EditResponse_UpdateTerminal::set_allocated_terminal(::auth::Terminal* terminal) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.terminal_;
  }
  if (terminal) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(terminal);
    if (message_arena != submessage_arena) {
      terminal = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, terminal, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.terminal_ = terminal;
  // @@protoc_insertion_point(field_set_allocated:auth.EditResponse.UpdateTerminal.terminal)
}

// optional .auth.EditResponse.Error error = 2;
inline bool EditResponse_UpdateTerminal::_internal_has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.error_ != nullptr);
  return value;
}
inline bool EditResponse_UpdateTerminal::has_error() const {
  return _internal_has_error();
}
inline void EditResponse_UpdateTerminal::clear_error() {
  if (_impl_.error_ != nullptr) _impl_.error_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::auth::EditResponse_Error& EditResponse_UpdateTerminal::_internal_error() const {
  const ::auth::EditResponse_Error* p = _impl_.error_;
  return p != nullptr ? *p : reinterpret_cast<const ::auth::EditResponse_Error&>(
      ::auth::_EditResponse_Error_default_instance_);
}
inline const ::auth::EditResponse_Error& EditResponse_UpdateTerminal::error() const {
  // @@protoc_insertion_point(field_get:auth.EditResponse.UpdateTerminal.error)
  return _internal_error();
}
inline void EditResponse_UpdateTerminal::unsafe_arena_set_allocated_error(
    ::auth::EditResponse_Error* error) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.error_);
  }
  _impl_.error_ = error;
  if (error) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:auth.EditResponse.UpdateTerminal.error)
}
inline ::auth::EditResponse_Error* EditResponse_UpdateTerminal::release_error() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::auth::EditResponse_Error* temp = _impl_.error_;
  _impl_.error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::auth::EditResponse_Error* EditResponse_UpdateTerminal::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_release:auth.EditResponse.UpdateTerminal.error)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::auth::EditResponse_Error* temp = _impl_.error_;
  _impl_.error_ = nullptr;
  return temp;
}
inline ::auth::EditResponse_Error* EditResponse_UpdateTerminal::_internal_mutable_error() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.error_ == nullptr) {
    auto* p = CreateMaybeMessage<::auth::EditResponse_Error>(GetArenaForAllocation());
    _impl_.error_ = p;
  }
  return _impl_.error_;
}
inline ::auth::EditResponse_Error* EditResponse_UpdateTerminal::mutable_error() {
  ::auth::EditResponse_Error* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:auth.EditResponse.UpdateTerminal.error)
  return _msg;
}
inline void EditResponse_UpdateTerminal::set_allocated_error(::auth::EditResponse_Error* error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.error_;
  }
  if (error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(error);
    if (message_arena != submessage_arena) {
      error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.error_ = error;
  // @@protoc_insertion_point(field_set_allocated:auth.EditResponse.UpdateTerminal.error)
}

// -------------------------------------------------------------------

// EditResponse_DeleteTerminal

// optional .auth.EditResponse.Error error = 1;
inline bool EditResponse_DeleteTerminal::_internal_has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.error_ != nullptr);
  return value;
}
inline bool EditResponse_DeleteTerminal::has_error() const {
  return _internal_has_error();
}
inline void EditResponse_DeleteTerminal::clear_error() {
  if (_impl_.error_ != nullptr) _impl_.error_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::auth::EditResponse_Error& EditResponse_DeleteTerminal::_internal_error() const {
  const ::auth::EditResponse_Error* p = _impl_.error_;
  return p != nullptr ? *p : reinterpret_cast<const ::auth::EditResponse_Error&>(
      ::auth::_EditResponse_Error_default_instance_);
}
inline const ::auth::EditResponse_Error& EditResponse_DeleteTerminal::error() const {
  // @@protoc_insertion_point(field_get:auth.EditResponse.DeleteTerminal.error)
  return _internal_error();
}
inline void EditResponse_DeleteTerminal::unsafe_arena_set_allocated_error(
    ::auth::EditResponse_Error* error) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.error_);
  }
  _impl_.error_ = error;
  if (error) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:auth.EditResponse.DeleteTerminal.error)
}
inline ::auth::EditResponse_Error* EditResponse_DeleteTerminal::release_error() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::auth::EditResponse_Error* temp = _impl_.error_;
  _impl_.error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::auth::EditResponse_Error* EditResponse_DeleteTerminal::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_release:auth.EditResponse.DeleteTerminal.error)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::auth::EditResponse_Error* temp = _impl_.error_;
  _impl_.error_ = nullptr;
  return temp;
}
inline ::auth::EditResponse_Error* EditResponse_DeleteTerminal::_internal_mutable_error() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.error_ == nullptr) {
    auto* p = CreateMaybeMessage<::auth::EditResponse_Error>(GetArenaForAllocation());
    _impl_.error_ = p;
  }
  return _impl_.error_;
}
inline ::auth::EditResponse_Error* EditResponse_DeleteTerminal::mutable_error() {
  ::auth::EditResponse_Error* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:auth.EditResponse.DeleteTerminal.error)
  return _msg;
}
inline void EditResponse_DeleteTerminal::set_allocated_error(::auth::EditResponse_Error* error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.error_;
  }
  if (error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(error);
    if (message_arena != submessage_arena) {
      error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.error_ = error;
  // @@protoc_insertion_point(field_set_allocated:auth.EditResponse.DeleteTerminal.error)
}

// -------------------------------------------------------------------

// EditResponse_GetTerminals

// optional .auth.EditResponse.TerminalsResp terminals = 1;
inline bool EditResponse_GetTerminals::_internal_has_terminals() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.terminals_ != nullptr);
  return value;
}
inline bool EditResponse_GetTerminals::has_terminals() const {
  return _internal_has_terminals();
}
inline void EditResponse_GetTerminals::clear_terminals() {
  if (_impl_.terminals_ != nullptr) _impl_.terminals_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::auth::EditResponse_TerminalsResp& EditResponse_GetTerminals::_internal_terminals() const {
  const ::auth::EditResponse_TerminalsResp* p = _impl_.terminals_;
  return p != nullptr ? *p : reinterpret_cast<const ::auth::EditResponse_TerminalsResp&>(
      ::auth::_EditResponse_TerminalsResp_default_instance_);
}
inline const ::auth::EditResponse_TerminalsResp& EditResponse_GetTerminals::terminals() const {
  // @@protoc_insertion_point(field_get:auth.EditResponse.GetTerminals.terminals)
  return _internal_terminals();
}
inline void EditResponse_GetTerminals::unsafe_arena_set_allocated_terminals(
    ::auth::EditResponse_TerminalsResp* terminals) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.terminals_);
  }
  _impl_.terminals_ = terminals;
  if (terminals) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:auth.EditResponse.GetTerminals.terminals)
}
inline ::auth::EditResponse_TerminalsResp* EditResponse_GetTerminals::release_terminals() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::auth::EditResponse_TerminalsResp* temp = _impl_.terminals_;
  _impl_.terminals_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::auth::EditResponse_TerminalsResp* EditResponse_GetTerminals::unsafe_arena_release_terminals() {
  // @@protoc_insertion_point(field_release:auth.EditResponse.GetTerminals.terminals)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::auth::EditResponse_TerminalsResp* temp = _impl_.terminals_;
  _impl_.terminals_ = nullptr;
  return temp;
}
inline ::auth::EditResponse_TerminalsResp* EditResponse_GetTerminals::_internal_mutable_terminals() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.terminals_ == nullptr) {
    auto* p = CreateMaybeMessage<::auth::EditResponse_TerminalsResp>(GetArenaForAllocation());
    _impl_.terminals_ = p;
  }
  return _impl_.terminals_;
}
inline ::auth::EditResponse_TerminalsResp* EditResponse_GetTerminals::mutable_terminals() {
  ::auth::EditResponse_TerminalsResp* _msg = _internal_mutable_terminals();
  // @@protoc_insertion_point(field_mutable:auth.EditResponse.GetTerminals.terminals)
  return _msg;
}
inline void EditResponse_GetTerminals::set_allocated_terminals(::auth::EditResponse_TerminalsResp* terminals) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.terminals_;
  }
  if (terminals) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(terminals);
    if (message_arena != submessage_arena) {
      terminals = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, terminals, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.terminals_ = terminals;
  // @@protoc_insertion_point(field_set_allocated:auth.EditResponse.GetTerminals.terminals)
}

// optional .auth.EditResponse.Error error = 2;
inline bool EditResponse_GetTerminals::_internal_has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.error_ != nullptr);
  return value;
}
inline bool EditResponse_GetTerminals::has_error() const {
  return _internal_has_error();
}
inline void EditResponse_GetTerminals::clear_error() {
  if (_impl_.error_ != nullptr) _impl_.error_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::auth::EditResponse_Error& EditResponse_GetTerminals::_internal_error() const {
  const ::auth::EditResponse_Error* p = _impl_.error_;
  return p != nullptr ? *p : reinterpret_cast<const ::auth::EditResponse_Error&>(
      ::auth::_EditResponse_Error_default_instance_);
}
inline const ::auth::EditResponse_Error& EditResponse_GetTerminals::error() const {
  // @@protoc_insertion_point(field_get:auth.EditResponse.GetTerminals.error)
  return _internal_error();
}
inline void EditResponse_GetTerminals::unsafe_arena_set_allocated_error(
    ::auth::EditResponse_Error* error) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.error_);
  }
  _impl_.error_ = error;
  if (error) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:auth.EditResponse.GetTerminals.error)
}
inline ::auth::EditResponse_Error* EditResponse_GetTerminals::release_error() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::auth::EditResponse_Error* temp = _impl_.error_;
  _impl_.error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::auth::EditResponse_Error* EditResponse_GetTerminals::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_release:auth.EditResponse.GetTerminals.error)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::auth::EditResponse_Error* temp = _impl_.error_;
  _impl_.error_ = nullptr;
  return temp;
}
inline ::auth::EditResponse_Error* EditResponse_GetTerminals::_internal_mutable_error() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.error_ == nullptr) {
    auto* p = CreateMaybeMessage<::auth::EditResponse_Error>(GetArenaForAllocation());
    _impl_.error_ = p;
  }
  return _impl_.error_;
}
inline ::auth::EditResponse_Error* EditResponse_GetTerminals::mutable_error() {
  ::auth::EditResponse_Error* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:auth.EditResponse.GetTerminals.error)
  return _msg;
}
inline void EditResponse_GetTerminals::set_allocated_error(::auth::EditResponse_Error* error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.error_;
  }
  if (error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(error);
    if (message_arena != submessage_arena) {
      error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.error_ = error;
  // @@protoc_insertion_point(field_set_allocated:auth.EditResponse.GetTerminals.error)
}

// -------------------------------------------------------------------

// EditResponse_CreateTerminal

// optional .auth.Terminal terminal = 1;
inline bool EditResponse_CreateTerminal::_internal_has_terminal() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.terminal_ != nullptr);
  return value;
}
inline bool EditResponse_CreateTerminal::has_terminal() const {
  return _internal_has_terminal();
}
inline void EditResponse_CreateTerminal::clear_terminal() {
  if (_impl_.terminal_ != nullptr) _impl_.terminal_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::auth::Terminal& EditResponse_CreateTerminal::_internal_terminal() const {
  const ::auth::Terminal* p = _impl_.terminal_;
  return p != nullptr ? *p : reinterpret_cast<const ::auth::Terminal&>(
      ::auth::_Terminal_default_instance_);
}
inline const ::auth::Terminal& EditResponse_CreateTerminal::terminal() const {
  // @@protoc_insertion_point(field_get:auth.EditResponse.CreateTerminal.terminal)
  return _internal_terminal();
}
inline void EditResponse_CreateTerminal::unsafe_arena_set_allocated_terminal(
    ::auth::Terminal* terminal) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.terminal_);
  }
  _impl_.terminal_ = terminal;
  if (terminal) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:auth.EditResponse.CreateTerminal.terminal)
}
inline ::auth::Terminal* EditResponse_CreateTerminal::release_terminal() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::auth::Terminal* temp = _impl_.terminal_;
  _impl_.terminal_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::auth::Terminal* EditResponse_CreateTerminal::unsafe_arena_release_terminal() {
  // @@protoc_insertion_point(field_release:auth.EditResponse.CreateTerminal.terminal)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::auth::Terminal* temp = _impl_.terminal_;
  _impl_.terminal_ = nullptr;
  return temp;
}
inline ::auth::Terminal* EditResponse_CreateTerminal::_internal_mutable_terminal() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.terminal_ == nullptr) {
    auto* p = CreateMaybeMessage<::auth::Terminal>(GetArenaForAllocation());
    _impl_.terminal_ = p;
  }
  return _impl_.terminal_;
}
inline ::auth::Terminal* EditResponse_CreateTerminal::mutable_terminal() {
  ::auth::Terminal* _msg = _internal_mutable_terminal();
  // @@protoc_insertion_point(field_mutable:auth.EditResponse.CreateTerminal.terminal)
  return _msg;
}
inline void EditResponse_CreateTerminal::set_allocated_terminal(::auth::Terminal* terminal) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.terminal_;
  }
  if (terminal) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(terminal);
    if (message_arena != submessage_arena) {
      terminal = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, terminal, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.terminal_ = terminal;
  // @@protoc_insertion_point(field_set_allocated:auth.EditResponse.CreateTerminal.terminal)
}

// optional .auth.EditResponse.Error error = 2;
inline bool EditResponse_CreateTerminal::_internal_has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.error_ != nullptr);
  return value;
}
inline bool EditResponse_CreateTerminal::has_error() const {
  return _internal_has_error();
}
inline void EditResponse_CreateTerminal::clear_error() {
  if (_impl_.error_ != nullptr) _impl_.error_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::auth::EditResponse_Error& EditResponse_CreateTerminal::_internal_error() const {
  const ::auth::EditResponse_Error* p = _impl_.error_;
  return p != nullptr ? *p : reinterpret_cast<const ::auth::EditResponse_Error&>(
      ::auth::_EditResponse_Error_default_instance_);
}
inline const ::auth::EditResponse_Error& EditResponse_CreateTerminal::error() const {
  // @@protoc_insertion_point(field_get:auth.EditResponse.CreateTerminal.error)
  return _internal_error();
}
inline void EditResponse_CreateTerminal::unsafe_arena_set_allocated_error(
    ::auth::EditResponse_Error* error) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.error_);
  }
  _impl_.error_ = error;
  if (error) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:auth.EditResponse.CreateTerminal.error)
}
inline ::auth::EditResponse_Error* EditResponse_CreateTerminal::release_error() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::auth::EditResponse_Error* temp = _impl_.error_;
  _impl_.error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::auth::EditResponse_Error* EditResponse_CreateTerminal::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_release:auth.EditResponse.CreateTerminal.error)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::auth::EditResponse_Error* temp = _impl_.error_;
  _impl_.error_ = nullptr;
  return temp;
}
inline ::auth::EditResponse_Error* EditResponse_CreateTerminal::_internal_mutable_error() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.error_ == nullptr) {
    auto* p = CreateMaybeMessage<::auth::EditResponse_Error>(GetArenaForAllocation());
    _impl_.error_ = p;
  }
  return _impl_.error_;
}
inline ::auth::EditResponse_Error* EditResponse_CreateTerminal::mutable_error() {
  ::auth::EditResponse_Error* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:auth.EditResponse.CreateTerminal.error)
  return _msg;
}
inline void EditResponse_CreateTerminal::set_allocated_error(::auth::EditResponse_Error* error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.error_;
  }
  if (error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(error);
    if (message_arena != submessage_arena) {
      error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.error_ = error;
  // @@protoc_insertion_point(field_set_allocated:auth.EditResponse.CreateTerminal.error)
}

// -------------------------------------------------------------------

// EditResponse

// .auth.EditResponse.GetUser getUserResponse = 1;
inline bool EditResponse::_internal_has_getuserresponse() const {
  return response_case() == kGetUserResponse;
}
inline bool EditResponse::has_getuserresponse() const {
  return _internal_has_getuserresponse();
}
inline void EditResponse::set_has_getuserresponse() {
  _impl_._oneof_case_[0] = kGetUserResponse;
}
inline void EditResponse::clear_getuserresponse() {
  if (_internal_has_getuserresponse()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.response_.getuserresponse_;
    }
    clear_has_response();
  }
}
inline ::auth::EditResponse_GetUser* EditResponse::release_getuserresponse() {
  // @@protoc_insertion_point(field_release:auth.EditResponse.getUserResponse)
  if (_internal_has_getuserresponse()) {
    clear_has_response();
    ::auth::EditResponse_GetUser* temp = _impl_.response_.getuserresponse_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_.getuserresponse_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::auth::EditResponse_GetUser& EditResponse::_internal_getuserresponse() const {
  return _internal_has_getuserresponse()
      ? *_impl_.response_.getuserresponse_
      : reinterpret_cast< ::auth::EditResponse_GetUser&>(::auth::_EditResponse_GetUser_default_instance_);
}
inline const ::auth::EditResponse_GetUser& EditResponse::getuserresponse() const {
  // @@protoc_insertion_point(field_get:auth.EditResponse.getUserResponse)
  return _internal_getuserresponse();
}
inline ::auth::EditResponse_GetUser* EditResponse::unsafe_arena_release_getuserresponse() {
  // @@protoc_insertion_point(field_unsafe_arena_release:auth.EditResponse.getUserResponse)
  if (_internal_has_getuserresponse()) {
    clear_has_response();
    ::auth::EditResponse_GetUser* temp = _impl_.response_.getuserresponse_;
    _impl_.response_.getuserresponse_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EditResponse::unsafe_arena_set_allocated_getuserresponse(::auth::EditResponse_GetUser* getuserresponse) {
  clear_response();
  if (getuserresponse) {
    set_has_getuserresponse();
    _impl_.response_.getuserresponse_ = getuserresponse;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:auth.EditResponse.getUserResponse)
}
inline ::auth::EditResponse_GetUser* EditResponse::_internal_mutable_getuserresponse() {
  if (!_internal_has_getuserresponse()) {
    clear_response();
    set_has_getuserresponse();
    _impl_.response_.getuserresponse_ = CreateMaybeMessage< ::auth::EditResponse_GetUser >(GetArenaForAllocation());
  }
  return _impl_.response_.getuserresponse_;
}
inline ::auth::EditResponse_GetUser* EditResponse::mutable_getuserresponse() {
  ::auth::EditResponse_GetUser* _msg = _internal_mutable_getuserresponse();
  // @@protoc_insertion_point(field_mutable:auth.EditResponse.getUserResponse)
  return _msg;
}

// .auth.EditResponse.GetUserGroup getUserGroupResponse = 2;
inline bool EditResponse::_internal_has_getusergroupresponse() const {
  return response_case() == kGetUserGroupResponse;
}
inline bool EditResponse::has_getusergroupresponse() const {
  return _internal_has_getusergroupresponse();
}
inline void EditResponse::set_has_getusergroupresponse() {
  _impl_._oneof_case_[0] = kGetUserGroupResponse;
}
inline void EditResponse::clear_getusergroupresponse() {
  if (_internal_has_getusergroupresponse()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.response_.getusergroupresponse_;
    }
    clear_has_response();
  }
}
inline ::auth::EditResponse_GetUserGroup* EditResponse::release_getusergroupresponse() {
  // @@protoc_insertion_point(field_release:auth.EditResponse.getUserGroupResponse)
  if (_internal_has_getusergroupresponse()) {
    clear_has_response();
    ::auth::EditResponse_GetUserGroup* temp = _impl_.response_.getusergroupresponse_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_.getusergroupresponse_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::auth::EditResponse_GetUserGroup& EditResponse::_internal_getusergroupresponse() const {
  return _internal_has_getusergroupresponse()
      ? *_impl_.response_.getusergroupresponse_
      : reinterpret_cast< ::auth::EditResponse_GetUserGroup&>(::auth::_EditResponse_GetUserGroup_default_instance_);
}
inline const ::auth::EditResponse_GetUserGroup& EditResponse::getusergroupresponse() const {
  // @@protoc_insertion_point(field_get:auth.EditResponse.getUserGroupResponse)
  return _internal_getusergroupresponse();
}
inline ::auth::EditResponse_GetUserGroup* EditResponse::unsafe_arena_release_getusergroupresponse() {
  // @@protoc_insertion_point(field_unsafe_arena_release:auth.EditResponse.getUserGroupResponse)
  if (_internal_has_getusergroupresponse()) {
    clear_has_response();
    ::auth::EditResponse_GetUserGroup* temp = _impl_.response_.getusergroupresponse_;
    _impl_.response_.getusergroupresponse_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EditResponse::unsafe_arena_set_allocated_getusergroupresponse(::auth::EditResponse_GetUserGroup* getusergroupresponse) {
  clear_response();
  if (getusergroupresponse) {
    set_has_getusergroupresponse();
    _impl_.response_.getusergroupresponse_ = getusergroupresponse;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:auth.EditResponse.getUserGroupResponse)
}
inline ::auth::EditResponse_GetUserGroup* EditResponse::_internal_mutable_getusergroupresponse() {
  if (!_internal_has_getusergroupresponse()) {
    clear_response();
    set_has_getusergroupresponse();
    _impl_.response_.getusergroupresponse_ = CreateMaybeMessage< ::auth::EditResponse_GetUserGroup >(GetArenaForAllocation());
  }
  return _impl_.response_.getusergroupresponse_;
}
inline ::auth::EditResponse_GetUserGroup* EditResponse::mutable_getusergroupresponse() {
  ::auth::EditResponse_GetUserGroup* _msg = _internal_mutable_getusergroupresponse();
  // @@protoc_insertion_point(field_mutable:auth.EditResponse.getUserGroupResponse)
  return _msg;
}

// .auth.EditResponse.UpdateUser updateUserResponse = 3;
inline bool EditResponse::_internal_has_updateuserresponse() const {
  return response_case() == kUpdateUserResponse;
}
inline bool EditResponse::has_updateuserresponse() const {
  return _internal_has_updateuserresponse();
}
inline void EditResponse::set_has_updateuserresponse() {
  _impl_._oneof_case_[0] = kUpdateUserResponse;
}
inline void EditResponse::clear_updateuserresponse() {
  if (_internal_has_updateuserresponse()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.response_.updateuserresponse_;
    }
    clear_has_response();
  }
}
inline ::auth::EditResponse_UpdateUser* EditResponse::release_updateuserresponse() {
  // @@protoc_insertion_point(field_release:auth.EditResponse.updateUserResponse)
  if (_internal_has_updateuserresponse()) {
    clear_has_response();
    ::auth::EditResponse_UpdateUser* temp = _impl_.response_.updateuserresponse_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_.updateuserresponse_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::auth::EditResponse_UpdateUser& EditResponse::_internal_updateuserresponse() const {
  return _internal_has_updateuserresponse()
      ? *_impl_.response_.updateuserresponse_
      : reinterpret_cast< ::auth::EditResponse_UpdateUser&>(::auth::_EditResponse_UpdateUser_default_instance_);
}
inline const ::auth::EditResponse_UpdateUser& EditResponse::updateuserresponse() const {
  // @@protoc_insertion_point(field_get:auth.EditResponse.updateUserResponse)
  return _internal_updateuserresponse();
}
inline ::auth::EditResponse_UpdateUser* EditResponse::unsafe_arena_release_updateuserresponse() {
  // @@protoc_insertion_point(field_unsafe_arena_release:auth.EditResponse.updateUserResponse)
  if (_internal_has_updateuserresponse()) {
    clear_has_response();
    ::auth::EditResponse_UpdateUser* temp = _impl_.response_.updateuserresponse_;
    _impl_.response_.updateuserresponse_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EditResponse::unsafe_arena_set_allocated_updateuserresponse(::auth::EditResponse_UpdateUser* updateuserresponse) {
  clear_response();
  if (updateuserresponse) {
    set_has_updateuserresponse();
    _impl_.response_.updateuserresponse_ = updateuserresponse;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:auth.EditResponse.updateUserResponse)
}
inline ::auth::EditResponse_UpdateUser* EditResponse::_internal_mutable_updateuserresponse() {
  if (!_internal_has_updateuserresponse()) {
    clear_response();
    set_has_updateuserresponse();
    _impl_.response_.updateuserresponse_ = CreateMaybeMessage< ::auth::EditResponse_UpdateUser >(GetArenaForAllocation());
  }
  return _impl_.response_.updateuserresponse_;
}
inline ::auth::EditResponse_UpdateUser* EditResponse::mutable_updateuserresponse() {
  ::auth::EditResponse_UpdateUser* _msg = _internal_mutable_updateuserresponse();
  // @@protoc_insertion_point(field_mutable:auth.EditResponse.updateUserResponse)
  return _msg;
}

// .auth.EditResponse.UpdateUserGroup updateUserGroupResponse = 4;
inline bool EditResponse::_internal_has_updateusergroupresponse() const {
  return response_case() == kUpdateUserGroupResponse;
}
inline bool EditResponse::has_updateusergroupresponse() const {
  return _internal_has_updateusergroupresponse();
}
inline void EditResponse::set_has_updateusergroupresponse() {
  _impl_._oneof_case_[0] = kUpdateUserGroupResponse;
}
inline void EditResponse::clear_updateusergroupresponse() {
  if (_internal_has_updateusergroupresponse()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.response_.updateusergroupresponse_;
    }
    clear_has_response();
  }
}
inline ::auth::EditResponse_UpdateUserGroup* EditResponse::release_updateusergroupresponse() {
  // @@protoc_insertion_point(field_release:auth.EditResponse.updateUserGroupResponse)
  if (_internal_has_updateusergroupresponse()) {
    clear_has_response();
    ::auth::EditResponse_UpdateUserGroup* temp = _impl_.response_.updateusergroupresponse_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_.updateusergroupresponse_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::auth::EditResponse_UpdateUserGroup& EditResponse::_internal_updateusergroupresponse() const {
  return _internal_has_updateusergroupresponse()
      ? *_impl_.response_.updateusergroupresponse_
      : reinterpret_cast< ::auth::EditResponse_UpdateUserGroup&>(::auth::_EditResponse_UpdateUserGroup_default_instance_);
}
inline const ::auth::EditResponse_UpdateUserGroup& EditResponse::updateusergroupresponse() const {
  // @@protoc_insertion_point(field_get:auth.EditResponse.updateUserGroupResponse)
  return _internal_updateusergroupresponse();
}
inline ::auth::EditResponse_UpdateUserGroup* EditResponse::unsafe_arena_release_updateusergroupresponse() {
  // @@protoc_insertion_point(field_unsafe_arena_release:auth.EditResponse.updateUserGroupResponse)
  if (_internal_has_updateusergroupresponse()) {
    clear_has_response();
    ::auth::EditResponse_UpdateUserGroup* temp = _impl_.response_.updateusergroupresponse_;
    _impl_.response_.updateusergroupresponse_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EditResponse::unsafe_arena_set_allocated_updateusergroupresponse(::auth::EditResponse_UpdateUserGroup* updateusergroupresponse) {
  clear_response();
  if (updateusergroupresponse) {
    set_has_updateusergroupresponse();
    _impl_.response_.updateusergroupresponse_ = updateusergroupresponse;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:auth.EditResponse.updateUserGroupResponse)
}
inline ::auth::EditResponse_UpdateUserGroup* EditResponse::_internal_mutable_updateusergroupresponse() {
  if (!_internal_has_updateusergroupresponse()) {
    clear_response();
    set_has_updateusergroupresponse();
    _impl_.response_.updateusergroupresponse_ = CreateMaybeMessage< ::auth::EditResponse_UpdateUserGroup >(GetArenaForAllocation());
  }
  return _impl_.response_.updateusergroupresponse_;
}
inline ::auth::EditResponse_UpdateUserGroup* EditResponse::mutable_updateusergroupresponse() {
  ::auth::EditResponse_UpdateUserGroup* _msg = _internal_mutable_updateusergroupresponse();
  // @@protoc_insertion_point(field_mutable:auth.EditResponse.updateUserGroupResponse)
  return _msg;
}

// .auth.EditResponse.DeleteUser deleteUserResponse = 5;
inline bool EditResponse::_internal_has_deleteuserresponse() const {
  return response_case() == kDeleteUserResponse;
}
inline bool EditResponse::has_deleteuserresponse() const {
  return _internal_has_deleteuserresponse();
}
inline void EditResponse::set_has_deleteuserresponse() {
  _impl_._oneof_case_[0] = kDeleteUserResponse;
}
inline void EditResponse::clear_deleteuserresponse() {
  if (_internal_has_deleteuserresponse()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.response_.deleteuserresponse_;
    }
    clear_has_response();
  }
}
inline ::auth::EditResponse_DeleteUser* EditResponse::release_deleteuserresponse() {
  // @@protoc_insertion_point(field_release:auth.EditResponse.deleteUserResponse)
  if (_internal_has_deleteuserresponse()) {
    clear_has_response();
    ::auth::EditResponse_DeleteUser* temp = _impl_.response_.deleteuserresponse_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_.deleteuserresponse_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::auth::EditResponse_DeleteUser& EditResponse::_internal_deleteuserresponse() const {
  return _internal_has_deleteuserresponse()
      ? *_impl_.response_.deleteuserresponse_
      : reinterpret_cast< ::auth::EditResponse_DeleteUser&>(::auth::_EditResponse_DeleteUser_default_instance_);
}
inline const ::auth::EditResponse_DeleteUser& EditResponse::deleteuserresponse() const {
  // @@protoc_insertion_point(field_get:auth.EditResponse.deleteUserResponse)
  return _internal_deleteuserresponse();
}
inline ::auth::EditResponse_DeleteUser* EditResponse::unsafe_arena_release_deleteuserresponse() {
  // @@protoc_insertion_point(field_unsafe_arena_release:auth.EditResponse.deleteUserResponse)
  if (_internal_has_deleteuserresponse()) {
    clear_has_response();
    ::auth::EditResponse_DeleteUser* temp = _impl_.response_.deleteuserresponse_;
    _impl_.response_.deleteuserresponse_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EditResponse::unsafe_arena_set_allocated_deleteuserresponse(::auth::EditResponse_DeleteUser* deleteuserresponse) {
  clear_response();
  if (deleteuserresponse) {
    set_has_deleteuserresponse();
    _impl_.response_.deleteuserresponse_ = deleteuserresponse;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:auth.EditResponse.deleteUserResponse)
}
inline ::auth::EditResponse_DeleteUser* EditResponse::_internal_mutable_deleteuserresponse() {
  if (!_internal_has_deleteuserresponse()) {
    clear_response();
    set_has_deleteuserresponse();
    _impl_.response_.deleteuserresponse_ = CreateMaybeMessage< ::auth::EditResponse_DeleteUser >(GetArenaForAllocation());
  }
  return _impl_.response_.deleteuserresponse_;
}
inline ::auth::EditResponse_DeleteUser* EditResponse::mutable_deleteuserresponse() {
  ::auth::EditResponse_DeleteUser* _msg = _internal_mutable_deleteuserresponse();
  // @@protoc_insertion_point(field_mutable:auth.EditResponse.deleteUserResponse)
  return _msg;
}

// .auth.EditResponse.DeleteUserGroup deleteUserGroupResponse = 6;
inline bool EditResponse::_internal_has_deleteusergroupresponse() const {
  return response_case() == kDeleteUserGroupResponse;
}
inline bool EditResponse::has_deleteusergroupresponse() const {
  return _internal_has_deleteusergroupresponse();
}
inline void EditResponse::set_has_deleteusergroupresponse() {
  _impl_._oneof_case_[0] = kDeleteUserGroupResponse;
}
inline void EditResponse::clear_deleteusergroupresponse() {
  if (_internal_has_deleteusergroupresponse()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.response_.deleteusergroupresponse_;
    }
    clear_has_response();
  }
}
inline ::auth::EditResponse_DeleteUserGroup* EditResponse::release_deleteusergroupresponse() {
  // @@protoc_insertion_point(field_release:auth.EditResponse.deleteUserGroupResponse)
  if (_internal_has_deleteusergroupresponse()) {
    clear_has_response();
    ::auth::EditResponse_DeleteUserGroup* temp = _impl_.response_.deleteusergroupresponse_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_.deleteusergroupresponse_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::auth::EditResponse_DeleteUserGroup& EditResponse::_internal_deleteusergroupresponse() const {
  return _internal_has_deleteusergroupresponse()
      ? *_impl_.response_.deleteusergroupresponse_
      : reinterpret_cast< ::auth::EditResponse_DeleteUserGroup&>(::auth::_EditResponse_DeleteUserGroup_default_instance_);
}
inline const ::auth::EditResponse_DeleteUserGroup& EditResponse::deleteusergroupresponse() const {
  // @@protoc_insertion_point(field_get:auth.EditResponse.deleteUserGroupResponse)
  return _internal_deleteusergroupresponse();
}
inline ::auth::EditResponse_DeleteUserGroup* EditResponse::unsafe_arena_release_deleteusergroupresponse() {
  // @@protoc_insertion_point(field_unsafe_arena_release:auth.EditResponse.deleteUserGroupResponse)
  if (_internal_has_deleteusergroupresponse()) {
    clear_has_response();
    ::auth::EditResponse_DeleteUserGroup* temp = _impl_.response_.deleteusergroupresponse_;
    _impl_.response_.deleteusergroupresponse_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EditResponse::unsafe_arena_set_allocated_deleteusergroupresponse(::auth::EditResponse_DeleteUserGroup* deleteusergroupresponse) {
  clear_response();
  if (deleteusergroupresponse) {
    set_has_deleteusergroupresponse();
    _impl_.response_.deleteusergroupresponse_ = deleteusergroupresponse;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:auth.EditResponse.deleteUserGroupResponse)
}
inline ::auth::EditResponse_DeleteUserGroup* EditResponse::_internal_mutable_deleteusergroupresponse() {
  if (!_internal_has_deleteusergroupresponse()) {
    clear_response();
    set_has_deleteusergroupresponse();
    _impl_.response_.deleteusergroupresponse_ = CreateMaybeMessage< ::auth::EditResponse_DeleteUserGroup >(GetArenaForAllocation());
  }
  return _impl_.response_.deleteusergroupresponse_;
}
inline ::auth::EditResponse_DeleteUserGroup* EditResponse::mutable_deleteusergroupresponse() {
  ::auth::EditResponse_DeleteUserGroup* _msg = _internal_mutable_deleteusergroupresponse();
  // @@protoc_insertion_point(field_mutable:auth.EditResponse.deleteUserGroupResponse)
  return _msg;
}

// .auth.EditResponse.CreateUser createUserResponse = 7;
inline bool EditResponse::_internal_has_createuserresponse() const {
  return response_case() == kCreateUserResponse;
}
inline bool EditResponse::has_createuserresponse() const {
  return _internal_has_createuserresponse();
}
inline void EditResponse::set_has_createuserresponse() {
  _impl_._oneof_case_[0] = kCreateUserResponse;
}
inline void EditResponse::clear_createuserresponse() {
  if (_internal_has_createuserresponse()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.response_.createuserresponse_;
    }
    clear_has_response();
  }
}
inline ::auth::EditResponse_CreateUser* EditResponse::release_createuserresponse() {
  // @@protoc_insertion_point(field_release:auth.EditResponse.createUserResponse)
  if (_internal_has_createuserresponse()) {
    clear_has_response();
    ::auth::EditResponse_CreateUser* temp = _impl_.response_.createuserresponse_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_.createuserresponse_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::auth::EditResponse_CreateUser& EditResponse::_internal_createuserresponse() const {
  return _internal_has_createuserresponse()
      ? *_impl_.response_.createuserresponse_
      : reinterpret_cast< ::auth::EditResponse_CreateUser&>(::auth::_EditResponse_CreateUser_default_instance_);
}
inline const ::auth::EditResponse_CreateUser& EditResponse::createuserresponse() const {
  // @@protoc_insertion_point(field_get:auth.EditResponse.createUserResponse)
  return _internal_createuserresponse();
}
inline ::auth::EditResponse_CreateUser* EditResponse::unsafe_arena_release_createuserresponse() {
  // @@protoc_insertion_point(field_unsafe_arena_release:auth.EditResponse.createUserResponse)
  if (_internal_has_createuserresponse()) {
    clear_has_response();
    ::auth::EditResponse_CreateUser* temp = _impl_.response_.createuserresponse_;
    _impl_.response_.createuserresponse_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EditResponse::unsafe_arena_set_allocated_createuserresponse(::auth::EditResponse_CreateUser* createuserresponse) {
  clear_response();
  if (createuserresponse) {
    set_has_createuserresponse();
    _impl_.response_.createuserresponse_ = createuserresponse;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:auth.EditResponse.createUserResponse)
}
inline ::auth::EditResponse_CreateUser* EditResponse::_internal_mutable_createuserresponse() {
  if (!_internal_has_createuserresponse()) {
    clear_response();
    set_has_createuserresponse();
    _impl_.response_.createuserresponse_ = CreateMaybeMessage< ::auth::EditResponse_CreateUser >(GetArenaForAllocation());
  }
  return _impl_.response_.createuserresponse_;
}
inline ::auth::EditResponse_CreateUser* EditResponse::mutable_createuserresponse() {
  ::auth::EditResponse_CreateUser* _msg = _internal_mutable_createuserresponse();
  // @@protoc_insertion_point(field_mutable:auth.EditResponse.createUserResponse)
  return _msg;
}

// .auth.EditResponse.CreateUserGroup createUserGroupResponse = 8;
inline bool EditResponse::_internal_has_createusergroupresponse() const {
  return response_case() == kCreateUserGroupResponse;
}
inline bool EditResponse::has_createusergroupresponse() const {
  return _internal_has_createusergroupresponse();
}
inline void EditResponse::set_has_createusergroupresponse() {
  _impl_._oneof_case_[0] = kCreateUserGroupResponse;
}
inline void EditResponse::clear_createusergroupresponse() {
  if (_internal_has_createusergroupresponse()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.response_.createusergroupresponse_;
    }
    clear_has_response();
  }
}
inline ::auth::EditResponse_CreateUserGroup* EditResponse::release_createusergroupresponse() {
  // @@protoc_insertion_point(field_release:auth.EditResponse.createUserGroupResponse)
  if (_internal_has_createusergroupresponse()) {
    clear_has_response();
    ::auth::EditResponse_CreateUserGroup* temp = _impl_.response_.createusergroupresponse_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_.createusergroupresponse_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::auth::EditResponse_CreateUserGroup& EditResponse::_internal_createusergroupresponse() const {
  return _internal_has_createusergroupresponse()
      ? *_impl_.response_.createusergroupresponse_
      : reinterpret_cast< ::auth::EditResponse_CreateUserGroup&>(::auth::_EditResponse_CreateUserGroup_default_instance_);
}
inline const ::auth::EditResponse_CreateUserGroup& EditResponse::createusergroupresponse() const {
  // @@protoc_insertion_point(field_get:auth.EditResponse.createUserGroupResponse)
  return _internal_createusergroupresponse();
}
inline ::auth::EditResponse_CreateUserGroup* EditResponse::unsafe_arena_release_createusergroupresponse() {
  // @@protoc_insertion_point(field_unsafe_arena_release:auth.EditResponse.createUserGroupResponse)
  if (_internal_has_createusergroupresponse()) {
    clear_has_response();
    ::auth::EditResponse_CreateUserGroup* temp = _impl_.response_.createusergroupresponse_;
    _impl_.response_.createusergroupresponse_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EditResponse::unsafe_arena_set_allocated_createusergroupresponse(::auth::EditResponse_CreateUserGroup* createusergroupresponse) {
  clear_response();
  if (createusergroupresponse) {
    set_has_createusergroupresponse();
    _impl_.response_.createusergroupresponse_ = createusergroupresponse;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:auth.EditResponse.createUserGroupResponse)
}
inline ::auth::EditResponse_CreateUserGroup* EditResponse::_internal_mutable_createusergroupresponse() {
  if (!_internal_has_createusergroupresponse()) {
    clear_response();
    set_has_createusergroupresponse();
    _impl_.response_.createusergroupresponse_ = CreateMaybeMessage< ::auth::EditResponse_CreateUserGroup >(GetArenaForAllocation());
  }
  return _impl_.response_.createusergroupresponse_;
}
inline ::auth::EditResponse_CreateUserGroup* EditResponse::mutable_createusergroupresponse() {
  ::auth::EditResponse_CreateUserGroup* _msg = _internal_mutable_createusergroupresponse();
  // @@protoc_insertion_point(field_mutable:auth.EditResponse.createUserGroupResponse)
  return _msg;
}

// .auth.EditResponse.GetUserGroupsResponse getUserGroupsResp = 9;
inline bool EditResponse::_internal_has_getusergroupsresp() const {
  return response_case() == kGetUserGroupsResp;
}
inline bool EditResponse::has_getusergroupsresp() const {
  return _internal_has_getusergroupsresp();
}
inline void EditResponse::set_has_getusergroupsresp() {
  _impl_._oneof_case_[0] = kGetUserGroupsResp;
}
inline void EditResponse::clear_getusergroupsresp() {
  if (_internal_has_getusergroupsresp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.response_.getusergroupsresp_;
    }
    clear_has_response();
  }
}
inline ::auth::EditResponse_GetUserGroupsResponse* EditResponse::release_getusergroupsresp() {
  // @@protoc_insertion_point(field_release:auth.EditResponse.getUserGroupsResp)
  if (_internal_has_getusergroupsresp()) {
    clear_has_response();
    ::auth::EditResponse_GetUserGroupsResponse* temp = _impl_.response_.getusergroupsresp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_.getusergroupsresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::auth::EditResponse_GetUserGroupsResponse& EditResponse::_internal_getusergroupsresp() const {
  return _internal_has_getusergroupsresp()
      ? *_impl_.response_.getusergroupsresp_
      : reinterpret_cast< ::auth::EditResponse_GetUserGroupsResponse&>(::auth::_EditResponse_GetUserGroupsResponse_default_instance_);
}
inline const ::auth::EditResponse_GetUserGroupsResponse& EditResponse::getusergroupsresp() const {
  // @@protoc_insertion_point(field_get:auth.EditResponse.getUserGroupsResp)
  return _internal_getusergroupsresp();
}
inline ::auth::EditResponse_GetUserGroupsResponse* EditResponse::unsafe_arena_release_getusergroupsresp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:auth.EditResponse.getUserGroupsResp)
  if (_internal_has_getusergroupsresp()) {
    clear_has_response();
    ::auth::EditResponse_GetUserGroupsResponse* temp = _impl_.response_.getusergroupsresp_;
    _impl_.response_.getusergroupsresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EditResponse::unsafe_arena_set_allocated_getusergroupsresp(::auth::EditResponse_GetUserGroupsResponse* getusergroupsresp) {
  clear_response();
  if (getusergroupsresp) {
    set_has_getusergroupsresp();
    _impl_.response_.getusergroupsresp_ = getusergroupsresp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:auth.EditResponse.getUserGroupsResp)
}
inline ::auth::EditResponse_GetUserGroupsResponse* EditResponse::_internal_mutable_getusergroupsresp() {
  if (!_internal_has_getusergroupsresp()) {
    clear_response();
    set_has_getusergroupsresp();
    _impl_.response_.getusergroupsresp_ = CreateMaybeMessage< ::auth::EditResponse_GetUserGroupsResponse >(GetArenaForAllocation());
  }
  return _impl_.response_.getusergroupsresp_;
}
inline ::auth::EditResponse_GetUserGroupsResponse* EditResponse::mutable_getusergroupsresp() {
  ::auth::EditResponse_GetUserGroupsResponse* _msg = _internal_mutable_getusergroupsresp();
  // @@protoc_insertion_point(field_mutable:auth.EditResponse.getUserGroupsResp)
  return _msg;
}

// .auth.EditResponse.GetUsersByGroupResponse getUsersByGroupResp = 10;
inline bool EditResponse::_internal_has_getusersbygroupresp() const {
  return response_case() == kGetUsersByGroupResp;
}
inline bool EditResponse::has_getusersbygroupresp() const {
  return _internal_has_getusersbygroupresp();
}
inline void EditResponse::set_has_getusersbygroupresp() {
  _impl_._oneof_case_[0] = kGetUsersByGroupResp;
}
inline void EditResponse::clear_getusersbygroupresp() {
  if (_internal_has_getusersbygroupresp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.response_.getusersbygroupresp_;
    }
    clear_has_response();
  }
}
inline ::auth::EditResponse_GetUsersByGroupResponse* EditResponse::release_getusersbygroupresp() {
  // @@protoc_insertion_point(field_release:auth.EditResponse.getUsersByGroupResp)
  if (_internal_has_getusersbygroupresp()) {
    clear_has_response();
    ::auth::EditResponse_GetUsersByGroupResponse* temp = _impl_.response_.getusersbygroupresp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_.getusersbygroupresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::auth::EditResponse_GetUsersByGroupResponse& EditResponse::_internal_getusersbygroupresp() const {
  return _internal_has_getusersbygroupresp()
      ? *_impl_.response_.getusersbygroupresp_
      : reinterpret_cast< ::auth::EditResponse_GetUsersByGroupResponse&>(::auth::_EditResponse_GetUsersByGroupResponse_default_instance_);
}
inline const ::auth::EditResponse_GetUsersByGroupResponse& EditResponse::getusersbygroupresp() const {
  // @@protoc_insertion_point(field_get:auth.EditResponse.getUsersByGroupResp)
  return _internal_getusersbygroupresp();
}
inline ::auth::EditResponse_GetUsersByGroupResponse* EditResponse::unsafe_arena_release_getusersbygroupresp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:auth.EditResponse.getUsersByGroupResp)
  if (_internal_has_getusersbygroupresp()) {
    clear_has_response();
    ::auth::EditResponse_GetUsersByGroupResponse* temp = _impl_.response_.getusersbygroupresp_;
    _impl_.response_.getusersbygroupresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EditResponse::unsafe_arena_set_allocated_getusersbygroupresp(::auth::EditResponse_GetUsersByGroupResponse* getusersbygroupresp) {
  clear_response();
  if (getusersbygroupresp) {
    set_has_getusersbygroupresp();
    _impl_.response_.getusersbygroupresp_ = getusersbygroupresp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:auth.EditResponse.getUsersByGroupResp)
}
inline ::auth::EditResponse_GetUsersByGroupResponse* EditResponse::_internal_mutable_getusersbygroupresp() {
  if (!_internal_has_getusersbygroupresp()) {
    clear_response();
    set_has_getusersbygroupresp();
    _impl_.response_.getusersbygroupresp_ = CreateMaybeMessage< ::auth::EditResponse_GetUsersByGroupResponse >(GetArenaForAllocation());
  }
  return _impl_.response_.getusersbygroupresp_;
}
inline ::auth::EditResponse_GetUsersByGroupResponse* EditResponse::mutable_getusersbygroupresp() {
  ::auth::EditResponse_GetUsersByGroupResponse* _msg = _internal_mutable_getusersbygroupresp();
  // @@protoc_insertion_point(field_mutable:auth.EditResponse.getUsersByGroupResp)
  return _msg;
}

// .auth.EditResponse.GetTerminal getTerminalResponse = 11;
inline bool EditResponse::_internal_has_getterminalresponse() const {
  return response_case() == kGetTerminalResponse;
}
inline bool EditResponse::has_getterminalresponse() const {
  return _internal_has_getterminalresponse();
}
inline void EditResponse::set_has_getterminalresponse() {
  _impl_._oneof_case_[0] = kGetTerminalResponse;
}
inline void EditResponse::clear_getterminalresponse() {
  if (_internal_has_getterminalresponse()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.response_.getterminalresponse_;
    }
    clear_has_response();
  }
}
inline ::auth::EditResponse_GetTerminal* EditResponse::release_getterminalresponse() {
  // @@protoc_insertion_point(field_release:auth.EditResponse.getTerminalResponse)
  if (_internal_has_getterminalresponse()) {
    clear_has_response();
    ::auth::EditResponse_GetTerminal* temp = _impl_.response_.getterminalresponse_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_.getterminalresponse_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::auth::EditResponse_GetTerminal& EditResponse::_internal_getterminalresponse() const {
  return _internal_has_getterminalresponse()
      ? *_impl_.response_.getterminalresponse_
      : reinterpret_cast< ::auth::EditResponse_GetTerminal&>(::auth::_EditResponse_GetTerminal_default_instance_);
}
inline const ::auth::EditResponse_GetTerminal& EditResponse::getterminalresponse() const {
  // @@protoc_insertion_point(field_get:auth.EditResponse.getTerminalResponse)
  return _internal_getterminalresponse();
}
inline ::auth::EditResponse_GetTerminal* EditResponse::unsafe_arena_release_getterminalresponse() {
  // @@protoc_insertion_point(field_unsafe_arena_release:auth.EditResponse.getTerminalResponse)
  if (_internal_has_getterminalresponse()) {
    clear_has_response();
    ::auth::EditResponse_GetTerminal* temp = _impl_.response_.getterminalresponse_;
    _impl_.response_.getterminalresponse_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EditResponse::unsafe_arena_set_allocated_getterminalresponse(::auth::EditResponse_GetTerminal* getterminalresponse) {
  clear_response();
  if (getterminalresponse) {
    set_has_getterminalresponse();
    _impl_.response_.getterminalresponse_ = getterminalresponse;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:auth.EditResponse.getTerminalResponse)
}
inline ::auth::EditResponse_GetTerminal* EditResponse::_internal_mutable_getterminalresponse() {
  if (!_internal_has_getterminalresponse()) {
    clear_response();
    set_has_getterminalresponse();
    _impl_.response_.getterminalresponse_ = CreateMaybeMessage< ::auth::EditResponse_GetTerminal >(GetArenaForAllocation());
  }
  return _impl_.response_.getterminalresponse_;
}
inline ::auth::EditResponse_GetTerminal* EditResponse::mutable_getterminalresponse() {
  ::auth::EditResponse_GetTerminal* _msg = _internal_mutable_getterminalresponse();
  // @@protoc_insertion_point(field_mutable:auth.EditResponse.getTerminalResponse)
  return _msg;
}

// .auth.EditResponse.UpdateTerminal updateTerminalResponse = 12;
inline bool EditResponse::_internal_has_updateterminalresponse() const {
  return response_case() == kUpdateTerminalResponse;
}
inline bool EditResponse::has_updateterminalresponse() const {
  return _internal_has_updateterminalresponse();
}
inline void EditResponse::set_has_updateterminalresponse() {
  _impl_._oneof_case_[0] = kUpdateTerminalResponse;
}
inline void EditResponse::clear_updateterminalresponse() {
  if (_internal_has_updateterminalresponse()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.response_.updateterminalresponse_;
    }
    clear_has_response();
  }
}
inline ::auth::EditResponse_UpdateTerminal* EditResponse::release_updateterminalresponse() {
  // @@protoc_insertion_point(field_release:auth.EditResponse.updateTerminalResponse)
  if (_internal_has_updateterminalresponse()) {
    clear_has_response();
    ::auth::EditResponse_UpdateTerminal* temp = _impl_.response_.updateterminalresponse_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_.updateterminalresponse_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::auth::EditResponse_UpdateTerminal& EditResponse::_internal_updateterminalresponse() const {
  return _internal_has_updateterminalresponse()
      ? *_impl_.response_.updateterminalresponse_
      : reinterpret_cast< ::auth::EditResponse_UpdateTerminal&>(::auth::_EditResponse_UpdateTerminal_default_instance_);
}
inline const ::auth::EditResponse_UpdateTerminal& EditResponse::updateterminalresponse() const {
  // @@protoc_insertion_point(field_get:auth.EditResponse.updateTerminalResponse)
  return _internal_updateterminalresponse();
}
inline ::auth::EditResponse_UpdateTerminal* EditResponse::unsafe_arena_release_updateterminalresponse() {
  // @@protoc_insertion_point(field_unsafe_arena_release:auth.EditResponse.updateTerminalResponse)
  if (_internal_has_updateterminalresponse()) {
    clear_has_response();
    ::auth::EditResponse_UpdateTerminal* temp = _impl_.response_.updateterminalresponse_;
    _impl_.response_.updateterminalresponse_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EditResponse::unsafe_arena_set_allocated_updateterminalresponse(::auth::EditResponse_UpdateTerminal* updateterminalresponse) {
  clear_response();
  if (updateterminalresponse) {
    set_has_updateterminalresponse();
    _impl_.response_.updateterminalresponse_ = updateterminalresponse;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:auth.EditResponse.updateTerminalResponse)
}
inline ::auth::EditResponse_UpdateTerminal* EditResponse::_internal_mutable_updateterminalresponse() {
  if (!_internal_has_updateterminalresponse()) {
    clear_response();
    set_has_updateterminalresponse();
    _impl_.response_.updateterminalresponse_ = CreateMaybeMessage< ::auth::EditResponse_UpdateTerminal >(GetArenaForAllocation());
  }
  return _impl_.response_.updateterminalresponse_;
}
inline ::auth::EditResponse_UpdateTerminal* EditResponse::mutable_updateterminalresponse() {
  ::auth::EditResponse_UpdateTerminal* _msg = _internal_mutable_updateterminalresponse();
  // @@protoc_insertion_point(field_mutable:auth.EditResponse.updateTerminalResponse)
  return _msg;
}

// .auth.EditResponse.DeleteTerminal deleteTerminalResponse = 13;
inline bool EditResponse::_internal_has_deleteterminalresponse() const {
  return response_case() == kDeleteTerminalResponse;
}
inline bool EditResponse::has_deleteterminalresponse() const {
  return _internal_has_deleteterminalresponse();
}
inline void EditResponse::set_has_deleteterminalresponse() {
  _impl_._oneof_case_[0] = kDeleteTerminalResponse;
}
inline void EditResponse::clear_deleteterminalresponse() {
  if (_internal_has_deleteterminalresponse()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.response_.deleteterminalresponse_;
    }
    clear_has_response();
  }
}
inline ::auth::EditResponse_DeleteTerminal* EditResponse::release_deleteterminalresponse() {
  // @@protoc_insertion_point(field_release:auth.EditResponse.deleteTerminalResponse)
  if (_internal_has_deleteterminalresponse()) {
    clear_has_response();
    ::auth::EditResponse_DeleteTerminal* temp = _impl_.response_.deleteterminalresponse_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_.deleteterminalresponse_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::auth::EditResponse_DeleteTerminal& EditResponse::_internal_deleteterminalresponse() const {
  return _internal_has_deleteterminalresponse()
      ? *_impl_.response_.deleteterminalresponse_
      : reinterpret_cast< ::auth::EditResponse_DeleteTerminal&>(::auth::_EditResponse_DeleteTerminal_default_instance_);
}
inline const ::auth::EditResponse_DeleteTerminal& EditResponse::deleteterminalresponse() const {
  // @@protoc_insertion_point(field_get:auth.EditResponse.deleteTerminalResponse)
  return _internal_deleteterminalresponse();
}
inline ::auth::EditResponse_DeleteTerminal* EditResponse::unsafe_arena_release_deleteterminalresponse() {
  // @@protoc_insertion_point(field_unsafe_arena_release:auth.EditResponse.deleteTerminalResponse)
  if (_internal_has_deleteterminalresponse()) {
    clear_has_response();
    ::auth::EditResponse_DeleteTerminal* temp = _impl_.response_.deleteterminalresponse_;
    _impl_.response_.deleteterminalresponse_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EditResponse::unsafe_arena_set_allocated_deleteterminalresponse(::auth::EditResponse_DeleteTerminal* deleteterminalresponse) {
  clear_response();
  if (deleteterminalresponse) {
    set_has_deleteterminalresponse();
    _impl_.response_.deleteterminalresponse_ = deleteterminalresponse;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:auth.EditResponse.deleteTerminalResponse)
}
inline ::auth::EditResponse_DeleteTerminal* EditResponse::_internal_mutable_deleteterminalresponse() {
  if (!_internal_has_deleteterminalresponse()) {
    clear_response();
    set_has_deleteterminalresponse();
    _impl_.response_.deleteterminalresponse_ = CreateMaybeMessage< ::auth::EditResponse_DeleteTerminal >(GetArenaForAllocation());
  }
  return _impl_.response_.deleteterminalresponse_;
}
inline ::auth::EditResponse_DeleteTerminal* EditResponse::mutable_deleteterminalresponse() {
  ::auth::EditResponse_DeleteTerminal* _msg = _internal_mutable_deleteterminalresponse();
  // @@protoc_insertion_point(field_mutable:auth.EditResponse.deleteTerminalResponse)
  return _msg;
}

// .auth.EditResponse.GetTerminals getTerminals = 14;
inline bool EditResponse::_internal_has_getterminals() const {
  return response_case() == kGetTerminals;
}
inline bool EditResponse::has_getterminals() const {
  return _internal_has_getterminals();
}
inline void EditResponse::set_has_getterminals() {
  _impl_._oneof_case_[0] = kGetTerminals;
}
inline void EditResponse::clear_getterminals() {
  if (_internal_has_getterminals()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.response_.getterminals_;
    }
    clear_has_response();
  }
}
inline ::auth::EditResponse_GetTerminals* EditResponse::release_getterminals() {
  // @@protoc_insertion_point(field_release:auth.EditResponse.getTerminals)
  if (_internal_has_getterminals()) {
    clear_has_response();
    ::auth::EditResponse_GetTerminals* temp = _impl_.response_.getterminals_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_.getterminals_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::auth::EditResponse_GetTerminals& EditResponse::_internal_getterminals() const {
  return _internal_has_getterminals()
      ? *_impl_.response_.getterminals_
      : reinterpret_cast< ::auth::EditResponse_GetTerminals&>(::auth::_EditResponse_GetTerminals_default_instance_);
}
inline const ::auth::EditResponse_GetTerminals& EditResponse::getterminals() const {
  // @@protoc_insertion_point(field_get:auth.EditResponse.getTerminals)
  return _internal_getterminals();
}
inline ::auth::EditResponse_GetTerminals* EditResponse::unsafe_arena_release_getterminals() {
  // @@protoc_insertion_point(field_unsafe_arena_release:auth.EditResponse.getTerminals)
  if (_internal_has_getterminals()) {
    clear_has_response();
    ::auth::EditResponse_GetTerminals* temp = _impl_.response_.getterminals_;
    _impl_.response_.getterminals_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EditResponse::unsafe_arena_set_allocated_getterminals(::auth::EditResponse_GetTerminals* getterminals) {
  clear_response();
  if (getterminals) {
    set_has_getterminals();
    _impl_.response_.getterminals_ = getterminals;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:auth.EditResponse.getTerminals)
}
inline ::auth::EditResponse_GetTerminals* EditResponse::_internal_mutable_getterminals() {
  if (!_internal_has_getterminals()) {
    clear_response();
    set_has_getterminals();
    _impl_.response_.getterminals_ = CreateMaybeMessage< ::auth::EditResponse_GetTerminals >(GetArenaForAllocation());
  }
  return _impl_.response_.getterminals_;
}
inline ::auth::EditResponse_GetTerminals* EditResponse::mutable_getterminals() {
  ::auth::EditResponse_GetTerminals* _msg = _internal_mutable_getterminals();
  // @@protoc_insertion_point(field_mutable:auth.EditResponse.getTerminals)
  return _msg;
}

// .auth.EditResponse.CreateTerminal createTerminalResponse = 15;
inline bool EditResponse::_internal_has_createterminalresponse() const {
  return response_case() == kCreateTerminalResponse;
}
inline bool EditResponse::has_createterminalresponse() const {
  return _internal_has_createterminalresponse();
}
inline void EditResponse::set_has_createterminalresponse() {
  _impl_._oneof_case_[0] = kCreateTerminalResponse;
}
inline void EditResponse::clear_createterminalresponse() {
  if (_internal_has_createterminalresponse()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.response_.createterminalresponse_;
    }
    clear_has_response();
  }
}
inline ::auth::EditResponse_CreateTerminal* EditResponse::release_createterminalresponse() {
  // @@protoc_insertion_point(field_release:auth.EditResponse.createTerminalResponse)
  if (_internal_has_createterminalresponse()) {
    clear_has_response();
    ::auth::EditResponse_CreateTerminal* temp = _impl_.response_.createterminalresponse_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_.createterminalresponse_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::auth::EditResponse_CreateTerminal& EditResponse::_internal_createterminalresponse() const {
  return _internal_has_createterminalresponse()
      ? *_impl_.response_.createterminalresponse_
      : reinterpret_cast< ::auth::EditResponse_CreateTerminal&>(::auth::_EditResponse_CreateTerminal_default_instance_);
}
inline const ::auth::EditResponse_CreateTerminal& EditResponse::createterminalresponse() const {
  // @@protoc_insertion_point(field_get:auth.EditResponse.createTerminalResponse)
  return _internal_createterminalresponse();
}
inline ::auth::EditResponse_CreateTerminal* EditResponse::unsafe_arena_release_createterminalresponse() {
  // @@protoc_insertion_point(field_unsafe_arena_release:auth.EditResponse.createTerminalResponse)
  if (_internal_has_createterminalresponse()) {
    clear_has_response();
    ::auth::EditResponse_CreateTerminal* temp = _impl_.response_.createterminalresponse_;
    _impl_.response_.createterminalresponse_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EditResponse::unsafe_arena_set_allocated_createterminalresponse(::auth::EditResponse_CreateTerminal* createterminalresponse) {
  clear_response();
  if (createterminalresponse) {
    set_has_createterminalresponse();
    _impl_.response_.createterminalresponse_ = createterminalresponse;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:auth.EditResponse.createTerminalResponse)
}
inline ::auth::EditResponse_CreateTerminal* EditResponse::_internal_mutable_createterminalresponse() {
  if (!_internal_has_createterminalresponse()) {
    clear_response();
    set_has_createterminalresponse();
    _impl_.response_.createterminalresponse_ = CreateMaybeMessage< ::auth::EditResponse_CreateTerminal >(GetArenaForAllocation());
  }
  return _impl_.response_.createterminalresponse_;
}
inline ::auth::EditResponse_CreateTerminal* EditResponse::mutable_createterminalresponse() {
  ::auth::EditResponse_CreateTerminal* _msg = _internal_mutable_createterminalresponse();
  // @@protoc_insertion_point(field_mutable:auth.EditResponse.createTerminalResponse)
  return _msg;
}

inline bool EditResponse::has_response() const {
  return response_case() != RESPONSE_NOT_SET;
}
inline void EditResponse::clear_has_response() {
  _impl_._oneof_case_[0] = RESPONSE_NOT_SET;
}
inline EditResponse::ResponseCase EditResponse::response_case() const {
  return EditResponse::ResponseCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// SubscribeCommands_Subscribe

// -------------------------------------------------------------------

// SubscribeCommands_Unsubscribe

// -------------------------------------------------------------------

// SubscribeCommands

// .auth.SubscribeCommands.Subscribe subscribe = 1;
inline bool SubscribeCommands::_internal_has_subscribe() const {
  return event_case() == kSubscribe;
}
inline bool SubscribeCommands::has_subscribe() const {
  return _internal_has_subscribe();
}
inline void SubscribeCommands::set_has_subscribe() {
  _impl_._oneof_case_[0] = kSubscribe;
}
inline void SubscribeCommands::clear_subscribe() {
  if (_internal_has_subscribe()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_.subscribe_;
    }
    clear_has_event();
  }
}
inline ::auth::SubscribeCommands_Subscribe* SubscribeCommands::release_subscribe() {
  // @@protoc_insertion_point(field_release:auth.SubscribeCommands.subscribe)
  if (_internal_has_subscribe()) {
    clear_has_event();
    ::auth::SubscribeCommands_Subscribe* temp = _impl_.event_.subscribe_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.subscribe_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::auth::SubscribeCommands_Subscribe& SubscribeCommands::_internal_subscribe() const {
  return _internal_has_subscribe()
      ? *_impl_.event_.subscribe_
      : reinterpret_cast< ::auth::SubscribeCommands_Subscribe&>(::auth::_SubscribeCommands_Subscribe_default_instance_);
}
inline const ::auth::SubscribeCommands_Subscribe& SubscribeCommands::subscribe() const {
  // @@protoc_insertion_point(field_get:auth.SubscribeCommands.subscribe)
  return _internal_subscribe();
}
inline ::auth::SubscribeCommands_Subscribe* SubscribeCommands::unsafe_arena_release_subscribe() {
  // @@protoc_insertion_point(field_unsafe_arena_release:auth.SubscribeCommands.subscribe)
  if (_internal_has_subscribe()) {
    clear_has_event();
    ::auth::SubscribeCommands_Subscribe* temp = _impl_.event_.subscribe_;
    _impl_.event_.subscribe_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SubscribeCommands::unsafe_arena_set_allocated_subscribe(::auth::SubscribeCommands_Subscribe* subscribe) {
  clear_event();
  if (subscribe) {
    set_has_subscribe();
    _impl_.event_.subscribe_ = subscribe;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:auth.SubscribeCommands.subscribe)
}
inline ::auth::SubscribeCommands_Subscribe* SubscribeCommands::_internal_mutable_subscribe() {
  if (!_internal_has_subscribe()) {
    clear_event();
    set_has_subscribe();
    _impl_.event_.subscribe_ = CreateMaybeMessage< ::auth::SubscribeCommands_Subscribe >(GetArenaForAllocation());
  }
  return _impl_.event_.subscribe_;
}
inline ::auth::SubscribeCommands_Subscribe* SubscribeCommands::mutable_subscribe() {
  ::auth::SubscribeCommands_Subscribe* _msg = _internal_mutable_subscribe();
  // @@protoc_insertion_point(field_mutable:auth.SubscribeCommands.subscribe)
  return _msg;
}

// .auth.SubscribeCommands.Unsubscribe unsubscribe = 2;
inline bool SubscribeCommands::_internal_has_unsubscribe() const {
  return event_case() == kUnsubscribe;
}
inline bool SubscribeCommands::has_unsubscribe() const {
  return _internal_has_unsubscribe();
}
inline void SubscribeCommands::set_has_unsubscribe() {
  _impl_._oneof_case_[0] = kUnsubscribe;
}
inline void SubscribeCommands::clear_unsubscribe() {
  if (_internal_has_unsubscribe()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_.unsubscribe_;
    }
    clear_has_event();
  }
}
inline ::auth::SubscribeCommands_Unsubscribe* SubscribeCommands::release_unsubscribe() {
  // @@protoc_insertion_point(field_release:auth.SubscribeCommands.unsubscribe)
  if (_internal_has_unsubscribe()) {
    clear_has_event();
    ::auth::SubscribeCommands_Unsubscribe* temp = _impl_.event_.unsubscribe_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.unsubscribe_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::auth::SubscribeCommands_Unsubscribe& SubscribeCommands::_internal_unsubscribe() const {
  return _internal_has_unsubscribe()
      ? *_impl_.event_.unsubscribe_
      : reinterpret_cast< ::auth::SubscribeCommands_Unsubscribe&>(::auth::_SubscribeCommands_Unsubscribe_default_instance_);
}
inline const ::auth::SubscribeCommands_Unsubscribe& SubscribeCommands::unsubscribe() const {
  // @@protoc_insertion_point(field_get:auth.SubscribeCommands.unsubscribe)
  return _internal_unsubscribe();
}
inline ::auth::SubscribeCommands_Unsubscribe* SubscribeCommands::unsafe_arena_release_unsubscribe() {
  // @@protoc_insertion_point(field_unsafe_arena_release:auth.SubscribeCommands.unsubscribe)
  if (_internal_has_unsubscribe()) {
    clear_has_event();
    ::auth::SubscribeCommands_Unsubscribe* temp = _impl_.event_.unsubscribe_;
    _impl_.event_.unsubscribe_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SubscribeCommands::unsafe_arena_set_allocated_unsubscribe(::auth::SubscribeCommands_Unsubscribe* unsubscribe) {
  clear_event();
  if (unsubscribe) {
    set_has_unsubscribe();
    _impl_.event_.unsubscribe_ = unsubscribe;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:auth.SubscribeCommands.unsubscribe)
}
inline ::auth::SubscribeCommands_Unsubscribe* SubscribeCommands::_internal_mutable_unsubscribe() {
  if (!_internal_has_unsubscribe()) {
    clear_event();
    set_has_unsubscribe();
    _impl_.event_.unsubscribe_ = CreateMaybeMessage< ::auth::SubscribeCommands_Unsubscribe >(GetArenaForAllocation());
  }
  return _impl_.event_.unsubscribe_;
}
inline ::auth::SubscribeCommands_Unsubscribe* SubscribeCommands::mutable_unsubscribe() {
  ::auth::SubscribeCommands_Unsubscribe* _msg = _internal_mutable_unsubscribe();
  // @@protoc_insertion_point(field_mutable:auth.SubscribeCommands.unsubscribe)
  return _msg;
}

inline bool SubscribeCommands::has_event() const {
  return event_case() != EVENT_NOT_SET;
}
inline void SubscribeCommands::clear_has_event() {
  _impl_._oneof_case_[0] = EVENT_NOT_SET;
}
inline SubscribeCommands::EventCase SubscribeCommands::event_case() const {
  return SubscribeCommands::EventCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Events_Event

// .auth.EventType etype = 1;
inline void Events_Event::clear_etype() {
  _impl_.etype_ = 0;
}
inline ::auth::EventType Events_Event::_internal_etype() const {
  return static_cast< ::auth::EventType >(_impl_.etype_);
}
inline ::auth::EventType Events_Event::etype() const {
  // @@protoc_insertion_point(field_get:auth.Events.Event.etype)
  return _internal_etype();
}
inline void Events_Event::_internal_set_etype(::auth::EventType value) {
  
  _impl_.etype_ = value;
}
inline void Events_Event::set_etype(::auth::EventType value) {
  _internal_set_etype(value);
  // @@protoc_insertion_point(field_set:auth.Events.Event.etype)
}

// repeated uint64 ids = 2;
inline int Events_Event::_internal_ids_size() const {
  return _impl_.ids_.size();
}
inline int Events_Event::ids_size() const {
  return _internal_ids_size();
}
inline void Events_Event::clear_ids() {
  _impl_.ids_.Clear();
}
inline uint64_t Events_Event::_internal_ids(int index) const {
  return _impl_.ids_.Get(index);
}
inline uint64_t Events_Event::ids(int index) const {
  // @@protoc_insertion_point(field_get:auth.Events.Event.ids)
  return _internal_ids(index);
}
inline void Events_Event::set_ids(int index, uint64_t value) {
  _impl_.ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:auth.Events.Event.ids)
}
inline void Events_Event::_internal_add_ids(uint64_t value) {
  _impl_.ids_.Add(value);
}
inline void Events_Event::add_ids(uint64_t value) {
  _internal_add_ids(value);
  // @@protoc_insertion_point(field_add:auth.Events.Event.ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
Events_Event::_internal_ids() const {
  return _impl_.ids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
Events_Event::ids() const {
  // @@protoc_insertion_point(field_list:auth.Events.Event.ids)
  return _internal_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
Events_Event::_internal_mutable_ids() {
  return &_impl_.ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
Events_Event::mutable_ids() {
  // @@protoc_insertion_point(field_mutable_list:auth.Events.Event.ids)
  return _internal_mutable_ids();
}

// -------------------------------------------------------------------

// Events

// string author = 1;
inline void Events::clear_author() {
  _impl_.author_.ClearToEmpty();
}
inline const std::string& Events::author() const {
  // @@protoc_insertion_point(field_get:auth.Events.author)
  return _internal_author();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Events::set_author(ArgT0&& arg0, ArgT... args) {
 
 _impl_.author_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:auth.Events.author)
}
inline std::string* Events::mutable_author() {
  std::string* _s = _internal_mutable_author();
  // @@protoc_insertion_point(field_mutable:auth.Events.author)
  return _s;
}
inline const std::string& Events::_internal_author() const {
  return _impl_.author_.Get();
}
inline void Events::_internal_set_author(const std::string& value) {
  
  _impl_.author_.Set(value, GetArenaForAllocation());
}
inline std::string* Events::_internal_mutable_author() {
  
  return _impl_.author_.Mutable(GetArenaForAllocation());
}
inline std::string* Events::release_author() {
  // @@protoc_insertion_point(field_release:auth.Events.author)
  return _impl_.author_.Release();
}
inline void Events::set_allocated_author(std::string* author) {
  if (author != nullptr) {
    
  } else {
    
  }
  _impl_.author_.SetAllocated(author, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.author_.IsDefault()) {
    _impl_.author_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:auth.Events.author)
}

// repeated .auth.Events.Event events = 2;
inline int Events::_internal_events_size() const {
  return _impl_.events_.size();
}
inline int Events::events_size() const {
  return _internal_events_size();
}
inline void Events::clear_events() {
  _impl_.events_.Clear();
}
inline ::auth::Events_Event* Events::mutable_events(int index) {
  // @@protoc_insertion_point(field_mutable:auth.Events.events)
  return _impl_.events_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::auth::Events_Event >*
Events::mutable_events() {
  // @@protoc_insertion_point(field_mutable_list:auth.Events.events)
  return &_impl_.events_;
}
inline const ::auth::Events_Event& Events::_internal_events(int index) const {
  return _impl_.events_.Get(index);
}
inline const ::auth::Events_Event& Events::events(int index) const {
  // @@protoc_insertion_point(field_get:auth.Events.events)
  return _internal_events(index);
}
inline ::auth::Events_Event* Events::_internal_add_events() {
  return _impl_.events_.Add();
}
inline ::auth::Events_Event* Events::add_events() {
  ::auth::Events_Event* _add = _internal_add_events();
  // @@protoc_insertion_point(field_add:auth.Events.events)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::auth::Events_Event >&
Events::events() const {
  // @@protoc_insertion_point(field_list:auth.Events.events)
  return _impl_.events_;
}

// -------------------------------------------------------------------

// User

// uint64 id = 1;
inline void User::clear_id() {
  _impl_.id_ = uint64_t{0u};
}
inline uint64_t User::_internal_id() const {
  return _impl_.id_;
}
inline uint64_t User::id() const {
  // @@protoc_insertion_point(field_get:auth.User.id)
  return _internal_id();
}
inline void User::_internal_set_id(uint64_t value) {
  
  _impl_.id_ = value;
}
inline void User::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:auth.User.id)
}

// string login = 2;
inline void User::clear_login() {
  _impl_.login_.ClearToEmpty();
}
inline const std::string& User::login() const {
  // @@protoc_insertion_point(field_get:auth.User.login)
  return _internal_login();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void User::set_login(ArgT0&& arg0, ArgT... args) {
 
 _impl_.login_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:auth.User.login)
}
inline std::string* User::mutable_login() {
  std::string* _s = _internal_mutable_login();
  // @@protoc_insertion_point(field_mutable:auth.User.login)
  return _s;
}
inline const std::string& User::_internal_login() const {
  return _impl_.login_.Get();
}
inline void User::_internal_set_login(const std::string& value) {
  
  _impl_.login_.Set(value, GetArenaForAllocation());
}
inline std::string* User::_internal_mutable_login() {
  
  return _impl_.login_.Mutable(GetArenaForAllocation());
}
inline std::string* User::release_login() {
  // @@protoc_insertion_point(field_release:auth.User.login)
  return _impl_.login_.Release();
}
inline void User::set_allocated_login(std::string* login) {
  if (login != nullptr) {
    
  } else {
    
  }
  _impl_.login_.SetAllocated(login, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.login_.IsDefault()) {
    _impl_.login_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:auth.User.login)
}

// string pass = 3;
inline void User::clear_pass() {
  _impl_.pass_.ClearToEmpty();
}
inline const std::string& User::pass() const {
  // @@protoc_insertion_point(field_get:auth.User.pass)
  return _internal_pass();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void User::set_pass(ArgT0&& arg0, ArgT... args) {
 
 _impl_.pass_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:auth.User.pass)
}
inline std::string* User::mutable_pass() {
  std::string* _s = _internal_mutable_pass();
  // @@protoc_insertion_point(field_mutable:auth.User.pass)
  return _s;
}
inline const std::string& User::_internal_pass() const {
  return _impl_.pass_.Get();
}
inline void User::_internal_set_pass(const std::string& value) {
  
  _impl_.pass_.Set(value, GetArenaForAllocation());
}
inline std::string* User::_internal_mutable_pass() {
  
  return _impl_.pass_.Mutable(GetArenaForAllocation());
}
inline std::string* User::release_pass() {
  // @@protoc_insertion_point(field_release:auth.User.pass)
  return _impl_.pass_.Release();
}
inline void User::set_allocated_pass(std::string* pass) {
  if (pass != nullptr) {
    
  } else {
    
  }
  _impl_.pass_.SetAllocated(pass, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pass_.IsDefault()) {
    _impl_.pass_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:auth.User.pass)
}

// uint64 groupid = 4;
inline void User::clear_groupid() {
  _impl_.groupid_ = uint64_t{0u};
}
inline uint64_t User::_internal_groupid() const {
  return _impl_.groupid_;
}
inline uint64_t User::groupid() const {
  // @@protoc_insertion_point(field_get:auth.User.groupid)
  return _internal_groupid();
}
inline void User::_internal_set_groupid(uint64_t value) {
  
  _impl_.groupid_ = value;
}
inline void User::set_groupid(uint64_t value) {
  _internal_set_groupid(value);
  // @@protoc_insertion_point(field_set:auth.User.groupid)
}

// uint64 sessionid = 5;
inline void User::clear_sessionid() {
  _impl_.sessionid_ = uint64_t{0u};
}
inline uint64_t User::_internal_sessionid() const {
  return _impl_.sessionid_;
}
inline uint64_t User::sessionid() const {
  // @@protoc_insertion_point(field_get:auth.User.sessionid)
  return _internal_sessionid();
}
inline void User::_internal_set_sessionid(uint64_t value) {
  
  _impl_.sessionid_ = value;
}
inline void User::set_sessionid(uint64_t value) {
  _internal_set_sessionid(value);
  // @@protoc_insertion_point(field_set:auth.User.sessionid)
}

// -------------------------------------------------------------------

// Credentials

// string login = 1;
inline void Credentials::clear_login() {
  _impl_.login_.ClearToEmpty();
}
inline const std::string& Credentials::login() const {
  // @@protoc_insertion_point(field_get:auth.Credentials.login)
  return _internal_login();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Credentials::set_login(ArgT0&& arg0, ArgT... args) {
 
 _impl_.login_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:auth.Credentials.login)
}
inline std::string* Credentials::mutable_login() {
  std::string* _s = _internal_mutable_login();
  // @@protoc_insertion_point(field_mutable:auth.Credentials.login)
  return _s;
}
inline const std::string& Credentials::_internal_login() const {
  return _impl_.login_.Get();
}
inline void Credentials::_internal_set_login(const std::string& value) {
  
  _impl_.login_.Set(value, GetArenaForAllocation());
}
inline std::string* Credentials::_internal_mutable_login() {
  
  return _impl_.login_.Mutable(GetArenaForAllocation());
}
inline std::string* Credentials::release_login() {
  // @@protoc_insertion_point(field_release:auth.Credentials.login)
  return _impl_.login_.Release();
}
inline void Credentials::set_allocated_login(std::string* login) {
  if (login != nullptr) {
    
  } else {
    
  }
  _impl_.login_.SetAllocated(login, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.login_.IsDefault()) {
    _impl_.login_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:auth.Credentials.login)
}

// string pass = 2;
inline void Credentials::clear_pass() {
  _impl_.pass_.ClearToEmpty();
}
inline const std::string& Credentials::pass() const {
  // @@protoc_insertion_point(field_get:auth.Credentials.pass)
  return _internal_pass();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Credentials::set_pass(ArgT0&& arg0, ArgT... args) {
 
 _impl_.pass_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:auth.Credentials.pass)
}
inline std::string* Credentials::mutable_pass() {
  std::string* _s = _internal_mutable_pass();
  // @@protoc_insertion_point(field_mutable:auth.Credentials.pass)
  return _s;
}
inline const std::string& Credentials::_internal_pass() const {
  return _impl_.pass_.Get();
}
inline void Credentials::_internal_set_pass(const std::string& value) {
  
  _impl_.pass_.Set(value, GetArenaForAllocation());
}
inline std::string* Credentials::_internal_mutable_pass() {
  
  return _impl_.pass_.Mutable(GetArenaForAllocation());
}
inline std::string* Credentials::release_pass() {
  // @@protoc_insertion_point(field_release:auth.Credentials.pass)
  return _impl_.pass_.Release();
}
inline void Credentials::set_allocated_pass(std::string* pass) {
  if (pass != nullptr) {
    
  } else {
    
  }
  _impl_.pass_.SetAllocated(pass, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pass_.IsDefault()) {
    _impl_.pass_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:auth.Credentials.pass)
}

// string terminalNumber = 3;
inline void Credentials::clear_terminalnumber() {
  _impl_.terminalnumber_.ClearToEmpty();
}
inline const std::string& Credentials::terminalnumber() const {
  // @@protoc_insertion_point(field_get:auth.Credentials.terminalNumber)
  return _internal_terminalnumber();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Credentials::set_terminalnumber(ArgT0&& arg0, ArgT... args) {
 
 _impl_.terminalnumber_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:auth.Credentials.terminalNumber)
}
inline std::string* Credentials::mutable_terminalnumber() {
  std::string* _s = _internal_mutable_terminalnumber();
  // @@protoc_insertion_point(field_mutable:auth.Credentials.terminalNumber)
  return _s;
}
inline const std::string& Credentials::_internal_terminalnumber() const {
  return _impl_.terminalnumber_.Get();
}
inline void Credentials::_internal_set_terminalnumber(const std::string& value) {
  
  _impl_.terminalnumber_.Set(value, GetArenaForAllocation());
}
inline std::string* Credentials::_internal_mutable_terminalnumber() {
  
  return _impl_.terminalnumber_.Mutable(GetArenaForAllocation());
}
inline std::string* Credentials::release_terminalnumber() {
  // @@protoc_insertion_point(field_release:auth.Credentials.terminalNumber)
  return _impl_.terminalnumber_.Release();
}
inline void Credentials::set_allocated_terminalnumber(std::string* terminalnumber) {
  if (terminalnumber != nullptr) {
    
  } else {
    
  }
  _impl_.terminalnumber_.SetAllocated(terminalnumber, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.terminalnumber_.IsDefault()) {
    _impl_.terminalnumber_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:auth.Credentials.terminalNumber)
}

// -------------------------------------------------------------------

// LoginRequest_Logout

// -------------------------------------------------------------------

// LoginRequest

// .auth.Credentials credentials = 1;
inline bool LoginRequest::_internal_has_credentials() const {
  return req_case() == kCredentials;
}
inline bool LoginRequest::has_credentials() const {
  return _internal_has_credentials();
}
inline void LoginRequest::set_has_credentials() {
  _impl_._oneof_case_[0] = kCredentials;
}
inline void LoginRequest::clear_credentials() {
  if (_internal_has_credentials()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.req_.credentials_;
    }
    clear_has_req();
  }
}
inline ::auth::Credentials* LoginRequest::release_credentials() {
  // @@protoc_insertion_point(field_release:auth.LoginRequest.credentials)
  if (_internal_has_credentials()) {
    clear_has_req();
    ::auth::Credentials* temp = _impl_.req_.credentials_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.req_.credentials_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::auth::Credentials& LoginRequest::_internal_credentials() const {
  return _internal_has_credentials()
      ? *_impl_.req_.credentials_
      : reinterpret_cast< ::auth::Credentials&>(::auth::_Credentials_default_instance_);
}
inline const ::auth::Credentials& LoginRequest::credentials() const {
  // @@protoc_insertion_point(field_get:auth.LoginRequest.credentials)
  return _internal_credentials();
}
inline ::auth::Credentials* LoginRequest::unsafe_arena_release_credentials() {
  // @@protoc_insertion_point(field_unsafe_arena_release:auth.LoginRequest.credentials)
  if (_internal_has_credentials()) {
    clear_has_req();
    ::auth::Credentials* temp = _impl_.req_.credentials_;
    _impl_.req_.credentials_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LoginRequest::unsafe_arena_set_allocated_credentials(::auth::Credentials* credentials) {
  clear_req();
  if (credentials) {
    set_has_credentials();
    _impl_.req_.credentials_ = credentials;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:auth.LoginRequest.credentials)
}
inline ::auth::Credentials* LoginRequest::_internal_mutable_credentials() {
  if (!_internal_has_credentials()) {
    clear_req();
    set_has_credentials();
    _impl_.req_.credentials_ = CreateMaybeMessage< ::auth::Credentials >(GetArenaForAllocation());
  }
  return _impl_.req_.credentials_;
}
inline ::auth::Credentials* LoginRequest::mutable_credentials() {
  ::auth::Credentials* _msg = _internal_mutable_credentials();
  // @@protoc_insertion_point(field_mutable:auth.LoginRequest.credentials)
  return _msg;
}

// .auth.LoginRequest.Logout logout = 2;
inline bool LoginRequest::_internal_has_logout() const {
  return req_case() == kLogout;
}
inline bool LoginRequest::has_logout() const {
  return _internal_has_logout();
}
inline void LoginRequest::set_has_logout() {
  _impl_._oneof_case_[0] = kLogout;
}
inline void LoginRequest::clear_logout() {
  if (_internal_has_logout()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.req_.logout_;
    }
    clear_has_req();
  }
}
inline ::auth::LoginRequest_Logout* LoginRequest::release_logout() {
  // @@protoc_insertion_point(field_release:auth.LoginRequest.logout)
  if (_internal_has_logout()) {
    clear_has_req();
    ::auth::LoginRequest_Logout* temp = _impl_.req_.logout_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.req_.logout_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::auth::LoginRequest_Logout& LoginRequest::_internal_logout() const {
  return _internal_has_logout()
      ? *_impl_.req_.logout_
      : reinterpret_cast< ::auth::LoginRequest_Logout&>(::auth::_LoginRequest_Logout_default_instance_);
}
inline const ::auth::LoginRequest_Logout& LoginRequest::logout() const {
  // @@protoc_insertion_point(field_get:auth.LoginRequest.logout)
  return _internal_logout();
}
inline ::auth::LoginRequest_Logout* LoginRequest::unsafe_arena_release_logout() {
  // @@protoc_insertion_point(field_unsafe_arena_release:auth.LoginRequest.logout)
  if (_internal_has_logout()) {
    clear_has_req();
    ::auth::LoginRequest_Logout* temp = _impl_.req_.logout_;
    _impl_.req_.logout_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LoginRequest::unsafe_arena_set_allocated_logout(::auth::LoginRequest_Logout* logout) {
  clear_req();
  if (logout) {
    set_has_logout();
    _impl_.req_.logout_ = logout;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:auth.LoginRequest.logout)
}
inline ::auth::LoginRequest_Logout* LoginRequest::_internal_mutable_logout() {
  if (!_internal_has_logout()) {
    clear_req();
    set_has_logout();
    _impl_.req_.logout_ = CreateMaybeMessage< ::auth::LoginRequest_Logout >(GetArenaForAllocation());
  }
  return _impl_.req_.logout_;
}
inline ::auth::LoginRequest_Logout* LoginRequest::mutable_logout() {
  ::auth::LoginRequest_Logout* _msg = _internal_mutable_logout();
  // @@protoc_insertion_point(field_mutable:auth.LoginRequest.logout)
  return _msg;
}

inline bool LoginRequest::has_req() const {
  return req_case() != REQ_NOT_SET;
}
inline void LoginRequest::clear_has_req() {
  _impl_._oneof_case_[0] = REQ_NOT_SET;
}
inline LoginRequest::ReqCase LoginRequest::req_case() const {
  return LoginRequest::ReqCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// LoginResponse

// .auth.Token token = 1;
inline bool LoginResponse::_internal_has_token() const {
  return res_case() == kToken;
}
inline bool LoginResponse::has_token() const {
  return _internal_has_token();
}
inline void LoginResponse::set_has_token() {
  _impl_._oneof_case_[0] = kToken;
}
inline void LoginResponse::clear_token() {
  if (_internal_has_token()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.res_.token_;
    }
    clear_has_res();
  }
}
inline ::auth::Token* LoginResponse::release_token() {
  // @@protoc_insertion_point(field_release:auth.LoginResponse.token)
  if (_internal_has_token()) {
    clear_has_res();
    ::auth::Token* temp = _impl_.res_.token_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.res_.token_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::auth::Token& LoginResponse::_internal_token() const {
  return _internal_has_token()
      ? *_impl_.res_.token_
      : reinterpret_cast< ::auth::Token&>(::auth::_Token_default_instance_);
}
inline const ::auth::Token& LoginResponse::token() const {
  // @@protoc_insertion_point(field_get:auth.LoginResponse.token)
  return _internal_token();
}
inline ::auth::Token* LoginResponse::unsafe_arena_release_token() {
  // @@protoc_insertion_point(field_unsafe_arena_release:auth.LoginResponse.token)
  if (_internal_has_token()) {
    clear_has_res();
    ::auth::Token* temp = _impl_.res_.token_;
    _impl_.res_.token_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LoginResponse::unsafe_arena_set_allocated_token(::auth::Token* token) {
  clear_res();
  if (token) {
    set_has_token();
    _impl_.res_.token_ = token;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:auth.LoginResponse.token)
}
inline ::auth::Token* LoginResponse::_internal_mutable_token() {
  if (!_internal_has_token()) {
    clear_res();
    set_has_token();
    _impl_.res_.token_ = CreateMaybeMessage< ::auth::Token >(GetArenaForAllocation());
  }
  return _impl_.res_.token_;
}
inline ::auth::Token* LoginResponse::mutable_token() {
  ::auth::Token* _msg = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:auth.LoginResponse.token)
  return _msg;
}

// .auth.Error error = 2;
inline bool LoginResponse::_internal_has_error() const {
  return res_case() == kError;
}
inline bool LoginResponse::has_error() const {
  return _internal_has_error();
}
inline void LoginResponse::set_has_error() {
  _impl_._oneof_case_[0] = kError;
}
inline void LoginResponse::clear_error() {
  if (_internal_has_error()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.res_.error_;
    }
    clear_has_res();
  }
}
inline ::auth::Error* LoginResponse::release_error() {
  // @@protoc_insertion_point(field_release:auth.LoginResponse.error)
  if (_internal_has_error()) {
    clear_has_res();
    ::auth::Error* temp = _impl_.res_.error_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.res_.error_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::auth::Error& LoginResponse::_internal_error() const {
  return _internal_has_error()
      ? *_impl_.res_.error_
      : reinterpret_cast< ::auth::Error&>(::auth::_Error_default_instance_);
}
inline const ::auth::Error& LoginResponse::error() const {
  // @@protoc_insertion_point(field_get:auth.LoginResponse.error)
  return _internal_error();
}
inline ::auth::Error* LoginResponse::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_unsafe_arena_release:auth.LoginResponse.error)
  if (_internal_has_error()) {
    clear_has_res();
    ::auth::Error* temp = _impl_.res_.error_;
    _impl_.res_.error_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LoginResponse::unsafe_arena_set_allocated_error(::auth::Error* error) {
  clear_res();
  if (error) {
    set_has_error();
    _impl_.res_.error_ = error;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:auth.LoginResponse.error)
}
inline ::auth::Error* LoginResponse::_internal_mutable_error() {
  if (!_internal_has_error()) {
    clear_res();
    set_has_error();
    _impl_.res_.error_ = CreateMaybeMessage< ::auth::Error >(GetArenaForAllocation());
  }
  return _impl_.res_.error_;
}
inline ::auth::Error* LoginResponse::mutable_error() {
  ::auth::Error* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:auth.LoginResponse.error)
  return _msg;
}

inline bool LoginResponse::has_res() const {
  return res_case() != RES_NOT_SET;
}
inline void LoginResponse::clear_has_res() {
  _impl_._oneof_case_[0] = RES_NOT_SET;
}
inline LoginResponse::ResCase LoginResponse::res_case() const {
  return LoginResponse::ResCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Token

// bytes data = 1;
inline void Token::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& Token::data() const {
  // @@protoc_insertion_point(field_get:auth.Token.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Token::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:auth.Token.data)
}
inline std::string* Token::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:auth.Token.data)
  return _s;
}
inline const std::string& Token::_internal_data() const {
  return _impl_.data_.Get();
}
inline void Token::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* Token::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* Token::release_data() {
  // @@protoc_insertion_point(field_release:auth.Token.data)
  return _impl_.data_.Release();
}
inline void Token::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:auth.Token.data)
}

// -------------------------------------------------------------------

// Error

// string message = 1;
inline void Error::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& Error::message() const {
  // @@protoc_insertion_point(field_get:auth.Error.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Error::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:auth.Error.message)
}
inline std::string* Error::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:auth.Error.message)
  return _s;
}
inline const std::string& Error::_internal_message() const {
  return _impl_.message_.Get();
}
inline void Error::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* Error::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* Error::release_message() {
  // @@protoc_insertion_point(field_release:auth.Error.message)
  return _impl_.message_.Release();
}
inline void Error::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:auth.Error.message)
}

// -------------------------------------------------------------------

// Terminal

// uint64 id = 1;
inline void Terminal::clear_id() {
  _impl_.id_ = uint64_t{0u};
}
inline uint64_t Terminal::_internal_id() const {
  return _impl_.id_;
}
inline uint64_t Terminal::id() const {
  // @@protoc_insertion_point(field_get:auth.Terminal.id)
  return _internal_id();
}
inline void Terminal::_internal_set_id(uint64_t value) {
  
  _impl_.id_ = value;
}
inline void Terminal::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:auth.Terminal.id)
}

// string number = 2;
inline void Terminal::clear_number() {
  _impl_.number_.ClearToEmpty();
}
inline const std::string& Terminal::number() const {
  // @@protoc_insertion_point(field_get:auth.Terminal.number)
  return _internal_number();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Terminal::set_number(ArgT0&& arg0, ArgT... args) {
 
 _impl_.number_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:auth.Terminal.number)
}
inline std::string* Terminal::mutable_number() {
  std::string* _s = _internal_mutable_number();
  // @@protoc_insertion_point(field_mutable:auth.Terminal.number)
  return _s;
}
inline const std::string& Terminal::_internal_number() const {
  return _impl_.number_.Get();
}
inline void Terminal::_internal_set_number(const std::string& value) {
  
  _impl_.number_.Set(value, GetArenaForAllocation());
}
inline std::string* Terminal::_internal_mutable_number() {
  
  return _impl_.number_.Mutable(GetArenaForAllocation());
}
inline std::string* Terminal::release_number() {
  // @@protoc_insertion_point(field_release:auth.Terminal.number)
  return _impl_.number_.Release();
}
inline void Terminal::set_allocated_number(std::string* number) {
  if (number != nullptr) {
    
  } else {
    
  }
  _impl_.number_.SetAllocated(number, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.number_.IsDefault()) {
    _impl_.number_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:auth.Terminal.number)
}

// string identificator = 3;
inline void Terminal::clear_identificator() {
  _impl_.identificator_.ClearToEmpty();
}
inline const std::string& Terminal::identificator() const {
  // @@protoc_insertion_point(field_get:auth.Terminal.identificator)
  return _internal_identificator();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Terminal::set_identificator(ArgT0&& arg0, ArgT... args) {
 
 _impl_.identificator_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:auth.Terminal.identificator)
}
inline std::string* Terminal::mutable_identificator() {
  std::string* _s = _internal_mutable_identificator();
  // @@protoc_insertion_point(field_mutable:auth.Terminal.identificator)
  return _s;
}
inline const std::string& Terminal::_internal_identificator() const {
  return _impl_.identificator_.Get();
}
inline void Terminal::_internal_set_identificator(const std::string& value) {
  
  _impl_.identificator_.Set(value, GetArenaForAllocation());
}
inline std::string* Terminal::_internal_mutable_identificator() {
  
  return _impl_.identificator_.Mutable(GetArenaForAllocation());
}
inline std::string* Terminal::release_identificator() {
  // @@protoc_insertion_point(field_release:auth.Terminal.identificator)
  return _impl_.identificator_.Release();
}
inline void Terminal::set_allocated_identificator(std::string* identificator) {
  if (identificator != nullptr) {
    
  } else {
    
  }
  _impl_.identificator_.SetAllocated(identificator, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.identificator_.IsDefault()) {
    _impl_.identificator_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:auth.Terminal.identificator)
}

// string description = 4;
inline void Terminal::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& Terminal::description() const {
  // @@protoc_insertion_point(field_get:auth.Terminal.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Terminal::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:auth.Terminal.description)
}
inline std::string* Terminal::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:auth.Terminal.description)
  return _s;
}
inline const std::string& Terminal::_internal_description() const {
  return _impl_.description_.Get();
}
inline void Terminal::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* Terminal::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* Terminal::release_description() {
  // @@protoc_insertion_point(field_release:auth.Terminal.description)
  return _impl_.description_.Release();
}
inline void Terminal::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:auth.Terminal.description)
}

// uint64 sessionid = 5;
inline void Terminal::clear_sessionid() {
  _impl_.sessionid_ = uint64_t{0u};
}
inline uint64_t Terminal::_internal_sessionid() const {
  return _impl_.sessionid_;
}
inline uint64_t Terminal::sessionid() const {
  // @@protoc_insertion_point(field_get:auth.Terminal.sessionid)
  return _internal_sessionid();
}
inline void Terminal::_internal_set_sessionid(uint64_t value) {
  
  _impl_.sessionid_ = value;
}
inline void Terminal::set_sessionid(uint64_t value) {
  _internal_set_sessionid(value);
  // @@protoc_insertion_point(field_set:auth.Terminal.sessionid)
}

// string number_hash = 6;
inline void Terminal::clear_number_hash() {
  _impl_.number_hash_.ClearToEmpty();
}
inline const std::string& Terminal::number_hash() const {
  // @@protoc_insertion_point(field_get:auth.Terminal.number_hash)
  return _internal_number_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Terminal::set_number_hash(ArgT0&& arg0, ArgT... args) {
 
 _impl_.number_hash_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:auth.Terminal.number_hash)
}
inline std::string* Terminal::mutable_number_hash() {
  std::string* _s = _internal_mutable_number_hash();
  // @@protoc_insertion_point(field_mutable:auth.Terminal.number_hash)
  return _s;
}
inline const std::string& Terminal::_internal_number_hash() const {
  return _impl_.number_hash_.Get();
}
inline void Terminal::_internal_set_number_hash(const std::string& value) {
  
  _impl_.number_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* Terminal::_internal_mutable_number_hash() {
  
  return _impl_.number_hash_.Mutable(GetArenaForAllocation());
}
inline std::string* Terminal::release_number_hash() {
  // @@protoc_insertion_point(field_release:auth.Terminal.number_hash)
  return _impl_.number_hash_.Release();
}
inline void Terminal::set_allocated_number_hash(std::string* number_hash) {
  if (number_hash != nullptr) {
    
  } else {
    
  }
  _impl_.number_hash_.SetAllocated(number_hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.number_hash_.IsDefault()) {
    _impl_.number_hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:auth.Terminal.number_hash)
}

// -------------------------------------------------------------------

// UserGroup

// uint64 id = 1;
inline void UserGroup::clear_id() {
  _impl_.id_ = uint64_t{0u};
}
inline uint64_t UserGroup::_internal_id() const {
  return _impl_.id_;
}
inline uint64_t UserGroup::id() const {
  // @@protoc_insertion_point(field_get:auth.UserGroup.id)
  return _internal_id();
}
inline void UserGroup::_internal_set_id(uint64_t value) {
  
  _impl_.id_ = value;
}
inline void UserGroup::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:auth.UserGroup.id)
}

// string name = 2;
inline void UserGroup::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& UserGroup::name() const {
  // @@protoc_insertion_point(field_get:auth.UserGroup.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserGroup::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:auth.UserGroup.name)
}
inline std::string* UserGroup::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:auth.UserGroup.name)
  return _s;
}
inline const std::string& UserGroup::_internal_name() const {
  return _impl_.name_.Get();
}
inline void UserGroup::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* UserGroup::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* UserGroup::release_name() {
  // @@protoc_insertion_point(field_release:auth.UserGroup.name)
  return _impl_.name_.Release();
}
inline void UserGroup::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:auth.UserGroup.name)
}

// string description = 3;
inline void UserGroup::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& UserGroup::description() const {
  // @@protoc_insertion_point(field_get:auth.UserGroup.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserGroup::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:auth.UserGroup.description)
}
inline std::string* UserGroup::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:auth.UserGroup.description)
  return _s;
}
inline const std::string& UserGroup::_internal_description() const {
  return _impl_.description_.Get();
}
inline void UserGroup::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* UserGroup::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* UserGroup::release_description() {
  // @@protoc_insertion_point(field_release:auth.UserGroup.description)
  return _impl_.description_.Release();
}
inline void UserGroup::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:auth.UserGroup.description)
}

// bool super = 4;
inline void UserGroup::clear_super() {
  _impl_.super_ = false;
}
inline bool UserGroup::_internal_super() const {
  return _impl_.super_;
}
inline bool UserGroup::super() const {
  // @@protoc_insertion_point(field_get:auth.UserGroup.super)
  return _internal_super();
}
inline void UserGroup::_internal_set_super(bool value) {
  
  _impl_.super_ = value;
}
inline void UserGroup::set_super(bool value) {
  _internal_set_super(value);
  // @@protoc_insertion_point(field_set:auth.UserGroup.super)
}

// uint64 sessionid = 5;
inline void UserGroup::clear_sessionid() {
  _impl_.sessionid_ = uint64_t{0u};
}
inline uint64_t UserGroup::_internal_sessionid() const {
  return _impl_.sessionid_;
}
inline uint64_t UserGroup::sessionid() const {
  // @@protoc_insertion_point(field_get:auth.UserGroup.sessionid)
  return _internal_sessionid();
}
inline void UserGroup::_internal_set_sessionid(uint64_t value) {
  
  _impl_.sessionid_ = value;
}
inline void UserGroup::set_sessionid(uint64_t value) {
  _internal_set_sessionid(value);
  // @@protoc_insertion_point(field_set:auth.UserGroup.sessionid)
}

// -------------------------------------------------------------------

// Session

// uint64 id = 1;
inline void Session::clear_id() {
  _impl_.id_ = uint64_t{0u};
}
inline uint64_t Session::_internal_id() const {
  return _impl_.id_;
}
inline uint64_t Session::id() const {
  // @@protoc_insertion_point(field_get:auth.Session.id)
  return _internal_id();
}
inline void Session::_internal_set_id(uint64_t value) {
  
  _impl_.id_ = value;
}
inline void Session::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:auth.Session.id)
}

// uint64 userid = 2;
inline void Session::clear_userid() {
  _impl_.userid_ = uint64_t{0u};
}
inline uint64_t Session::_internal_userid() const {
  return _impl_.userid_;
}
inline uint64_t Session::userid() const {
  // @@protoc_insertion_point(field_get:auth.Session.userid)
  return _internal_userid();
}
inline void Session::_internal_set_userid(uint64_t value) {
  
  _impl_.userid_ = value;
}
inline void Session::set_userid(uint64_t value) {
  _internal_set_userid(value);
  // @@protoc_insertion_point(field_set:auth.Session.userid)
}

// uint64 employeid = 3;
inline void Session::clear_employeid() {
  _impl_.employeid_ = uint64_t{0u};
}
inline uint64_t Session::_internal_employeid() const {
  return _impl_.employeid_;
}
inline uint64_t Session::employeid() const {
  // @@protoc_insertion_point(field_get:auth.Session.employeid)
  return _internal_employeid();
}
inline void Session::_internal_set_employeid(uint64_t value) {
  
  _impl_.employeid_ = value;
}
inline void Session::set_employeid(uint64_t value) {
  _internal_set_employeid(value);
  // @@protoc_insertion_point(field_set:auth.Session.employeid)
}

// uint64 terminalid = 4;
inline void Session::clear_terminalid() {
  _impl_.terminalid_ = uint64_t{0u};
}
inline uint64_t Session::_internal_terminalid() const {
  return _impl_.terminalid_;
}
inline uint64_t Session::terminalid() const {
  // @@protoc_insertion_point(field_get:auth.Session.terminalid)
  return _internal_terminalid();
}
inline void Session::_internal_set_terminalid(uint64_t value) {
  
  _impl_.terminalid_ = value;
}
inline void Session::set_terminalid(uint64_t value) {
  _internal_set_terminalid(value);
  // @@protoc_insertion_point(field_set:auth.Session.terminalid)
}

// uint64 branchid = 5;
inline void Session::clear_branchid() {
  _impl_.branchid_ = uint64_t{0u};
}
inline uint64_t Session::_internal_branchid() const {
  return _impl_.branchid_;
}
inline uint64_t Session::branchid() const {
  // @@protoc_insertion_point(field_get:auth.Session.branchid)
  return _internal_branchid();
}
inline void Session::_internal_set_branchid(uint64_t value) {
  
  _impl_.branchid_ = value;
}
inline void Session::set_branchid(uint64_t value) {
  _internal_set_branchid(value);
  // @@protoc_insertion_point(field_set:auth.Session.branchid)
}

// .google.protobuf.Timestamp startat = 6;
inline bool Session::_internal_has_startat() const {
  return this != internal_default_instance() && _impl_.startat_ != nullptr;
}
inline bool Session::has_startat() const {
  return _internal_has_startat();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Session::_internal_startat() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.startat_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Session::startat() const {
  // @@protoc_insertion_point(field_get:auth.Session.startat)
  return _internal_startat();
}
inline void Session::unsafe_arena_set_allocated_startat(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* startat) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.startat_);
  }
  _impl_.startat_ = startat;
  if (startat) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:auth.Session.startat)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Session::release_startat() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.startat_;
  _impl_.startat_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Session::unsafe_arena_release_startat() {
  // @@protoc_insertion_point(field_release:auth.Session.startat)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.startat_;
  _impl_.startat_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Session::_internal_mutable_startat() {
  
  if (_impl_.startat_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.startat_ = p;
  }
  return _impl_.startat_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Session::mutable_startat() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_startat();
  // @@protoc_insertion_point(field_mutable:auth.Session.startat)
  return _msg;
}
inline void Session::set_allocated_startat(::PROTOBUF_NAMESPACE_ID::Timestamp* startat) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.startat_);
  }
  if (startat) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(startat));
    if (message_arena != submessage_arena) {
      startat = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, startat, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.startat_ = startat;
  // @@protoc_insertion_point(field_set_allocated:auth.Session.startat)
}

// .google.protobuf.Timestamp endat = 7;
inline bool Session::_internal_has_endat() const {
  return this != internal_default_instance() && _impl_.endat_ != nullptr;
}
inline bool Session::has_endat() const {
  return _internal_has_endat();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Session::_internal_endat() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.endat_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Session::endat() const {
  // @@protoc_insertion_point(field_get:auth.Session.endat)
  return _internal_endat();
}
inline void Session::unsafe_arena_set_allocated_endat(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* endat) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.endat_);
  }
  _impl_.endat_ = endat;
  if (endat) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:auth.Session.endat)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Session::release_endat() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.endat_;
  _impl_.endat_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Session::unsafe_arena_release_endat() {
  // @@protoc_insertion_point(field_release:auth.Session.endat)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.endat_;
  _impl_.endat_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Session::_internal_mutable_endat() {
  
  if (_impl_.endat_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.endat_ = p;
  }
  return _impl_.endat_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Session::mutable_endat() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_endat();
  // @@protoc_insertion_point(field_mutable:auth.Session.endat)
  return _msg;
}
inline void Session::set_allocated_endat(::PROTOBUF_NAMESPACE_ID::Timestamp* endat) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.endat_);
  }
  if (endat) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(endat));
    if (message_arena != submessage_arena) {
      endat = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, endat, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.endat_ = endat;
  // @@protoc_insertion_point(field_set_allocated:auth.Session.endat)
}

// bool crash = 8;
inline void Session::clear_crash() {
  _impl_.crash_ = false;
}
inline bool Session::_internal_crash() const {
  return _impl_.crash_;
}
inline bool Session::crash() const {
  // @@protoc_insertion_point(field_get:auth.Session.crash)
  return _internal_crash();
}
inline void Session::_internal_set_crash(bool value) {
  
  _impl_.crash_ = value;
}
inline void Session::set_crash(bool value) {
  _internal_set_crash(value);
  // @@protoc_insertion_point(field_set:auth.Session.crash)
}

// string version = 9;
inline void Session::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& Session::version() const {
  // @@protoc_insertion_point(field_get:auth.Session.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Session::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:auth.Session.version)
}
inline std::string* Session::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:auth.Session.version)
  return _s;
}
inline const std::string& Session::_internal_version() const {
  return _impl_.version_.Get();
}
inline void Session::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* Session::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* Session::release_version() {
  // @@protoc_insertion_point(field_release:auth.Session.version)
  return _impl_.version_.Release();
}
inline void Session::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:auth.Session.version)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace auth

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::auth::EventType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::auth::EventType>() {
  return ::auth::EventType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_lc_5fkasse_5fauth_2fauth_2eproto
